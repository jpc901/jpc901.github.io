<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式存储系统使用kubernetes部署</title>
      <link href="/archives/282c52dc.html"/>
      <url>/archives/282c52dc.html</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ol><li><p>快速搭建k3s环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 k3s 安装脚本：</span></span><br><span class="line">curl -sfL https://get.k3s.io -o install.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行安装脚本：</span></span><br><span class="line"><span class="built_in">sudo</span> sh install.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待安装完成后，通过以下命令检查 k3s 是否已成功安装：</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status k3s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若要将当前用户添加到 Kubernetes 集群的 kubeconfig 文件中，以便能够使用 kubectl 命令行工具连接到集群，运行以下命令：</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /etc/rancher/k3s/k3s.yaml &gt;&gt; ~/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认是否已成功添加到 kubeconfig 文件中，运行以下命令：</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure></li><li><p>将其他节点加入到kubernetes集群中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Kubernetes 集群主节点的 token </span></span><br><span class="line"><span class="built_in">cat</span> /var/lib/rancher/k3s/server/node-token </span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前节点加入到主节点的集群中 </span></span><br><span class="line"><span class="built_in">sudo</span> k3s agent --server https://&lt;MASTER_IP&gt;:6443 --token &lt;NODE_TOKEN&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="创建好部署文件"><a href="#创建好部署文件" class="headerlink" title="创建好部署文件"></a>创建好部署文件</h1><p>项目分为三个部分：master(主体)， account（账户系统），rabbitmq(消息队列)<br>以account为例，创建account-deploy.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># deployment api 版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 资源类型为 deployment</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元信息</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment"># 标签</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">account-deploy</span> <span class="comment"># 具体的 key: value 配置形式</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">account-deploy</span> <span class="comment"># deployment 的名字</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">disk</span> <span class="comment"># 所在的命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment"># 期望副本数</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span> <span class="comment"># 进行滚动更新后，保留的历史版本数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，用于找到匹配的 RS</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 按照标签匹配</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">account-deploy</span> <span class="comment"># 匹配的标签key/value</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新配置</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span> <span class="comment"># 进行滚动更新时，更新的个数最多可以超过期望副本数的个数/比例</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span> <span class="comment"># 进行滚动更新时，最大不可用比例更新比例，表示在所有副本数中，最多可以有多少个不更新成功</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 更新类型，采用滚动更新</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># pod 模板</span></span><br><span class="line">    <span class="attr">metadata:</span> <span class="comment"># pod 的元信息</span></span><br><span class="line">      <span class="attr">labels:</span> <span class="comment"># pod 的标签</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">account-deploy</span></span><br><span class="line">    <span class="attr">spec:</span> <span class="comment"># pod 期望信息</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">jiapengcheng/disk-account-image:v3-amd64</span> <span class="comment"># 镜像</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 拉取策略</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">account</span> <span class="comment"># 容器名称</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span> <span class="comment"># 最多可以用多少资源</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">200m</span> <span class="comment"># 限制 cpu 最多使用 0.2 个核心</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">256Mi</span> <span class="comment"># 限制 最多使用 256兆</span></span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">18081</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span> <span class="comment"># 重启策略</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span> <span class="comment"># 删除操作最多宽限多长时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要信息：容器端口18081，限制使用资源<br>创建account-service.yaml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">account-svc</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">account-svc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">disk</span> <span class="comment"># 所在的命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span> <span class="comment"># service 端口配置的名称</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span> <span class="comment"># 端口绑定的协议，支持 TCP、UDP、SCTP，默认为 TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">18081</span> <span class="comment"># service 自己的端口</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">18081</span> <span class="comment"># 目标 pod 的端口</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选中当前 service 匹配哪些 pod，对哪些 pod 的东西流量进行代理</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">account-deploy</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure><p>主要信息，service端口18081与目标pod端口做映射，并且选择器选择匹配account-deploy。<br>因为是部署阶段，可以暂时先用NodePort服务类型作为调试，测试account服务是否可用。</p><p>最终看到我们所有的endpoints跟pod都做到一一对应基本已经没什大问题了。<br><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/20230806-175505.png" alt="图一"><br>最后检查一下各个接口调用<br><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/20230806-175505.png" alt="图二"></p><h1 id="部署过程遇到的坑"><a href="#部署过程遇到的坑" class="headerlink" title="部署过程遇到的坑"></a>部署过程遇到的坑</h1><ol><li>如果是一台机器，机器一定要有足够的剩余磁盘空间，部署时注意配置的内存限制。（否则master要是有磁盘或者内存压力就会自动产生污点无法调度，这种污点去除不掉，采用pod配置容忍依旧会因磁盘或者内存原因导致部署失败）所以建议两台虚拟机。</li><li>注意镜像打包时 —platform linux/amd64 指定镜像平台，不然也会因平台不一致导致container crash。</li><li>及时检查coreDNS pod的状态，否则就会出现容器内dns解析失败的问题，导致pod内连接我的mysql服务连接不上 <a href="https://learn.microsoft.com/zh-cn/troubleshoot/azure/azure-kubernetes/troubleshoot-dns-failure-from-pod-but-not-from-worker-node">pod内dns解析失败问题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣339场周赛（力扣题解）</title>
      <link href="/archives/14a387ba.html"/>
      <url>/archives/14a387ba.html</url>
      
        <content type="html"><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p><a href="https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/">题目链接</a></p><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个仅由 <code>0</code> 和 <code>1</code> 组成的二进制字符串 <code>s</code> 。 </p><p>如果子字符串中 <strong>所有的</strong> <code>0</code> <strong>都在</strong> <code>1</code> <strong>之前</strong> 且其中 <code>0</code> 的数量等于 <code>1</code> 的数量，则认为 <code>s</code> 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。 </p><p>返回 <code>s</code> 中最长的平衡子字符串长度。</p><p>子字符串是字符串中的一个连续字符序列。</p><h2 id="题解思路："><a href="#题解思路：" class="headerlink" title="题解思路："></a>题解思路：</h2><p>暴力遍历字符串数组，直接找连续的0和连续的1（01连续中0字符串和1字符串最小长度*2），并记录最大值即可</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTheLongestBalancedSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s);&#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &amp;&amp; s[i] == <span class="string">&#x27;0&#x27;</span> &#123;x++; i++&#125;</span><br><span class="line">        <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &amp;&amp; s[i] == <span class="string">&#x27;1&#x27;</span> &#123;y++; i++&#125;</span><br><span class="line">        res = max(res, min(x, y) * <span class="number">2</span>)<span class="comment">// 这个01连续字符串中0字符串和1字符串最小长度*2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;<span class="keyword">if</span> x &gt; y &#123;<span class="keyword">return</span> x&#125;; <span class="keyword">return</span> y&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;<span class="keyword">if</span> x &lt; y &#123;<span class="keyword">return</span> x&#125;; <span class="keyword">return</span> y&#125;</span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p><a href="https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions/">题目链接</a></p><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个整数数组 <code>nums</code> 。请你创建一个满足以下条件的二维数组：</p><ul><li>二维数组应该 <strong>只</strong> 包含数组 <code>nums</code> 中的元素。</li><li>二维数组中的每一行都包含 <strong>不同</strong> 的整数。</li><li>二维数组的行数应尽可能 <strong>少</strong> 。</li></ul><p>返回结果数组。如果存在多种答案，则返回其中任何一种。</p><p>请注意，二维数组的每一行上可以存在不同数量的元素。</p><h2 id="题解思路：-1"><a href="#题解思路：-1" class="headerlink" title="题解思路："></a>题解思路：</h2><p>map记录每个值有多少个，值元素个数最多的就是行数</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMatrix</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res [][]<span class="type">int</span></span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        mp[x]++<span class="comment">// 记录元素个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(mp) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp []<span class="type">int</span></span><br><span class="line">        <span class="keyword">for</span> k := <span class="keyword">range</span> mp &#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, k)</span><br><span class="line">            mp[k]--  </span><br><span class="line">            <span class="keyword">if</span> mp[k] == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">delete</span>(mp, k)<span class="comment">// 这个元素用完直接删除</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, tmp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p><a href="https://leetcode.cn/problems/mice-and-cheese/">题目链接</a></p><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>有两只老鼠和 <code>n</code> 块不同类型的奶酪，每块奶酪都只能被其中一只老鼠吃掉。</p><p>下标为 <code>i</code> 处的奶酪被吃掉的得分为：</p><ul><li>如果第一只老鼠吃掉，则得分为 <code>reward1[i]</code> 。</li><li>如果第二只老鼠吃掉，则得分为 <code>reward2[i]</code> 。</li></ul><p>给你一个正整数数组 <code>reward1</code> ，一个正整数数组 <code>reward2</code> ，和一个非负整数 <code>k</code> 。</p><p>请你返回第一只老鼠恰好吃掉 <code>k</code> 块奶酪的情况下，<strong>最大</strong> 得分为多少。</p><h2 id="题解思路：-2"><a href="#题解思路：-2" class="headerlink" title="题解思路："></a>题解思路：</h2><p>贪心思想：按照奶酪数组差值从大到小排序。老鼠1选择从按照差值大到小选择k个，剩下全部给老鼠2这样总得分最大。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">miceAndCheese</span><span class="params">(a []<span class="type">int</span>, b []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">type</span> s <span class="keyword">struct</span> &#123;</span><br><span class="line">        z, x, y <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    tmp := <span class="built_in">make</span>([]s, <span class="built_in">len</span>(a))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">        tmp[i] = s&#123;a[i]-b[i], a[i], b[i]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照差值排序</span></span><br><span class="line">    sort.Slice(tmp, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tmp[i].z &gt; tmp[j].z</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(tmp); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; k &#123;<span class="comment">// 老鼠1选择前k个</span></span><br><span class="line">            res += tmp[i].x</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res += tmp[i].y</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">miceAndCheese</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">tmp</span>(a.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            tmp[i] = &#123;a[i]-b[i], &#123;a[i], b[i]&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按照差值排序</span></span><br><span class="line">        <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>(), [](<span class="type">const</span> pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; x, <span class="type">const</span> pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; y)&#123;</span><br><span class="line">            <span class="keyword">return</span> x.first &gt; y.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k) res += tmp[i].second.first;<span class="comment">// 老鼠1选择前k个</span></span><br><span class="line">            <span class="keyword">else</span> res += tmp[i].second.second;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><p><a href="https://leetcode.cn/problems/minimum-reverse-operations/">题目链接</a></p><h2 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个整数 <code>n</code> 和一个在范围 <code>[0, n - 1]</code> 以内的整数 <code>p</code> ，它们表示一个长度为 <code>n</code> 且下标从 <strong>0</strong> 开始的数组 <code>arr</code> ，数组中除了下标为 <code>p</code> 处是 <code>1</code> 以外，其他所有数都是 <code>0</code> 。</p><p>同时给你一个整数数组 <code>banned</code> ，它包含数组中的一些位置。<code>banned</code> 中第 <strong>i</strong> 个位置表示 <code>arr[banned[i]] = 0</code> ，题目保证 <code>banned[i] != p</code> 。</p><p>你可以对 <code>arr</code> 进行 <strong>若干次</strong> 操作。一次操作中，你选择大小为 <code>k</code> 的一个 <strong>子数组</strong> ，并将它 <strong>翻转</strong> 。在任何一次翻转操作后，你都需要确保 <code>arr</code> 中唯一的 <code>1</code> 不会到达任何 <code>banned</code> 中的位置。换句话说，<code>arr[banned[i]]</code> 始终 <strong>保持</strong> <code>0</code> 。</p><p>请你返回一个数组 <code>ans</code> ，对于 <code>[0, n - 1]</code> 之间的任意下标 <code>i</code> ，<code>ans[i]</code> 是将 <code>1</code> 放到位置 <code>i</code> 处的 <strong>最少</strong> 翻转操作次数，如果无法放到位置 <code>i</code> 处，此数为 <code>-1</code> 。</p><ul><li><strong>子数组</strong> 指的是一个数组里一段连续 <strong>非空</strong> 的元素序列。</li><li>对于所有的 <code>i</code> ，<code>ans[i]</code> 相互之间独立计算。</li><li>将一个数组中的元素 <strong>翻转</strong> 指的是将数组中的值变成 <strong>相反顺序</strong> 。</li></ul><h2 id="题解思路：-3"><a href="#题解思路：-3" class="headerlink" title="题解思路："></a>题解思路：</h2><p>思路1：最开始直接BFS找能跳并且未跳过的位置，将这个位置加入到队列中。这样因为多了查找已经查找过的元素，导致时间复杂度超时。</p><p>思路2：采用BFS，但是并不是直接遍历，而是将遍历过的直接删除，避免因查找重复导致超时。</p><p>关键要素</p><ul><li>找到一个特征，能跳的位置一定是+2或者-2，所以可以按照奇偶存放未剩下元素。因为每次可跳位置奇偶性相同。</li><li>计算出每次可跳范围<ul><li><code>l = max(-(k - 1), k - 1 - cur * 2)；</code></li><li><code>r = min(k - 1, -(k - 1) + (n - cur - 1) * 2);</code></li></ul></li><li>从对应奇偶性集合中查找对应范围中的元素，表示为可跳元素，移出集合。</li></ul><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minReverseOperations</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p, vector&lt;<span class="type">int</span>&gt;&amp; banned, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">-2</span>)</span></span>;</span><br><span class="line">        res[p] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : banned) res[x] = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 还没被跳到的位置, 按奇偶放入set</span></span><br><span class="line">        set&lt;<span class="type">int</span>&gt; st[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (res[i] == <span class="number">-2</span>) st[i % <span class="number">2</span>].<span class="built_in">insert</span>(i);</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">while</span>  (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算可以跳的范围</span></span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            l = <span class="built_in">max</span>(-(k - <span class="number">1</span>), k - <span class="number">1</span> - cur * <span class="number">2</span>);</span><br><span class="line">            r = <span class="built_in">min</span>(k - <span class="number">1</span>, -(k - <span class="number">1</span>) + (n - cur - <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> x = (cur + (k - <span class="number">1</span>)) % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">auto</span> it = st[x].<span class="built_in">lower_bound</span>(cur + l); <span class="comment">// 找第一个大于等于的cur + l的位置</span></span><br><span class="line">            <span class="keyword">while</span> (it != st[x].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (*it &gt; cur + r) <span class="keyword">break</span>;   <span class="comment">// 超过界限</span></span><br><span class="line">                res[*it] = res[cur] + <span class="number">1</span>;    <span class="comment">// 可以跳</span></span><br><span class="line">                q.<span class="built_in">push</span>(*it);                <span class="comment">// 加入队列</span></span><br><span class="line">                it = st[x].<span class="built_in">erase</span>(it);       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span>(res[i] == <span class="number">-2</span>) res[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣336场周赛（力扣题解）</title>
      <link href="/archives/1d059c01.html"/>
      <url>/archives/1d059c01.html</url>
      
        <content type="html"><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p><a href="https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/">题目链接</a></p><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 和两个整数：<code>left</code> 和 <code>right</code> 。</p><p>如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 <strong>元音字符串</strong> ，其中元音字母是 <code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;o&#39;</code>、<code>&#39;u&#39;</code> 。</p><p>返回 <code>words[i]</code> 是元音字符串的数目，其中 <code>i</code> 在闭区间 <code>[left, right]</code> 内。</p><h2 id="题解思路："><a href="#题解思路：" class="headerlink" title="题解思路："></a>题解思路：</h2><p>暴力遍历字符串数组，直接查看前后两个字母是否是元音字母。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vowelStrings</span><span class="params">(words []<span class="type">string</span>, left <span class="type">int</span>, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    mp := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">bool</span>&#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;i&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;o&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;u&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    check := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        l := <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> mp[s[<span class="number">0</span>]] &amp;&amp; mp[s[l<span class="number">-1</span>]]&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> check(words[i])&#123;</span><br><span class="line">            res ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p><a href="https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score/">题目链接</a></p><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。你可以将 <code>nums</code> 中的元素按 <strong>任意顺序</strong> 重排（包括给定顺序）。</p><p>令 <code>prefix</code> 为一个数组，它包含了 <code>nums</code> 重新排列后的前缀和。换句话说，<code>prefix[i]</code> 是 <code>nums</code> 重新排列后下标从 <code>0</code> 到 <code>i</code> 的元素之和。<code>nums</code> 的 <strong>分数</strong> 是 <code>prefix</code> 数组中正整数的个数。</p><p>返回可以得到的最大分数。</p><h2 id="题解思路：-1"><a href="#题解思路：-1" class="headerlink" title="题解思路："></a>题解思路：</h2><p>排序后直接前缀和，查看大于0的个数就是结果</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxScore</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sort.Sort(sort.Reverse(sort.IntSlice(nums)))</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        nums[i] = nums[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line">            res++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p><a href="https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/">题目链接</a></p><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组<code>nums</code> 。每次操作中，你可以：</p><ul><li>选择两个满足 <code>0 &lt;= i, j &lt; nums.length</code> 的不同下标 <code>i</code> 和 <code>j</code> 。</li><li>选择一个非负整数 <code>k</code> ，满足 <code>nums[i]</code> 和 <code>nums[j]</code> 在二进制下的第 <code>k</code> 位（下标编号从 <strong>0</strong> 开始）是 <code>1</code> 。</li><li>将 <code>nums[i]</code> 和 <code>nums[j]</code> 都减去 <code>2k</code> 。</li></ul><p>如果一个子数组内执行上述操作若干次后，该子数组可以变成一个全为 <code>0</code> 的数组，那么我们称它是一个 <strong>美丽</strong> 的子数组。</p><p>请你返回数组 <code>nums</code> 中 <strong>美丽子数组</strong> 的数目。</p><p>子数组是一个数组中一段连续 <strong>非空</strong> 的元素序列。</p><h2 id="题解思路：-2"><a href="#题解思路：-2" class="headerlink" title="题解思路："></a>题解思路：</h2><ul><li>前缀异或和，之后用map记录前缀异或和一样的个数。（因为前缀异或和一样的就说明这段区间异或和为0）</li><li>假如异或和为3的有n个，那就就说明有(n - 1) * n / 2个子区间异或和为0，通过这个公式计算结果</li><li>还需要加上map中异或和为0的元素个数就是最终结果</li></ul><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beautifulSubarrays</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> res <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    mp[nums[<span class="number">0</span>]] = mp[nums[<span class="number">0</span>]] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        nums[i] = nums[i] ^ nums[i - <span class="number">1</span>]</span><br><span class="line">        mp[nums[i]] = mp[nums[i]] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> mp &#123;</span><br><span class="line">        <span class="keyword">var</span> x <span class="type">int64</span> = <span class="type">int64</span>(v)</span><br><span class="line">        res = res + (x * (x - <span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = res + <span class="type">int64</span>(mp[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><p><a href="https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/">题目链接</a></p><h2 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h2><p>你有一台电脑，它可以 <strong>同时</strong> 运行无数个任务。给你一个二维整数数组 <code>tasks</code> ，其中 <code>tasks[i] = [starti, endi, durationi]</code> 表示第 <code>i</code> 个任务需要在 <strong>闭区间</strong> 时间段 <code>[starti, endi]</code> 内运行 <code>durationi</code> 个整数时间点（但不需要连续）。</p><p>当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。</p><p>请你返回完成所有任务的情况下，电脑最少需要运行多少秒。</p><h2 id="题解思路：-3"><a href="#题解思路：-3" class="headerlink" title="题解思路："></a>题解思路：</h2><p>贪心：按照结束时间排序，并且按照优先靠右节点运行的方式。</p><p>用一个额外的数组，记录这个时间点是否被占用，（此题核心思想就是被占用的时间点最少，也就是重复覆盖的时间多）</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMinimumTime</span><span class="params">(tasks [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sort.Slice(tasks, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;<span class="keyword">return</span> tasks[i][<span class="number">1</span>] &lt; tasks[j][<span class="number">1</span>]&#125;)</span><br><span class="line">    st := [<span class="number">2001</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">        start, end, d := task[<span class="number">0</span>], task[<span class="number">1</span>], task[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> st[start : end + <span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">if</span> v &#123;</span><br><span class="line">                d --    <span class="comment">// 被覆盖掉</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := end; d &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">            <span class="keyword">if</span> !st[i] &#123;</span><br><span class="line">                st[i] = <span class="literal">true</span></span><br><span class="line">                d --</span><br><span class="line">                res ++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146-LRU 缓存（力扣题解）</title>
      <link href="/archives/47530237.html"/>
      <url>/archives/47530237.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="c-版"><a href="#c-版" class="headerlink" title="c++版"></a>c++版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;;    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="type">int</span> k, <span class="type">int</span> v): <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, DLinkedNode*&gt; mp;  <span class="comment">// 哈希表</span></span><br><span class="line">    DLinkedNode *head, *tail;   <span class="comment">// 头尾节点</span></span><br><span class="line">    <span class="type">int</span> size, capacity;        <span class="comment">// 链表长度，链表最大容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();   <span class="comment">// 创建头尾节点</span></span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail; </span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若不存在返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(key) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若存在返回值, 并且移动到链表头部</span></span><br><span class="line">        DLinkedNode *node = mp[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);   <span class="comment">// 移动到链表头</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果存在，修改值并且移动到链表头</span></span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">count</span>(key) == <span class="number">1</span>) &#123;</span><br><span class="line">            mp[key]-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(mp[key]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;          <span class="comment">// 不存在，检查容量，容量满足不删除，容量不满足删除</span></span><br><span class="line">            <span class="comment">// 创建节点</span></span><br><span class="line">            DLinkedNode *node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value); </span><br><span class="line">            mp[key] = node; <span class="comment">// 加入mp</span></span><br><span class="line">            <span class="built_in">addHead</span>(node); </span><br><span class="line">            size ++;</span><br><span class="line">            <span class="keyword">if</span>(size &gt; capacity) &#123;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="built_in">moveTail</span>(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到头结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode *node)</span></span>&#123;</span><br><span class="line">        <span class="built_in">moveNode</span>(node);</span><br><span class="line">        <span class="built_in">addHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveNode</span><span class="params">(DLinkedNode *node)</span></span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next; <span class="comment">// x-&gt;y-&gt;z变为x-&gt;z</span></span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev; <span class="comment">// x&lt;-y&lt;-z变为x&lt;-z</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加节点到头结点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addHead</span><span class="params">(DLinkedNode *node)</span></span>&#123;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除尾节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DLinkedNode *node = tail-&gt;prev; <span class="comment">// 尾节点</span></span><br><span class="line">        mp.<span class="built_in">erase</span>(node-&gt;key);</span><br><span class="line">        <span class="built_in">moveNode</span>(node);</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="go语言版"><a href="#go语言版" class="headerlink" title="go语言版"></a>go语言版</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span>&#123;</span><br><span class="line">    key, value <span class="type">int</span></span><br><span class="line">    prev, next *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size, capacity <span class="type">int</span></span><br><span class="line">    head, tail *DLinkedNode</span><br><span class="line">    mp <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDL</span><span class="params">(key <span class="type">int</span>, value <span class="type">int</span>)</span></span> *DLinkedNode&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">        key: key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    l := LRUCache&#123;</span><br><span class="line">        size: <span class="number">0</span>,</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        head: initDL(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        tail: initDL(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        mp: <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    l.head.next = l.tail</span><br><span class="line">    l.tail.prev = l.head</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在</span></span><br><span class="line">    <span class="keyword">if</span> _, k := this.mp[key]; !k&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 存在</span></span><br><span class="line">    node := this.mp[key]</span><br><span class="line">    this.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span> _, k := this.mp[key]; k &#123;    <span class="comment">// 存在</span></span><br><span class="line">        node := this.mp[key]</span><br><span class="line">        node.value = value</span><br><span class="line">        this.moveToHead(node)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                          <span class="comment">// 不存在</span></span><br><span class="line">        node := initDL(key, value)</span><br><span class="line">        this.mp[key] = node</span><br><span class="line">        this.addHead(node)</span><br><span class="line">        this.size++</span><br><span class="line">        <span class="keyword">if</span> this.size &gt; this.capacity &#123;</span><br><span class="line">            this.moveTail()</span><br><span class="line">            this.size--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 移动到头结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span>  moveToHead(node *DLinkedNode)&#123;</span><br><span class="line">    this.moveNode(node);</span><br><span class="line">    this.addHead(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span>  moveNode(node *DLinkedNode)&#123;</span><br><span class="line">    node.prev.next = node.next; <span class="comment">// x-&gt;y-&gt;z变为x-&gt;z</span></span><br><span class="line">    node.next.prev = node.prev; <span class="comment">// x&lt;-y&lt;-z变为x&lt;-z</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加节点到头结点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span>  addHead(node *DLinkedNode)&#123;</span><br><span class="line">    node.next = this.head.next;</span><br><span class="line">    node.next.prev = node;</span><br><span class="line">    node.prev = this.head;</span><br><span class="line">    this.head.next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除尾节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span>  moveTail()&#123;</span><br><span class="line">    node := this.tail.prev; <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="built_in">delete</span>(this.mp, node.key)</span><br><span class="line">    this.moveNode(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(capacity);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Get(key);</span></span><br><span class="line"><span class="comment"> * obj.Put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-防止缓存击穿与protobuf通信（Go实现分布式缓存）</title>
      <link href="/archives/fcbe13c3.html"/>
      <url>/archives/fcbe13c3.html</url>
      
        <content type="html"><![CDATA[<h1 id="防止缓存击穿"><a href="#防止缓存击穿" class="headerlink" title="防止缓存击穿"></a>防止缓存击穿</h1><h2 id="什么是缓存雪崩、击穿、穿透？"><a href="#什么是缓存雪崩、击穿、穿透？" class="headerlink" title="什么是缓存雪崩、击穿、穿透？"></a>什么是缓存雪崩、击穿、穿透？</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228200819499.png" alt="缓存雪崩"></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228200905423.png" alt="缓存击穿"></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228200918495.png" alt="缓存穿透"></p><h2 id="使用-singleflight-防止缓存击穿"><a href="#使用-singleflight-防止缓存击穿" class="headerlink" title="使用 singleflight 防止缓存击穿"></a>使用 singleflight 防止缓存击穿</h2><ol><li><p>定义请求对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">  wg sync.WaitGroup <span class="comment">// 控制线程是否等待</span></span><br><span class="line">  val <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 请求返回结果</span></span><br><span class="line">  err <span class="type">error</span> <span class="comment">// 错误信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>存储请求对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group 存储请求对象</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex       <span class="comment">// 线程安全必须上锁</span></span><br><span class="line">m  <span class="keyword">map</span>[<span class="type">string</span>]*call <span class="comment">// server 端需要记录一下这次请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新定义访问缓存的方法</p><ul><li>查询是否有相同的请求在查询缓存</li><li>当前有请求就要排队，排队完, 拿到前面处理完成的请求结果就返回</li><li>创建一个请求对象，如果其他请求来了就先让其等等，自己请求完成再给他放行</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Do(key <span class="type">string</span>, fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">c.wg.Wait()         <span class="comment">// 如果请求正在进行中，则等待</span></span><br><span class="line"><span class="keyword">return</span> c.val, c.err <span class="comment">// 请求结束，返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个请求对象</span></span><br><span class="line">c := <span class="built_in">new</span>(call)</span><br><span class="line"><span class="comment">// 发起请求前加锁</span></span><br><span class="line">c.wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 添加到 g.m，表明 key 已经有对应的请求在处理</span></span><br><span class="line">g.m[key] = c</span><br><span class="line"></span><br><span class="line">c.val, c.err = fn() <span class="comment">// 调用 fn，发起请求</span></span><br><span class="line">c.wg.Done()         <span class="comment">// 请求结束</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(g.m, key) <span class="comment">// 更新 g.m</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c.val, c.err <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="使用-protobuf-进行节点间通信"><a href="#使用-protobuf-进行节点间通信" class="headerlink" title="使用 protobuf 进行节点间通信"></a>使用 protobuf 进行节点间通信</h1><p>把原先的 http 换成了 rpc, 目的就是提升性能</p><blockquote><p>protobuf 即 Protocol Buffers，Google 开发的一种数据描述语言，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。protobuf 以二进制方式存储，占用空间小。</p></blockquote><ol><li><p>定义 protpbuf 文件</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syntax=<span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> geecachepb;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./&quot;</span>; <span class="comment">// 指定生成的go文件所在path</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Request</span> &#123;</span><br><span class="line">  <span class="type">string</span> <span class="keyword">group</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> key = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Response</span> &#123;</span><br><span class="line">  <span class="type">bytes</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">GroupCache</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Get(Request) <span class="keyword">returns</span> (Response)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>重新定义原有的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PeerGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(in *pb.Request, out *pb.Response) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> getFromPeer(peer PeerGetter, key <span class="type">string</span>) (ByteView, <span class="type">error</span>) &#123;</span><br><span class="line">req := &amp;pb.Request&#123;</span><br><span class="line">Group: g.name,</span><br><span class="line">Key:   key,</span><br><span class="line">&#125;</span><br><span class="line">res := &amp;pb.Response&#123;&#125;</span><br><span class="line">err := peer.Get(req, res)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ByteView&#123;b: res.Value&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HTTPPool)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Write the value to the response body as a proto message.</span></span><br><span class="line">body, err := proto.Marshal(&amp;pb.Response&#123;Value: view.ByteSlice()&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/octet-stream&quot;</span>)</span><br><span class="line">w.Write(body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *httpGetter)</span></span> Get(in *pb.Request, out *pb.Response) <span class="type">error</span> &#123;</span><br><span class="line">u := fmt.Sprintf(</span><br><span class="line"><span class="string">&quot;%v%v/%v&quot;</span>,</span><br><span class="line">h.baseURL,</span><br><span class="line">url.QueryEscape(in.GetGroup()),</span><br><span class="line">url.QueryEscape(in.GetKey()),</span><br><span class="line">)</span><br><span class="line">    res, err := http.Get(u)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> err = proto.Unmarshal(bytes, out); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decoding response body: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>完结 🎉</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-多节点间的通信（Go实现分布式缓存）</title>
      <link href="/archives/1cd762e8.html"/>
      <url>/archives/1cd762e8.html</url>
      
        <content type="html"><![CDATA[<h1 id="多节点间的通信"><a href="#多节点间的通信" class="headerlink" title="多节点间的通信"></a>多节点间的通信</h1><h2 id="远程访问流程"><a href="#远程访问流程" class="headerlink" title="远程访问流程"></a>远程访问流程</h2><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228194630542.png" alt="远程访问流程"></p><ul><li>当 <strong>客户端</strong> 发送一个查询请求达到某个<strong>缓存节点</strong>时, 该节点会先判断 <code>key</code> 是否在本地, 不在的话, 再通过发送网络请求去访问其他 <code>node</code> 节点。</li><li>每个 <strong>node</strong> 既要处理来自客户端这样的外部请求, 也要处理来自其他远端节点的内部请求。</li><li>我们需要在 <strong>node</strong> 内部, 启动两个 http 服务, 一个处理客户端请求(APIServer), 一个处理节点的请求(CacheServer).</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228195141212.png" alt="请求处理"></p><ol><li><p>定义一个查询节点的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PeerPicker <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// PickPeer 于根据传入的 key 选择相应节点(选择相应的节点方法)</span></span><br><span class="line">PickPeer(key <span class="type">string</span>) (peer PeerGetter, ok <span class="type">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>通过网络请求帮我们拿到缓存结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个接口为我们提供需要的能力.</span></span><br><span class="line"><span class="keyword">type</span> PeerGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(group <span class="type">string</span>, key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>实现 <code>PeerGetter#Get</code> 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先需要定义一个 struct 实现 PeerGetter 接口</span></span><br><span class="line"><span class="keyword">type</span> httpGetter <span class="keyword">struct</span> &#123;</span><br><span class="line">baseURL <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 实现接口对应的方法, 这个接口能提供访问网络接口拿到缓存数据。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *httpGetter)</span></span> Get(group <span class="type">string</span>, key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 访问 http 接口的逻辑</span></span><br><span class="line">u := fmt.Sprintf(</span><br><span class="line"><span class="string">&quot;%v%v/%v&quot;</span>,</span><br><span class="line">h.baseURL,</span><br><span class="line">url.QueryEscape(group),</span><br><span class="line">url.QueryEscape(key),</span><br><span class="line">)</span><br><span class="line">res, err := http.Get(u)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;server returned: %v&quot;</span>, res.Status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bytes, err := ioutil.ReadAll(res.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;reading response body: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bytes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>当我们 <strong>cache</strong> 服务启动时, 肯定要往 <strong>hash 环</strong> 添加节点(真实 + 虚拟)的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">defaultBasePath = <span class="string">&quot;/_gocache/&quot;</span></span><br><span class="line">defaultReplicas = <span class="number">50</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HttpPool <span class="keyword">struct</span> &#123;</span><br><span class="line">self        <span class="type">string</span>                 <span class="comment">// 记录本地地址和端口</span></span><br><span class="line">basePath    <span class="type">string</span>                 <span class="comment">// 基础路径</span></span><br><span class="line">mu          sync.Mutex             <span class="comment">// 保护peer和httpGetters</span></span><br><span class="line">peers       *consistenthash.Map    <span class="comment">// 根据具体的 key 选择节点</span></span><br><span class="line">httpGetters <span class="keyword">map</span>[<span class="type">string</span>]*httpGetter <span class="comment">// 每一个远程节点对应一个 httpGetter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set 更新节点列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HttpPool)</span></span> Set(peers ...<span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">// 因为 hash 环的 map 不是线程安全的,所以这里要加锁.</span></span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">p.peers = consistenthash.New(defaultReplicas, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 调用上一章节的方法, 在 hash 环上添加真实节点和虚拟节点</span></span><br><span class="line">p.peers.Add(peers...)</span><br><span class="line"><span class="comment">// 存储远端节点信息</span></span><br><span class="line">p.httpGetters = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*httpGetter, <span class="built_in">len</span>(peers))</span><br><span class="line"><span class="keyword">for</span> _, peer := <span class="keyword">range</span> peers &#123;</span><br><span class="line">p.httpGetters[peer] = &amp;httpGetter&#123;baseURL: peer + p.basePath&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PickPeer 根据key选择一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *HttpPool)</span></span> PickPeer(key <span class="type">string</span>) (PeerGetter, <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// 因为 hash 环的 map 不是线程安全的,所以这里要加锁.</span></span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line"><span class="comment">// p.peers 是个 哈希环, 通过调用它的 Get 方法拿到远端节点.</span></span><br><span class="line"><span class="comment">// 这里的 peer 是个地址.</span></span><br><span class="line"><span class="keyword">if</span> peer := p.peers.Get(key); peer != <span class="string">&quot;&quot;</span> &amp;&amp; peer != p.self &#123;</span><br><span class="line">p.Log(<span class="string">&quot;Pick peer %s&quot;</span>, peer)</span><br><span class="line"><span class="keyword">return</span> p.httpGetters[peer], <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ PeerPicker = (*HttpPool)(<span class="literal">nil</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>缓存节点启动的流程。</p><ol><li>创建 Group 对象.(用于存储缓存数据)</li><li>启动缓存 http 服务.(创建 HttpPool，添加节点信息，注册到 group 中)</li><li>启动 API 服务.(用于与客户端进行交互)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-一致性哈希（Go实现分布式缓存）</title>
      <link href="/archives/c950065c.html"/>
      <url>/archives/c950065c.html</url>
      
        <content type="html"><![CDATA[<h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><h2 id="普通hash算法"><a href="#普通hash算法" class="headerlink" title="普通hash算法"></a>普通hash算法</h2><p><strong>普通的hash算法在分布式应用中的不足</strong></p><p>在分布式的存储系统中，要将数据存储到具体的节点上，如果我们采用<strong>普通的hash算法</strong>进行路由，将<strong>数据映射到具体的节点</strong>上，如<strong>key%N</strong>，key是数据的<strong>哈希值</strong>，N是服务器<strong>节点数</strong>。</p><p>如果有一个节点加入或退出这个集群，也就意味着几乎缓存值对应的节点都发生了改变。即几乎所有的缓存值都失效了。节点在接收到对应的请求时，均需要重新去数据源获取数据，容易引起 <code>缓存雪崩</code>。</p><h2 id="一致性哈希-1"><a href="#一致性哈希-1" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><h3 id="一致性哈希原理"><a href="#一致性哈希原理" class="headerlink" title="一致性哈希原理"></a>一致性哈希原理</h3><p>哈希算法是对节点的数量进行取模运算，而一致性哈希是对2^32进行取模运算。一致性哈希将整个哈希值空间组成一个虚拟的圆环，也就是哈希环。</p><ul><li>计算节点/机器(通常使用节点的名称、编号和 IP 地址)的哈希值，放置在环上。</li><li>计算 key 的哈希值，放置在环上，顺时针寻找到的第一个节点，就是应选取的节点/机器。</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228163617232.png" alt="一致性哈希原理"></p><p><strong>在一致性哈希算法中，如果某个节点宕机不可用了，那么受影响的数据仅仅是会寻址到此节点和前一节点之间的数据</strong>。</p><h3 id="一致性哈希数据倾斜"><a href="#一致性哈希数据倾斜" class="headerlink" title="一致性哈希数据倾斜"></a>一致性哈希数据倾斜</h3><p>在一致性哈希算法中，如果节点太少，容易因为节点分布不均匀造成数据访问的冷热不均，也就是说大多数访问请求都会集中少量几个节点上。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228164110847.png" alt="数据倾斜"></p><p>通过引入虚拟节点解决分布不均匀的问题。对每一个服务器节点计算多个哈希值，每个计算结果位置上都放置一个虚拟节点，并将虚拟节点映射到实际节点。比如，可以在主机名后面增加编号，分别计算Node-A-01、Node-A-02、Node-B-01、Node-B-02、Node-C-01、Node-C-02的哈希值，于是形成6个虚拟节点。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228164408105.png" alt="虚拟节点"></p><p>增加了节点后，节点在哈希环上的分布就相对均匀了。如果有访问请求寻址到Node-A-01这个虚拟节点，将被重定位到节点A。</p><p>参考：</p><p><a href="https://blog.csdn.net/qq_40378034/article/details/117870061">一致性哈希算法详解</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">hash     Hash           <span class="comment">// hash函数，crc32哈希</span></span><br><span class="line">replicas <span class="type">int</span>            <span class="comment">// 虚拟节点倍数</span></span><br><span class="line">keys     []<span class="type">int</span>          <span class="comment">// 哈希环，环中元素是已经排序的</span></span><br><span class="line">hashMap  <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> <span class="comment">// 虚拟节点和真实节点的映射关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>虚拟节点和真实节点的倍数关系</p></li><li><p>虚拟节点和真实节点的映射关系</p></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>Add添加缓存节点</p><ul><li>虚拟节点名称为序号+key名称</li><li>循环replicas次，计算虚拟节点的哈希值，进行类型转换</li><li>添加到哈希环中</li><li>维护虚拟节点到真实节点之间的映射</li><li>最后对哈希环排序</li></ul></li><li><p>Get选择缓存节点</p><ul><li>校验数据有效性</li><li>计算key的哈希值</li><li>顺时针找到哈希环上的第一个匹配的虚拟节点的下标</li><li>通过hashMap定位到真实的缓存节点</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> consistenthash</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;hash/crc32&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash hash函数类型</span></span><br><span class="line"><span class="keyword">type</span> Hash <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">hash     Hash           <span class="comment">// hash函数，crc32哈希</span></span><br><span class="line">replicas <span class="type">int</span>            <span class="comment">// 虚拟节点倍数</span></span><br><span class="line">keys     []<span class="type">int</span>          <span class="comment">// 哈希环，环中元素是已经排序的</span></span><br><span class="line">hashMap  <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> <span class="comment">// 虚拟节点和真实节点的映射关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建一个Map实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(replicas <span class="type">int</span>, fn Hash)</span></span> *Map &#123;</span><br><span class="line">m := &amp;Map&#123;</span><br><span class="line">replicas: replicas,</span><br><span class="line">hash:     fn,</span><br><span class="line">hashMap:  <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>), <span class="comment">// 初始化map函数，map必须要进行初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认用crc32</span></span><br><span class="line"><span class="keyword">if</span> m.hash == <span class="literal">nil</span> &#123;</span><br><span class="line">m.hash = crc32.ChecksumIEEE</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 可以一次性添加多个缓存服务器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Add(keys ...<span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟节点名称为序号+key名称</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.replicas; i++ &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算虚拟节点的哈希值，进行类型转换</span></span><br><span class="line">hash := <span class="type">int</span>(m.hash([]<span class="type">byte</span>(strconv.Itoa(i) + key)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到哈希环中</span></span><br><span class="line">m.keys = <span class="built_in">append</span>(m.keys, hash)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护虚拟节点到真实节点之间的映射</span></span><br><span class="line">m.hashMap[hash] = key</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对哈希环进行排序</span></span><br><span class="line">sort.Ints(m.keys)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 选择缓存节点函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Get(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">// 校验数据有效性</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(m.keys) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算key的哈希值</span></span><br><span class="line">hash := <span class="type">int</span>(m.hash([]<span class="type">byte</span>(key)))</span><br><span class="line"><span class="comment">// 顺时针找到哈希环上的第一个匹配的虚拟节点的下标</span></span><br><span class="line">idx := sort.Search(<span class="built_in">len</span>(m.keys), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> m.keys[i] &gt;= hash</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过hashMap定位到真实的缓存节点</span></span><br><span class="line"><span class="keyword">return</span> m.hashMap[m.keys[idx%<span class="built_in">len</span>(m.keys)]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>学习到了什么是一致性哈希，了解了一致性哈希是如何解决数据倾斜的原理。</li><li>了解了如何通过一致性哈希算法来进行分布式缓存。</li></ol><p>参考：</p><p><a href="https://blog.csdn.net/qq_40378034/article/details/117870061">一致性哈希算法详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-基于HTTP的分布式缓存（Go实现分布式缓存）</title>
      <link href="/archives/2ea663e2.html"/>
      <url>/archives/2ea663e2.html</url>
      
        <content type="html"><![CDATA[<h1 id="基于HTTP的分布式缓存"><a href="#基于HTTP的分布式缓存" class="headerlink" title="基于HTTP的分布式缓存"></a>基于HTTP的分布式缓存</h1><p>目的：通过main 函数启动 HTTP Server测试API</p><h2 id="Cache-HTTP-服务端"><a href="#Cache-HTTP-服务端" class="headerlink" title="Cache HTTP 服务端"></a>Cache HTTP 服务端</h2><p>分布式缓存需要实现节点间通信，建立基于 HTTP 的通信机制是比较常见和简单的做法。如果一个节点启动了 HTTP 服务，那么这个节点就可以被其他节点访问。</p><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><ul><li>默认通信地址前缀是<code>defaultBasePath = &quot;/_gocache/&quot;</code>。</li><li>首先判断url路径中是否包含 basePath。</li><li>把groupname/key字符截断为groupname和key。</li><li>通过groupname获取Group对象。</li><li>使用Group对象方法和key来获取key对应的缓存值。</li><li>将缓存值作为http body进行响应。</li></ul><h3 id="代码http-go"><a href="#代码http-go" class="headerlink" title="代码http.go"></a>代码http.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultBasePath = <span class="string">&quot;/_gocache/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HttpPool <span class="keyword">struct</span> &#123;</span><br><span class="line">self     <span class="type">string</span> <span class="comment">// 记录本地地址和端口</span></span><br><span class="line">basePath <span class="type">string</span> <span class="comment">// 基础路径</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPPool</span><span class="params">(self <span class="type">string</span>)</span></span> *HttpPool &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;HttpPool&#123;</span><br><span class="line">self:     self,</span><br><span class="line">basePath: defaultBasePath,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hp *HttpPool)</span></span> ServeHTTP(resp http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line"><span class="comment">// 1. 判断url路径中是否包含 basePath</span></span><br><span class="line">url := req.URL.Path</span><br><span class="line"><span class="keyword">if</span> !strings.HasPrefix(url, hp.basePath) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;http request path is invalid&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. url路径为/_groupcache/&lt;groupname&gt;/&lt;key&gt;  -&gt; &lt;groupname&gt;/&lt;key&gt;</span></span><br><span class="line">path := url[<span class="built_in">len</span>(hp.basePath):]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 把&lt;groupname&gt;/&lt;key&gt;字符截断为groupname和key</span></span><br><span class="line">parts := strings.SplitN(path, <span class="string">&quot;/&quot;</span>, <span class="number">2</span>)</span><br><span class="line">groupName := parts[<span class="number">0</span>]</span><br><span class="line">key := parts[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 通过groupname获取Group对象</span></span><br><span class="line">group := GetGroup(groupName)</span><br><span class="line"><span class="keyword">if</span> group == <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(resp, <span class="string">&quot;no such group: &quot;</span>+groupName, http.StatusNotFound)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 使用Group对象方法和key来获取key对应的缓存值</span></span><br><span class="line">byteview, err := group.Get(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(resp, err.Error(), http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6. 将缓存值作为http body进行响应</span></span><br><span class="line">resp.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/octet-stream&quot;</span>)</span><br><span class="line">resp.Write(byteview.ByteSlice())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>使用 map 模拟了数据源 db。</li><li>创建一个名为 scores 的 Group，若缓存为空，回调函数会从 db 中获取数据并返回。</li><li>使用 http.ListenAndServe 在 9999 端口启动了 HTTP 服务。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;Cache/Cache&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;Tom&quot;</span>:  <span class="string">&quot;630&quot;</span>,</span><br><span class="line"><span class="string">&quot;Jack&quot;</span>: <span class="string">&quot;589&quot;</span>,</span><br><span class="line"><span class="string">&quot;Sam&quot;</span>:  <span class="string">&quot;567&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Cache.NewGroup(<span class="string">&quot;scores&quot;</span>, <span class="number">2</span>&lt;&lt;<span class="number">10</span>, Cache.GetterFunc(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">log.Println(<span class="string">&quot;[SlowDB] search key&quot;</span>, key)</span><br><span class="line"><span class="keyword">if</span> v, ok := db[key]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(v), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%s not exist&quot;</span>, key)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">addr := <span class="string">&quot;localhost:9999&quot;</span></span><br><span class="line">peers := Cache.NewHTTPPool(addr)</span><br><span class="line">log.Println(<span class="string">&quot;gocache is running at&quot;</span>, addr)</span><br><span class="line">log.Fatal(http.ListenAndServe(addr, peers))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试API"><a href="#测试API" class="headerlink" title="测试API"></a>测试API</h3><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228155704150.png" alt="测试1"></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228155636015.png" alt="测试2"></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228155523885.png" alt="测试结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过main 函数启动 HTTP Server测试API。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-实现单机缓存并发控制（Go实现分布式缓存）</title>
      <link href="/archives/d05a0b6f.html"/>
      <url>/archives/d05a0b6f.html</url>
      
        <content type="html"><![CDATA[<h1 id="单机缓存并发控制"><a href="#单机缓存并发控制" class="headerlink" title="单机缓存并发控制"></a>单机缓存并发控制</h1><h2 id="通过互斥锁Mutex实现-LRU-缓存的并发控制"><a href="#通过互斥锁Mutex实现-LRU-缓存的并发控制" class="headerlink" title="通过互斥锁Mutex实现 LRU 缓存的并发控制"></a>通过互斥锁Mutex实现 LRU 缓存的并发控制</h2><h3 id="封装一个只读数据结构"><a href="#封装一个只读数据结构" class="headerlink" title="封装一个只读数据结构"></a>封装一个只读数据结构</h3><ul><li>使用[]byte，支持各种数据类型。</li><li>封装一个ByteView结构体，并且在返回时，返回一个拷贝，防止缓存值被外部程序修改。</li></ul><p>byteview.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Cache</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">缓存值的抽象与封装</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ByteView 只读数据结构</span></span><br><span class="line"><span class="keyword">type</span> ByteView <span class="keyword">struct</span> &#123;</span><br><span class="line">b []<span class="type">byte</span> <span class="comment">// 存储真实缓存值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回其所占的内存大小。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(v.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ByteSlice 返回一个拷贝，防止缓存值被外部程序修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span></span> ByteSlice() []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="keyword">return</span> cloneBytes(v.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 以字符串形式返回数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v ByteView)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(v.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cloneBytes</span><span class="params">(b []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line"><span class="built_in">copy</span>(c, b)</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用锁进行并发控制"><a href="#使用锁进行并发控制" class="headerlink" title="使用锁进行并发控制"></a>使用锁进行并发控制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;Cache/Cache/lru&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主要是进行并发控制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持并发读写的lru缓存</span></span><br><span class="line"><span class="keyword">type</span> cache <span class="keyword">struct</span> &#123;</span><br><span class="line">mu         sync.Mutex</span><br><span class="line">lru        *lru.Cache</span><br><span class="line">cacheBytes <span class="type">int64</span> <span class="comment">// 缓存最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向缓存中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> add(key <span class="type">string</span>, value ByteView) &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="comment">// 使用延迟初始化，将该对象的创建延迟至第一次使该对象</span></span><br><span class="line"><span class="comment">// 主要用于提高性能，并且减少程序内存要求</span></span><br><span class="line"><span class="keyword">if</span> c.lru == <span class="literal">nil</span> &#123;</span><br><span class="line">c.lru = lru.New(c.cacheBytes, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.lru.Add(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从缓存中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> get(key <span class="type">string</span>) (value ByteView, ok <span class="type">bool</span>) &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> c.lru == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v, ok := c.lru.Get(key); ok &#123;</span><br><span class="line"><span class="keyword">return</span> v.(ByteView), ok <span class="comment">// 转化成ByteView类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主体结构-Group（最核心）"><a href="#主体结构-Group（最核心）" class="headerlink" title="主体结构 Group（最核心）"></a>主体结构 Group（最核心）</h2><p>Group是最核心的数据结构，负责用户的交互，并且控制缓存值，存储和获取的流程。</p><h3 id="Group流程"><a href="#Group流程" class="headerlink" title="Group流程"></a>Group流程</h3><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20230228151759527.png" alt="Group流程图"></p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>如果缓存不存在，应从数据源获取数据并添加到缓存中。</p><p>当缓存不存在时，调用这个函数，得到源数据。</p><p>gocache.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">负责与外部交互，控制缓存存储和获取的主流程</span></span><br><span class="line"><span class="comment">设计了一个回调函数，在缓存不存在时，调用这个函数，得到源数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Getter 通过回调函数加载数据</span></span><br><span class="line"><span class="keyword">type</span> Getter <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数类型</span></span><br><span class="line"><span class="keyword">type</span> GetterFunc <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 实现 Getter 接口方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f GetterFunc)</span></span> Get(key <span class="type">string</span>) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> f(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Group定义"><a href="#Group定义" class="headerlink" title="Group定义"></a>Group定义</h3><p>创建Group实例：</p><ol><li>判断getter是否为空</li><li>新建Group对象</li><li>将group对象添加到group中</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group 是一个缓存的命名空间</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">name      <span class="type">string</span></span><br><span class="line">getter    Getter <span class="comment">// 缓存未命中时获取源数据的回调(callback)</span></span><br><span class="line">mainCache cache  <span class="comment">// 并发缓存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">mu     sync.RWMutex <span class="comment">// 读写锁</span></span><br><span class="line">groups = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*Group) <span class="comment">// 存储所有Group信息的映射表</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewGroup 创建Group实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGroup</span><span class="params">(name <span class="type">string</span>, cacheBytes <span class="type">int64</span>, getter Getter)</span></span> *Group &#123;</span><br><span class="line"><span class="comment">// 判断getter是否为空</span></span><br><span class="line">    <span class="keyword">if</span> getter == <span class="literal">nil</span> &#123; </span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;nil Getter&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新建Group对象</span></span><br><span class="line">g := &amp;Group&#123;</span><br><span class="line">name:      name,</span><br><span class="line">getter:    getter,</span><br><span class="line">mainCache: cache&#123;cacheBytes: cacheBytes&#125;,</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 将group对象添加到group中</span></span><br><span class="line">groups[name] = g</span><br><span class="line"><span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从缓存获取key的value-Get最核心方法"><a href="#从缓存获取key的value-Get最核心方法" class="headerlink" title="从缓存获取key的value(Get最核心方法)"></a>从缓存获取key的value(Get最核心方法)</h3><ol><li>获取一个key值，首先查看本地缓存，如果命中直接返回。</li><li>如果没有命中缓存，调用Getter函数来拉去数据。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetGroup 返回之前用NewGroup创建的命名组，如果没有这样的组则为nil。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetGroup</span><span class="params">(name <span class="type">string</span>)</span></span> *Group &#123;</span><br><span class="line">mu.RLock()</span><br><span class="line">g := groups[name]</span><br><span class="line">mu.RUnlock()</span><br><span class="line"><span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 从缓存中获取一个key的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> Get(key <span class="type">string</span>) (ByteView, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// key为nil，返回</span></span><br><span class="line"><span class="keyword">if</span> key == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ByteView&#123;&#125;, fmt.Errorf(<span class="string">&quot;key is required&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命中会直接返回，从本地缓存中查找</span></span><br><span class="line"><span class="keyword">if</span> v, ok := g.mainCache.get(key); ok &#123;</span><br><span class="line">log.Println(<span class="string">&quot;[GoCache] hit&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未命中，查找失败调用Getter函数来拉去数据</span></span><br><span class="line"><span class="keyword">return</span> g.load(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> load(key <span class="type">string</span>) (value ByteView, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>优先从远程节点获取</span></span><br><span class="line">    <span class="comment">// 远程节点没有，调用Getter函数来获取</span></span><br><span class="line"><span class="keyword">return</span> g.getLocally(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取本地数据源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> getLocally(key <span class="type">string</span>) (ByteView, <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  调用用户回调函数 g.getter.Get() 获取源数据</span></span><br><span class="line">bytes, err := g.getter.Get(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ByteView&#123;&#125;, err</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将数据组成装成ByteView格式</span></span><br><span class="line">value := ByteView&#123;b: cloneBytes(bytes)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将源数据添加到缓存 mainCache 中</span></span><br><span class="line">g.populateCache(key, value)</span><br><span class="line"><span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将源数据添加到缓存 mainCache 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span></span> populateCache(key <span class="type">string</span>, value ByteView) &#123;</span><br><span class="line">g.mainCache.add(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>了解了Group设计原理。</li><li>实现了用互斥锁实现缓存并发控制。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-实现LRU缓存淘汰策略（Go实现分布式缓存）</title>
      <link href="/archives/44ed92c8.html"/>
      <url>/archives/44ed92c8.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="为什么需要分布式缓存"><a href="#为什么需要分布式缓存" class="headerlink" title="为什么需要分布式缓存"></a>为什么需要分布式缓存</h2><ol><li><strong>减少数据库压力</strong>：缓存数据一般是在内存中，而数据库中的数据一般是在磁盘上，二者的存储速度有着非常大的差距，数据库的操作很耗时，对于一些热点数据，一般都会被暂存在分布式缓存服务器集群中，减轻数据库压力。</li><li><strong>优化请求响应时间</strong>：如果请求命中缓存，就会直接返回，速度较快，不用再去请求数据库。</li><li><strong>支持高可用</strong>：如果缓存时单点服务，那这台服务器宕机之后，就不能继续进行缓存服务。如果缓存服务器没有数据分片的能力，那么当某个热点key所在的服务器宕机后，容易出现缓存击穿问题。</li></ol><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>​    这个项目模仿了 <a href="https://github.com/golang/groupcache">groupcache</a> 的实现。</p><ol><li>采用最近最少访问算法进行<a href="https://jpcly.cn/archives/44ed92c8.html">缓存淘汰</a>。</li><li>实现了<a href="https://jpcly.cn/archives/d05a0b6f.html">单机缓存</a>和基于<a href="https://jpcly.cn/archives/2ea663e2.html">HTTP的分布式缓存</a>。</li><li>使用Go锁机制<a href="https://jpcly.cn/archives/fcbe13c3.html">防止缓存击穿</a>。</li><li>使用<a href="https://jpcly.cn/archives/c950065c.html">一致性哈希</a>选择节点，实现负载均衡。</li><li>使用<a href="https://jpcly.cn/archives/fcbe13c3.html">protobuf</a>优化节点之间二进制通信。</li></ol><p>​    通过学习这个项目去了解分布式缓存如何设计，体会go语言的精巧，也感受一下设计之美。</p><h1 id="实现LRU缓存淘汰策略"><a href="#实现LRU缓存淘汰策略" class="headerlink" title="实现LRU缓存淘汰策略"></a>实现LRU缓存淘汰策略</h1><h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>一般常见的缓存淘汰策略有：FIFO，LFU 和 LRU。</p><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>FIFO是先进先出，淘汰缓存中<strong>最老的</strong>记录。</p><p><strong>原因</strong>：最早添加的记录，其不再被使用的可能性比刚添加的时候大。</p><p><strong>实现</strong>：创建一个队列，新增记录添加到队尾，每次内存不够时，淘汰队首。</p><p><strong>缺点</strong>：部分记录虽然最早添加但也最常被访问，如果采用FIFO策略，这种数据会被频繁的添加进缓存，又被淘汰出去，导致缓存命中率降低。</p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>LFU是最近最不常用算法，也就是淘汰缓存中访问<strong>频率最低</strong>的记录。</p><p><strong>原因</strong>：如果数据过去被访问多次，那么将来被访问的频率也更高。</p><p><strong>实现</strong>：维护一个按照访问次数排序的队列，每次访问，访问次数+1，队列重新排序。</p><p><strong>缺点</strong>：如果历史上某个数据访问次数非常高，之后便几乎不再访问，导致迟迟不能淘汰。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>LRU是最近最少使用。</p><p><strong>原因</strong>：如果数据最近被访问过，那么将来被访问的概率也会更高。</p><p><strong>实现</strong>：维护一个队列，如果某条记录被访问了，则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。</p><p><strong>缺点</strong>：LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在缓存中很长一段时间，造成<strong>缓存污染</strong>。</p><h2 id="采用LRU实现缓存淘汰策略"><a href="#采用LRU实现缓存淘汰策略" class="headerlink" title="采用LRU实现缓存淘汰策略"></a>采用LRU实现缓存淘汰策略</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>字典：存储键和值的映射关系。这样可以根据某个key查找到对应的value，时间复杂度为O(1)，在字典中插入一条记录的时间复杂度也是O(1)。</li><li>双向链表：将所有的值放到双向链表中，这样当访问到某个值时，将其移动到队列尾部的时间复杂度为O(1)，在队尾新增一条记录以及删除一条记录的复杂度均为O(1)。（队首队尾是相对的，约定front为队尾，back为队首）</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>lru.go文件</p><h4 id="对象的封装"><a href="#对象的封装" class="headerlink" title="对象的封装"></a>对象的封装</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lru</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache 是LRU缓存，对于并发访问是不安全的。</span></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">maxBytes <span class="type">int64</span> <span class="comment">// 允许使用的最大内存</span></span><br><span class="line">nbytes   <span class="type">int64</span> <span class="comment">// 已经使用的最大内存</span></span><br><span class="line">ll       *list.List</span><br><span class="line">cache    <span class="keyword">map</span>[<span class="type">string</span>]*list.Element <span class="comment">// 键是字符串，值是双向链表中节点的指针</span></span><br><span class="line"><span class="comment">// 某条记录被移除时的回调函数，可为nil。</span></span><br><span class="line">OnEvicted <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>, value Value)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点的数据类型</span></span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="type">string</span> <span class="comment">// 淘汰队首节点时，用key删除对应映射</span></span><br><span class="line">value Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value 用Len来计算它需要多少字节（返回值所占内存大小）</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">Len() <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 实例化Cache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxBytes <span class="type">int64</span>, onEvicted <span class="keyword">func</span>(<span class="type">string</span>, Value)</span></span>) *Cache &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Cache&#123;</span><br><span class="line">maxBytes:  maxBytes,</span><br><span class="line">ll:        list.New(),</span><br><span class="line">cache:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*list.Element),</span><br><span class="line">OnEvicted: onEvicted,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 找到字典中对应的双向链表的节点。</span></span><br><span class="line"><span class="comment">2. 将该节点移动到队尾。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 查找功能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span></span> Get(key <span class="type">string</span>) (value Value, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// 如果对应的链表存在，将链表中的节点ele移动到队尾</span></span><br><span class="line"><span class="keyword">if</span> ele, ok := c.cache[key]; ok &#123;</span><br><span class="line">c.ll.MoveToFront(ele)<span class="comment">// 移动到队尾（队首队尾是相对的，这里约定front是队尾）</span></span><br><span class="line">kv := ele.Value.(*entry)</span><br><span class="line"><span class="keyword">return</span> kv.value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoveOldest 删除，缓存淘汰，队头元素就是最近最少访问的节点。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span></span> RemoveOldest() &#123;</span><br><span class="line">ele := c.ll.Back() <span class="comment">// 队头元素</span></span><br><span class="line"><span class="keyword">if</span> ele != <span class="literal">nil</span> &#123;</span><br><span class="line">c.ll.Remove(ele)                                       <span class="comment">// 链表删除队头元素</span></span><br><span class="line">kv := ele.Value.(*entry)                               <span class="comment">// 元素实体</span></span><br><span class="line"><span class="built_in">delete</span>(c.cache, kv.key)                                <span class="comment">// 删除map中的key,value</span></span><br><span class="line">c.nbytes -= <span class="type">int64</span>(<span class="built_in">len</span>(kv.key)) + <span class="type">int64</span>(kv.value.Len()) <span class="comment">// 已经使用字节大小</span></span><br><span class="line"><span class="keyword">if</span> c.OnEvicted != <span class="literal">nil</span> &#123;                                <span class="comment">// OnEvicted不为nil，调用回调函数</span></span><br><span class="line">c.OnEvicted(kv.key, kv.value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="添加更新"><a href="#添加更新" class="headerlink" title="添加更新"></a>添加更新</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add 向缓存中添加一个值。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span></span> Add(key <span class="type">string</span>, value Value) &#123;</span><br><span class="line"><span class="comment">// 查看是否在字典中</span></span><br><span class="line"><span class="keyword">if</span> ele, ok := c.cache[key]; ok &#123; <span class="comment">// 在字典中</span></span><br><span class="line">c.ll.MoveToFront(ele) <span class="comment">// 移动到队尾</span></span><br><span class="line">kv := ele.Value.(*entry)</span><br><span class="line">c.nbytes += <span class="type">int64</span>(value.Len()) - <span class="type">int64</span>(kv.value.Len())</span><br><span class="line">kv.value = value <span class="comment">// 更新value</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不在字典中</span></span><br><span class="line">ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;) <span class="comment">// 加到队尾</span></span><br><span class="line">c.cache[key] = ele                        <span class="comment">// 存入字典</span></span><br><span class="line">c.nbytes += <span class="type">int64</span>(<span class="built_in">len</span>(key)) + <span class="type">int64</span>(value.Len())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果超过了设定的最大值 c.maxBytes，则移除最少访问的节点。</span></span><br><span class="line"><span class="keyword">for</span> c.maxBytes != <span class="number">0</span> &amp;&amp; c.maxBytes &lt; c.nbytes &#123;</span><br><span class="line">c.RemoveOldest()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 缓存项的个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.ll.Len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>分析三种淘汰策略，最终选择LRU算法。</li><li>通过双向链表+哈希表实现LRU缓存淘汰策略。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-Go操作redis(GoWeb进阶)</title>
      <link href="/archives/a2a267ca.html"/>
      <url>/archives/a2a267ca.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><p>Redis是一个开源的内存数据库，Redis提供了多种不同类型的数据结构，很多业务场景下的问题都可以很自然地映射到这些数据结构上。除此之外，通过复制、持久化和客户端分片等特性，我们可以很方便地将Redis扩展成一个能够包含数百GB数据、每秒处理上百万次请求的系统。</p><h3 id="Redis支持的数据结构"><a href="#Redis支持的数据结构" class="headerlink" title="Redis支持的数据结构"></a>Redis支持的数据结构</h3><p>Redis支持诸如字符串（string）、哈希（hashe）、列表（list）、集合（set）、带范围查询的排序集合（sorted set）、bitmap、hyperloglog、带半径查询的地理空间索引（geospatial index）和流（stream）等数据结构。</p><h3 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h3><ul><li>缓存系统，减轻主数据库（MySQL）的压力。</li><li>计数场景，比如微博、抖音中的关注数和粉丝数。</li><li>热门排行榜，需要排序的场景特别适合使用ZSET。</li><li>利用 LIST 可以实现队列的功能。</li><li>利用 HyperLogLog 统计UV、PV等数据。</li><li>使用 geospatial index 进行地理位置相关查询。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe redis.windows.conf</span><br><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure><h2 id="go-redis"><a href="#go-redis" class="headerlink" title="go-redis"></a>go-redis</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/go-redis/redis&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个全局的rdb变量</span></span><br><span class="line"><span class="keyword">var</span> rdb *redis.Client</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initClient</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">      Addr:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">      Password: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      DB:       <span class="number">0</span>,   <span class="comment">// 使用默认DB</span></span><br><span class="line">      PoolSize: <span class="number">100</span>, <span class="comment">// 连接池大小</span></span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   _, err = rdb.Ping().Result()</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> err := initClient(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;init redis client failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;connect redis success~~~&quot;</span>)</span><br><span class="line">   <span class="keyword">defer</span> rdb.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哨兵模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rdb := redis.NewFailoverClient(&amp;redis.FailoverOptions&#123;</span><br><span class="line">    MasterName:    <span class="string">&quot;master-name&quot;</span>,</span><br><span class="line">    SentinelAddrs: []<span class="type">string</span>&#123;<span class="string">&quot;:9126&quot;</span>, <span class="string">&quot;:9127&quot;</span>, <span class="string">&quot;:9128&quot;</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>集群模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rdb := redis.NewClusterClient(&amp;redis.ClusterOptions&#123;</span><br><span class="line">    Addrs: []<span class="type">string</span>&#123;<span class="string">&quot;:7000&quot;</span>, <span class="string">&quot;:7001&quot;</span>, <span class="string">&quot;:7002&quot;</span>, <span class="string">&quot;:7003&quot;</span>, <span class="string">&quot;:7004&quot;</span>, <span class="string">&quot;:7005&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若要根据延迟或随机路由命令，请启用以下命令之一</span></span><br><span class="line">    <span class="comment">// RouteByLatency: true,</span></span><br><span class="line">    <span class="comment">// RouteRandomly: true,</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/go-redis/redis&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个全局的rdb变量</span></span><br><span class="line"><span class="keyword">var</span> rdb *redis.Client</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initClient</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">      Addr:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">      Password: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      DB:       <span class="number">0</span>,   <span class="comment">// 使用默认DB</span></span><br><span class="line">      PoolSize: <span class="number">100</span>, <span class="comment">// 连接池大小</span></span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   _, err = rdb.Ping().Result()</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set/get的例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">redisExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := rdb.Set(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>, <span class="number">0</span>).Err()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;set age failed, err%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   val, err := rdb.Get(<span class="string">&quot;age&quot;</span>).Result()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;get age failed, err%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;age&quot;</span>, val)</span><br><span class="line">   val2, err := rdb.Get(<span class="string">&quot;name&quot;</span>).Result()</span><br><span class="line">   <span class="keyword">if</span> err == redis.Nil &#123; <span class="comment">// go-redis 库提供了一个 redis.Nil 错误来表示 Key 不存在的错误。</span></span><br><span class="line">      fmt.Printf(<span class="string">&quot;name does not exist&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;get name failed, err%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;name&quot;</span>, val2)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> err := initClient(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;init redis client failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;connect redis success~~~&quot;</span>)</span><br><span class="line">   redisExample()</span><br><span class="line">   <span class="keyword">defer</span> rdb.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go-redis 库提供了一个 redis.Nil 错误来表示 Key 不存在的错误。因此在使用 go-redis 时需要注意对返回错误的判断。在某些场景下我们应该区别处理 redis.Nil 和其他不为 nil 的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;context&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个全局的rdb变量</span></span><br><span class="line"><span class="keyword">var</span> rdb *redis.Client</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initClient</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">      Addr:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">      Password: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      DB:       <span class="number">0</span>,   <span class="comment">// 使用默认DB</span></span><br><span class="line">      PoolSize: <span class="number">100</span>, <span class="comment">// 连接池大小</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zsetDemo 操作zset示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zsetDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// key</span></span><br><span class="line">   zsetKey := <span class="string">&quot;language_rank&quot;</span></span><br><span class="line">   <span class="comment">// value</span></span><br><span class="line">   languages := []*redis.Z&#123;</span><br><span class="line">      &#123;Score: <span class="number">90.0</span>, Member: <span class="string">&quot;Golang&quot;</span>&#125;,</span><br><span class="line">      &#123;Score: <span class="number">98.0</span>, Member: <span class="string">&quot;Java&quot;</span>&#125;,</span><br><span class="line">      &#123;Score: <span class="number">95.0</span>, Member: <span class="string">&quot;Python&quot;</span>&#125;,</span><br><span class="line">      &#123;Score: <span class="number">97.0</span>, Member: <span class="string">&quot;JavaScript&quot;</span>&#125;,</span><br><span class="line">      &#123;Score: <span class="number">99.0</span>, Member: <span class="string">&quot;C/C++&quot;</span>&#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   ctx, cancel := context.WithTimeout(context.Background(), <span class="number">500</span>*time.Millisecond)</span><br><span class="line">   <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ZADD</span></span><br><span class="line">   err := rdb.ZAdd(ctx, zsetKey, languages...).Err()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;zadd failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;zadd success&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 把Golang的分数加10</span></span><br><span class="line">   newScore, err := rdb.ZIncrBy(ctx, zsetKey, <span class="number">10.0</span>, <span class="string">&quot;Golang&quot;</span>).Result()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;zincrby failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;Golang&#x27;s score is %f now.\n&quot;</span>, newScore)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 取分数最高的3个</span></span><br><span class="line">   ret := rdb.ZRevRangeWithScores(ctx, zsetKey, <span class="number">0</span>, <span class="number">2</span>).Val()</span><br><span class="line">   <span class="keyword">for</span> _, z := <span class="keyword">range</span> ret &#123;</span><br><span class="line">      fmt.Println(z.Member, z.Score)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 取95~100分的</span></span><br><span class="line">   op := &amp;redis.ZRangeBy&#123;</span><br><span class="line">      Min: <span class="string">&quot;95&quot;</span>,</span><br><span class="line">      Max: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   ret, err = rdb.ZRangeByScoreWithScores(ctx, zsetKey, op).Result()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;zrangebyscore failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> _, z := <span class="keyword">range</span> ret &#123;</span><br><span class="line">      fmt.Println(z.Member, z.Score)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> err := initClient(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;init redis client failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;connect redis success~~~&quot;</span>)</span><br><span class="line"></span><br><span class="line">   zsetDemo()</span><br><span class="line">   <span class="keyword">defer</span> rdb.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-Go使用sqlx(GoWeb进阶)</title>
      <link href="/archives/93e63a62.html"/>
      <url>/archives/93e63a62.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go使用sqlx"><a href="#Go使用sqlx" class="headerlink" title="Go使用sqlx"></a>Go使用sqlx</h1><p>在项目中我们通常可能会使用<code>database/sql</code>连接MySQL数据库。<code>sqlx</code>可以认为是Go语言内置<code>database/sql</code>的超集，它在优秀的内置<code>database/sql</code>基础上提供了一组扩展。</p><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/jmoiron/sqlx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sqlx.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">   <span class="comment">// 也可以使用MustConnect连接不成功就panic</span></span><br><span class="line">   db, err = sqlx.Connect(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;connect DB failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   db.SetMaxOpenConns(<span class="number">20</span>)</span><br><span class="line">   db.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;connect DB success!!!&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   initDB()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增删改查操作"><a href="#增删改查操作" class="headerlink" title="增删改查操作"></a>增删改查操作</h2><p>sqlx是利用反射将数据库字段映射到结构体字段的。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/jmoiron/sqlx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">   ID   <span class="type">int</span>    <span class="string">`db:&quot;id&quot;`</span></span><br><span class="line">   Age  <span class="type">int</span>    <span class="string">`db:&quot;age&quot;`</span></span><br><span class="line">   Name <span class="type">string</span> <span class="string">`db:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sqlx.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">   <span class="comment">// 也可以使用MustConnect连接不成功就panic</span></span><br><span class="line">   db, err = sqlx.Connect(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;connect DB failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   db.SetMaxOpenConns(<span class="number">20</span>)</span><br><span class="line">   db.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询单条数据示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">   sqlStr := <span class="string">&quot;select id, name, age from user where id=?&quot;</span></span><br><span class="line">   <span class="keyword">var</span> u user</span><br><span class="line">   err := db.Get(&amp;u, sqlStr, <span class="number">1</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;get failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;id:%d name:%s age:%d\n&quot;</span>, u.ID, u.Name, u.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;init db success!!!\n&quot;</span>)</span><br><span class="line">   queryRowDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>sqlx中的exec方法与原生sql中的exec使用基本一致.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/jmoiron/sqlx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">ID   <span class="type">int</span>    <span class="string">`db:&quot;id&quot;`</span></span><br><span class="line">Age  <span class="type">int</span>    <span class="string">`db:&quot;age&quot;`</span></span><br><span class="line">Name <span class="type">string</span> <span class="string">`db:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sqlx.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line"><span class="comment">// 也可以使用MustConnect连接不成功就panic</span></span><br><span class="line">db, err = sqlx.Connect(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;connect DB failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">db.SetMaxOpenConns(<span class="number">20</span>)</span><br><span class="line">db.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">&quot;insert into user(name, age) values (?,?)&quot;</span></span><br><span class="line">ret, err := db.Exec(sqlStr, <span class="string">&quot;小亿&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;insert failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">theID, err := ret.LastInsertId() <span class="comment">// 新插入数据的id</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;get lastinsert ID failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;insert success, the id is %d.\n&quot;</span>, theID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;init db success!!!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">insertRowDemo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/jmoiron/sqlx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">   ID   <span class="type">int</span>    <span class="string">`db:&quot;id&quot;`</span></span><br><span class="line">   Age  <span class="type">int</span>    <span class="string">`db:&quot;age&quot;`</span></span><br><span class="line">   Name <span class="type">string</span> <span class="string">`db:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sqlx.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   dsn := <span class="string">&quot;root:520jpc...@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">   <span class="comment">// 也可以使用MustConnect连接不成功就panic</span></span><br><span class="line">   db, err = sqlx.Connect(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;connect DB failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   db.SetMaxOpenConns(<span class="number">20</span>)</span><br><span class="line">   db.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">   sqlStr := <span class="string">&quot;update user set age=? where id = ?&quot;</span></span><br><span class="line">   ret, err := db.Exec(sqlStr, <span class="number">21</span>, <span class="number">9</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;update failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;get RowsAffected failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;update success, affected rows:%d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;init db success!!!\n&quot;</span>)</span><br><span class="line">   </span><br><span class="line">   updateRowDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/jmoiron/sqlx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">   ID   <span class="type">int</span>    <span class="string">`db:&quot;id&quot;`</span></span><br><span class="line">   Age  <span class="type">int</span>    <span class="string">`db:&quot;age&quot;`</span></span><br><span class="line">   Name <span class="type">string</span> <span class="string">`db:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sqlx.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   dsn := <span class="string">&quot;root:520jpc...@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">   <span class="comment">// 也可以使用MustConnect连接不成功就panic</span></span><br><span class="line">   db, err = sqlx.Connect(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;connect DB failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   db.SetMaxOpenConns(<span class="number">20</span>)</span><br><span class="line">   db.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">   sqlStr := <span class="string">&quot;delete from user where id = ?&quot;</span></span><br><span class="line">   ret, err := db.Exec(sqlStr, <span class="number">9</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;delete failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;get RowsAffected failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;delete success, affected rows:%d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;init db success!!!\n&quot;</span>)</span><br><span class="line">   deleteRowDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sqlx-In批量插入"><a href="#sqlx-In批量插入" class="headerlink" title="sqlx.In批量插入"></a>sqlx.In批量插入</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;database/sql/driver&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/jmoiron/sqlx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">   ID   <span class="type">int</span>    <span class="string">`db:&quot;id&quot;`</span></span><br><span class="line">   Age  <span class="type">int</span>    <span class="string">`db:&quot;age&quot;`</span></span><br><span class="line">   Name <span class="type">string</span> <span class="string">`db:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *sqlx.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> Value() (driver.Value, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> []<span class="keyword">interface</span>&#123;&#125;&#123;u.Name, u.Age&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">   <span class="comment">// 也可以使用MustConnect连接不成功就panic</span></span><br><span class="line">   db, err = sqlx.Connect(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;connect DB failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   db.SetMaxOpenConns(<span class="number">20</span>)</span><br><span class="line">   db.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchInsertUsers2 使用sqlx.In帮我们拼接语句和参数, 注意传入的参数是[]interface&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BatchInsertUsers2</span><span class="params">(users []<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   query, args, _ := sqlx.In(</span><br><span class="line">      <span class="string">&quot;INSERT INTO user (name, age) VALUES (?), (?), (?)&quot;</span>,</span><br><span class="line">      users..., <span class="comment">// 如果arg实现了 driver.Valuer, sqlx.In 会通过调用 Value()来展开它</span></span><br><span class="line">   )</span><br><span class="line">   fmt.Println(query) <span class="comment">// 查看生成的querystring</span></span><br><span class="line">   fmt.Println(args)  <span class="comment">// 查看生成的args</span></span><br><span class="line">   _, err := db.Exec(query, args...)</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;init db success!!!\n&quot;</span>)</span><br><span class="line">   u1 := user&#123;Name: <span class="string">&quot;jpc1&quot;</span>, Age: <span class="number">10</span>&#125;</span><br><span class="line">   u2 := user&#123;Name: <span class="string">&quot;jpc2&quot;</span>, Age: <span class="number">12</span>&#125;</span><br><span class="line">   u3 := user&#123;Name: <span class="string">&quot;jpc3&quot;</span>, Age: <span class="number">13</span>&#125;</span><br><span class="line">   users := []<span class="keyword">interface</span>&#123;&#125;&#123;u1, u2, u3&#125;</span><br><span class="line">   BatchInsertUsers2(users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sqlx-In查询"><a href="#sqlx-In查询" class="headerlink" title="sqlx.In查询"></a>sqlx.In查询</h2><p>查询id在给定id集合中的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QueryByIDs 根据给定ID查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryByIDs</span><span class="params">(ids []<span class="type">int</span>)</span></span>(users []User, err <span class="type">error</span>)&#123;</span><br><span class="line"><span class="comment">// 动态填充id</span></span><br><span class="line">query, args, err := sqlx.In(<span class="string">&quot;SELECT name, age FROM user WHERE id IN (?)&quot;</span>, ids)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sqlx.In 返回带 `?` bindvar的查询语句, 我们使用Rebind()重新绑定它</span></span><br><span class="line">query = DB.Rebind(query)</span><br><span class="line"></span><br><span class="line">err = DB.Select(&amp;users, query, args...)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询id在给定id集合的数据并维持给定id集合的顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QueryAndOrderByIDs 按照指定id查询并维护顺序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QueryAndOrderByIDs</span><span class="params">(ids []<span class="type">int</span>)</span></span>(users []User, err <span class="type">error</span>)&#123;</span><br><span class="line"><span class="comment">// 动态填充id</span></span><br><span class="line">strIDs := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(ids))</span><br><span class="line"><span class="keyword">for</span> _, id := <span class="keyword">range</span> ids &#123;</span><br><span class="line">strIDs = <span class="built_in">append</span>(strIDs, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, id))</span><br><span class="line">&#125;</span><br><span class="line">query, args, err := sqlx.In(<span class="string">&quot;SELECT name, age FROM user WHERE id IN (?) ORDER BY FIND_IN_SET(id, ?)&quot;</span>, ids, strings.Join(strIDs, <span class="string">&quot;,&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sqlx.In 返回带 `?` bindvar的查询语句, 我们使用Rebind()重新绑定它</span></span><br><span class="line">query = DB.Rebind(query)</span><br><span class="line"></span><br><span class="line">err = DB.Select(&amp;users, query, args...)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> sqlx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Go操作MySQL(GoWeb进阶)</title>
      <link href="/archives/54970c1e.html"/>
      <url>/archives/54970c1e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go操作MySQL"><a href="#Go操作MySQL" class="headerlink" title="Go操作MySQL"></a>Go操作MySQL</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="初始化连接"><a href="#初始化连接" class="headerlink" title="初始化连接"></a>初始化连接</h3><p><code>sql.DB</code>是表示连接的数据库对象（结构体实例），它保存了连接数据库相关的所有信息。它内部维护着一个具有零到多个底层连接的连接池，它可以安全地被多个goroutine同时使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象db</span></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个初始化数据库的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// DSN:Data Source Name</span></span><br><span class="line">dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line"><span class="comment">// 不会校验账号密码是否正确</span></span><br><span class="line"><span class="comment">// 给全局变量赋值，然后在main函数中使用全局变量db</span></span><br><span class="line">db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn) <span class="comment">// 使用MySQL驱动</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试与数据库建立连接（校验dsn是否正确）</span></span><br><span class="line">err = db.Ping()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;init db success!!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>SetMaxOpenConns</code>设置与数据库建立连接的最大数目。 <code>SetMaxIdleConns</code>设置连接池中的最大闲置连接数。</p><h2 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h2><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p><strong>单行查询</strong></p><p>单行查询<code>db.QueryRow()</code>执行一次查询，并期望返回最多一行结果（即Row）。QueryRow总是返回非nil的值，直到返回值的Scan方法被调用时，才会返回被延迟的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">id   <span class="type">int</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象db</span></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个初始化数据库的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// DSN:Data Source Name</span></span><br><span class="line">dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line"><span class="comment">// 不会校验账号密码是否正确</span></span><br><span class="line"><span class="comment">// 注意！！！这里不要使用:=，我们是给全局变量赋值，然后在main函数中使用全局变量db</span></span><br><span class="line">db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn) <span class="comment">// 使用MySQL驱动</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试与数据库建立连接（校验dsn是否正确）</span></span><br><span class="line">err = db.Ping()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.SetConnMaxLifetime(time.Second * <span class="number">10</span>)</span><br><span class="line">db.SetMaxOpenConns(<span class="number">200</span>) <span class="comment">// 最大链接数</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">10</span>)  <span class="comment">// 最大空闲链接数</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询单条数据示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">&quot;select id, name, age from user where id=?&quot;</span></span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line"><span class="comment">// 非常重要：确保QueryRow之后调用Scan方法，否则持有的数据库链接不会被释放</span></span><br><span class="line">err := db.QueryRow(sqlStr, <span class="number">1</span>).Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;scan failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;id:%d name:%s age:%d\n&quot;</span>, u.id, u.name, u.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;init db success!!!\n&quot;</span>)</span><br><span class="line">queryRowDemo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>多行查询</strong></p><p>多行查询<code>db.Query()</code>执行一次查询，返回多行结果（即Rows），一般用于执行select命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">id   <span class="type">int</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象db</span></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个初始化数据库的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// DSN:Data Source Name</span></span><br><span class="line">dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line"><span class="comment">// 不会校验账号密码是否正确</span></span><br><span class="line"><span class="comment">// 注意！！！这里不要使用:=，我们是给全局变量赋值，然后在main函数中使用全局变量db</span></span><br><span class="line">db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn) <span class="comment">// 使用MySQL驱动</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试与数据库建立连接（校验dsn是否正确）</span></span><br><span class="line">err = db.Ping()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.SetConnMaxLifetime(time.Second * <span class="number">10</span>)</span><br><span class="line">db.SetMaxOpenConns(<span class="number">200</span>) <span class="comment">// 最大链接数</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">10</span>)  <span class="comment">// 最大空闲链接数</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询多条数据示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">queryMultiRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">sqlStr := <span class="string">&quot;select id, name, age from user where id &gt; ?&quot;</span></span><br><span class="line">rows, err := db.Query(sqlStr, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;query failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭rows释放持有的数据库连接</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取结果集中的数据</span></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> u user</span><br><span class="line">err := rows.Scan(&amp;u.id, &amp;u.name, &amp;u.age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;scan failed err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;id:%d name:%s age:%d\n&quot;</span>, u.id, u.name, u.age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;init db success!!!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">queryMultiRowDemo()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>插入、更新和删除操作都使用<code>Exec</code>方法。</p><p>Exec执行一次命令（包括查询、删除、更新、插入等），返回的Result是对已执行的SQL命令的总结。参数args表示query中的占位参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">   id   <span class="type">int</span></span><br><span class="line">   age  <span class="type">int</span></span><br><span class="line">   name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象db</span></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个初始化数据库的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">// DSN:Data Source Name</span></span><br><span class="line">   dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">   <span class="comment">// 不会校验账号密码是否正确</span></span><br><span class="line">   <span class="comment">// 注意！！！这里不要使用:=，我们是给全局变量赋值，然后在main函数中使用全局变量db</span></span><br><span class="line">   db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn) <span class="comment">// 使用MySQL驱动</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 尝试与数据库建立连接（校验dsn是否正确）</span></span><br><span class="line">   err = db.Ping()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   db.SetConnMaxLifetime(time.Second * <span class="number">10</span>)</span><br><span class="line">   db.SetMaxOpenConns(<span class="number">200</span>) <span class="comment">// 最大链接数</span></span><br><span class="line">   db.SetMaxIdleConns(<span class="number">10</span>)  <span class="comment">// 最大空闲链接数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">   sqlStr := <span class="string">&quot;insert into user(name, age) values(?, ?)&quot;</span></span><br><span class="line">   ret, err := db.Exec(sqlStr, <span class="string">&quot;小贾&quot;</span>, <span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;insert failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   theID, err := ret.LastInsertId() <span class="comment">// 新插入的数据id</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;get lastinsert ID failed, err%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;insert success, the id is %d.\n&quot;</span>, theID)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;init db success!!!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">   insertRowDemo()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">   id   <span class="type">int</span></span><br><span class="line">   age  <span class="type">int</span></span><br><span class="line">   name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象db</span></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个初始化数据库的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">// DSN:Data Source Name</span></span><br><span class="line">   dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">   <span class="comment">// 不会校验账号密码是否正确</span></span><br><span class="line">   <span class="comment">// 注意！！！这里不要使用:=，我们是给全局变量赋值，然后在main函数中使用全局变量db</span></span><br><span class="line">   db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn) <span class="comment">// 使用MySQL驱动</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 尝试与数据库建立连接（校验dsn是否正确）</span></span><br><span class="line">   err = db.Ping()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   db.SetConnMaxLifetime(time.Second * <span class="number">10</span>)</span><br><span class="line">   db.SetMaxOpenConns(<span class="number">200</span>) <span class="comment">// 最大链接数</span></span><br><span class="line">   db.SetMaxIdleConns(<span class="number">10</span>)  <span class="comment">// 最大空闲链接数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">   sqlStr := <span class="string">&quot;update user set age=? where id = ?&quot;</span></span><br><span class="line">   ret, err := db.Exec(sqlStr, <span class="number">21</span>, <span class="number">6</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;update failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;get RowsAffected failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;update success, affected rows:%d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;init db success!!!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">   updateRowDemo()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">   id   <span class="type">int</span></span><br><span class="line">   age  <span class="type">int</span></span><br><span class="line">   name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象db</span></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个初始化数据库的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">// DSN:Data Source Name</span></span><br><span class="line">   dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">   <span class="comment">// 不会校验账号密码是否正确</span></span><br><span class="line">   <span class="comment">// 注意！！！这里不要使用:=，我们是给全局变量赋值，然后在main函数中使用全局变量db</span></span><br><span class="line">   db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn) <span class="comment">// 使用MySQL驱动</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 尝试与数据库建立连接（校验dsn是否正确）</span></span><br><span class="line">   err = db.Ping()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   db.SetConnMaxLifetime(time.Second * <span class="number">10</span>)</span><br><span class="line">   db.SetMaxOpenConns(<span class="number">200</span>) <span class="comment">// 最大链接数</span></span><br><span class="line">   db.SetMaxIdleConns(<span class="number">10</span>)  <span class="comment">// 最大空闲链接数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteRowDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">   sqlStr := <span class="string">&quot;delete from user where id = ?&quot;</span></span><br><span class="line">   ret, err := db.Exec(sqlStr, <span class="number">6</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;delete failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   n, err := ret.RowsAffected() <span class="comment">// 操作影响的行数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;get RowsAffected failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;delete success, affected rows:%d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;init db success!!!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">   deleteRowDemo()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MySQL预处理"><a href="#MySQL预处理" class="headerlink" title="MySQL预处理"></a>MySQL预处理</h2><h3 id="预处理过程"><a href="#预处理过程" class="headerlink" title="预处理过程"></a>预处理过程</h3><p>普通SQL语句执行过程：</p><ol><li>客户端对SQL语句进行占位符替换得到完整的SQL语句。</li><li>客户端发送完整SQL语句到MySQL服务端</li><li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li></ol><p>预处理执行过程：</p><ol><li>把SQL语句分成两部分，命令部分与数据部分。</li><li>先把命令部分发送给MySQL服务端，MySQL服务端进行SQL预处理。</li><li>然后把数据部分发送给MySQL服务端，MySQL服务端对SQL语句进行占位符替换。</li><li>MySQL服务端执行完整的SQL语句并将结果返回给客户端。</li></ol><h3 id="预处理的优点"><a href="#预处理的优点" class="headerlink" title="预处理的优点"></a>预处理的优点</h3><ol><li>优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，<strong>提前让服务器编译</strong>，<strong>一次编译多次执行，节省后续编译的成本</strong>。</li><li>避免SQL注入问题。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">   id   <span class="type">int</span></span><br><span class="line">   age  <span class="type">int</span></span><br><span class="line">   name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象db</span></span><br><span class="line"><span class="keyword">var</span> db *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个初始化数据库的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initDB</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">// DSN:Data Source Name</span></span><br><span class="line">   dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&quot;</span></span><br><span class="line">   <span class="comment">// 不会校验账号密码是否正确</span></span><br><span class="line">   <span class="comment">// 注意！！！这里不要使用:=，我们是给全局变量赋值，然后在main函数中使用全局变量db</span></span><br><span class="line">   db, err = sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn) <span class="comment">// 使用MySQL驱动</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 尝试与数据库建立连接（校验dsn是否正确）</span></span><br><span class="line">   err = db.Ping()</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   db.SetConnMaxLifetime(time.Second * <span class="number">10</span>)</span><br><span class="line">   db.SetMaxOpenConns(<span class="number">200</span>) <span class="comment">// 最大链接数</span></span><br><span class="line">   db.SetMaxIdleConns(<span class="number">10</span>)  <span class="comment">// 最大空闲链接数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理插入示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareInsertDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">   sqlStr := <span class="string">&quot;insert into user(name, age) values (?,?)&quot;</span></span><br><span class="line">   stmt, err := db.Prepare(sqlStr) <span class="comment">//Prepare方法会先将sql语句发送给MySQL服务端，返回一个准备好的状态用于之后的查询和命令</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;prepare failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> stmt.Close()</span><br><span class="line">   _, err = stmt.Exec(<span class="string">&quot;小贾&quot;</span>, <span class="number">18</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;insert failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   _, err = stmt.Exec(<span class="string">&quot;小刘&quot;</span>, <span class="number">18</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;insert failed, err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;insert success.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   err := initDB() <span class="comment">// 调用输出化数据库的函数</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;init db failed,err:%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;init db success!!!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">   prepareInsertDemo()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><p>事务：一个最小的不可再分的工作单元。</p><p>在MySQL中只有使用了<code>Innodb</code>数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。</p><h3 id="事务的四个特性（ACID）"><a href="#事务的四个特性（ACID）" class="headerlink" title="事务的四个特性（ACID）"></a>事务的四个特性（ACID）</h3><ul><li>A：原子性（Atomicity，或称不可分割性）</li><li>C：一致性（Consistency）</li><li>I：隔离性（Isolation，又称独立性）</li><li>D：持久性（Durability）</li></ul><div class="table-container"><table><thead><tr><th>条件</th><th>解释</th></tr></thead><tbody><tr><td>原子性</td><td>一个事务中的所有操作，<strong>要么全部完成，要么全部不完成</strong>，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</td></tr><tr><td>一致性</td><td>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</td></tr><tr><td>隔离性</td><td>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</td></tr><tr><td>持久性</td><td>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</td></tr></tbody></table></div><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>开始事务：<code>func (db *DB) Begin() (*Tx, error)</code></li><li>提交事务：<code>func (tx *Tx) Commit() error</code></li><li>回滚事务：<code>func (tx *Tx) Rollback() error</code></li></ul><p>更新数据库要么都成功要么都失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务操作示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transactionDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">tx, err := db.Begin() <span class="comment">// 开启事务</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> tx != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;begin trans failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">sqlStr1 := <span class="string">&quot;Update user set age=30 where id=?&quot;</span></span><br><span class="line">    </span><br><span class="line">ret1, err := tx.Exec(sqlStr1, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;exec sql1 failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 返回受影响的行数</span></span><br><span class="line">affRow1, err := ret1.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;exec ret1.RowsAffected() failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqlStr2 := <span class="string">&quot;Update user set age=40 where id=?&quot;</span></span><br><span class="line">ret2, err := tx.Exec(sqlStr2, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;exec sql2 failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">affRow2, err := ret2.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Rollback() <span class="comment">// 回滚</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;exec ret1.RowsAffected() failed, err:%v\n&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(affRow1, affRow2)</span><br><span class="line"><span class="keyword">if</span> affRow1 == <span class="number">1</span> &amp;&amp; affRow2 == <span class="number">1</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;事务提交啦...&quot;</span>)</span><br><span class="line">tx.Commit() <span class="comment">// 提交事务</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tx.Rollback()</span><br><span class="line">fmt.Println(<span class="string">&quot;事务回滚啦...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;exec trans success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-Golang幼麟实验室笔记(方法)</title>
      <link href="/archives/853c0961.html"/>
      <url>/archives/853c0961.html</url>
      
        <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>变量a称为<strong>方法接收者</strong>，会作为方法Name()的第一个参数传入。</p><p><strong>Go语言中函数类型只和参数与返回值相关。</strong></p><p><strong>方法本质上就是普通的函数</strong>，接收者是隐含的第一个参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">  a.name = <span class="string">&quot;Hi &quot;</span> + a.name</span><br><span class="line">  <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := A&#123;name: <span class="string">&quot;itxiaoma&quot;</span>&#125;</span><br><span class="line">  fmt.Println(a.Name())  <span class="comment">//Hi itxiaoma</span></span><br><span class="line">  fmt.Println(A.Name(a)) <span class="comment">//Hi itxiaoma</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">  a.name = <span class="string">&quot;Hi &quot;</span> + a.name</span><br><span class="line">  <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NameOfA</span><span class="params">(a A)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  a.name = <span class="string">&quot;Hi &quot;</span> + a.name</span><br><span class="line">  <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  t1 := reflect.TypeOf(A.Name)    </span><br><span class="line">  t2 := reflect.TypeOf(NameOfA)    </span><br><span class="line">  fmt.Println(t1)    <span class="comment">//func(main.A) string</span></span><br><span class="line">  fmt.Println(t2)    <span class="comment">//func(main.A) string</span></span><br><span class="line">  fmt.Println(t1 == t2)    <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><h3 id="值接收者"><a href="#值接收者" class="headerlink" title="值接收者"></a>值接收者</h3><ul><li>main函数栈帧：局部变量a只包含一个string类型成员，字符串内容在数据段，地址addr1，字节数目4；</li><li>传参值拷贝：局部变量a拷贝到参数空间，指向新的内容addr2，字节数目改为8</li><li>局部变量a是值接收者，通过它调用方法时修改的是拷贝过去的参数，而不是局部变量a</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221226212840188.png" alt="image-20221226212840188"></p><h3 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h3><ul><li>main函数栈帧：包含局部变量a，还有a的指针pa</li><li>pa.Name()会被转为<code>(*A).Name(pa)</code>这样的函数调用</li><li>传参值拷贝：参数为A的指针，传参值拷贝时拷贝的是变量a的地址；修改时变量a指向新的地址addr2，字节数目改为8；</li><li>拷贝返回值时，拷贝的是局部变量a的成员</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221226214236989.png" alt="image-20221226214236989"></p><h3 id="转换语法糖"><a href="#转换语法糖" class="headerlink" title="转换语法糖"></a>转换语法糖</h3><p>语法糖是在编译期间发挥作用的，编译期间无法拿到地址的字面量就不能借助语法糖转换了，无法通过编译。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221226214257204.png" alt="image-20221226214257204"></p><h2 id="方法赋给变量"><a href="#方法赋给变量" class="headerlink" title="方法赋给变量"></a>方法赋给变量</h2><p>Go语言中函数作为变量，参数和返回值时，都是以Function Value的形式存在的。</p><p>闭包只是有捕获列表的Function Value。</p><h3 id="方法表达式"><a href="#方法表达式" class="headerlink" title="方法表达式"></a>方法表达式</h3><ul><li>把一个类型的方法赋给一个变量，该变量称为方法表达式(f1)</li><li>f1本质上也是一个Function Value，也就是一个funcval结构体的指针，fn指向A.GetName的函数指令入口</li><li>通过f1执行方法时，需要传入A类型的变量a作为参数</li></ul><h3 id="方法变量"><a href="#方法变量" class="headerlink" title="方法变量"></a>方法变量</h3><ul><li>方法变量也是一个Function Value，而且会捕获方法接收者形成闭包</li><li>这里f2仅作为局部变量，与a的声明周期是一致的，编译器会优化为<code>A.GetName(a)</code>进行调用</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221226214333782.png" alt="image-20221226214333782"></p><p>方法变量作为返回值：</p><p>f3就是一个闭包对象，捕获了GetFunc函数的局部变量a</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221226214359371.png" alt="image-20221226214359371"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>幼麟实验室bilibili：<a href="https://www.bilibili.com/video/BV1hv411x7we/?spm_id_from=333.999.0.0&amp;vd_source=44bd80a738e14b1c370a0a540eb6975f">https://space.bilibili.com/567195437/?spm_id_from=333.999.0.0</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-Golang幼麟实验室笔记(闭包)</title>
      <link href="/archives/6e3aeda2.html"/>
      <url>/archives/6e3aeda2.html</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="Function-Value"><a href="#Function-Value" class="headerlink" title="Function Value"></a>Function Value</h2><p>go中函数是头等对象，可以作为参数传递，可以作为返回值，也可以绑定到变量。go中称这样的参数，返回值或者变量为Function Value。</p><p>Function Value本质上是一个指针，却不直接指向函数指令入口，而是指向runtime.funcval结构体，这个结构体里只有一个地址，就是这个函数指令的<strong>入口地址</strong>。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221220230702063.png" alt="image-20221220230702063"></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221220230844375.png" alt="image-20221220230844375"></p><p>函数A被赋值给f1和f2两个变量，这种情况，编译器会做出优化，让f1和f2共用一个funcval结构体。</p><p>如果函数A的指令在这，入口地址addr1，编译阶段，会在只读数据段分配一个funcval结构体，fn指向函数A指令入口，而它本身的起始地址，会在执行阶段赋给f1和f2。通过f1来执行函数，就会通过它存储的地址找到对应的funcval结构体，拿到函数入口地址，然后调转执行。</p><p>既然只要有函数入口地址就能调用 ，为什么要通过funcval结构体包装这个地址，然后使用一个二级指针来调用呢？这里主要是为了处理闭包的情况。</p><h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h2><ul><li>第一：必须要有在<strong>函数外部定义</strong>，但在函数<strong>内部</strong>引用的<strong>自由变量</strong>。</li><li>第二：脱离了形成闭包的上下文，闭包也能照常使用这些自由变量。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c := <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f1 := create()</span><br><span class="line">    f2 := create()</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create函数的返回值是一个函数，并且引用了其外层函数定义的局部变量c；而且，即便create函数结束，依然可以通过f1和f2正常执行这个函数并使用定义在create内部的变量c。所以这个返回值符合闭包的定义，而这个自由变量c，通常被称为“<strong><em>\</em>捕获变量**</strong>”。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221220231610359.png" alt="image-20221220231610359"></p><p><strong>在Go语言中闭包只是拥有一个或多个捕获变量的Function Value而已</strong>。</p><p>每个闭包对象都是一个Function Value，但是各自持有自己的捕获列表，这也是称闭包为<strong>有状态的函数</strong>的原因。</p><h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><p>被闭包捕获的变量，要在外层函数与闭包函数中表现一致，好像它们在使用同一个变量，为此，go语言的编译器针对不同情况做了不同的处理。</p><h3 id="被捕获的变量没有被修改的情况"><a href="#被捕获的变量没有被修改的情况" class="headerlink" title="被捕获的变量没有被修改的情况"></a>被捕获的变量没有被修改的情况</h3><p>最简单的情况就像上面那个例子，被捕获的变量除了初始化赋值外，在任何地方都没有被修改过，所以直接拷贝值到捕获列表就ok了</p><h3 id="被捕获的变量被修改的情况"><a href="#被捕获的变量被修改的情况" class="headerlink" title="被捕获的变量被修改的情况"></a>被捕获的变量被修改的情况</h3><p>举个栗子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> (fs [<span class="number">2</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        fs[i] = <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fs := create()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(fs); i++ &#123;</span><br><span class="line">        fs[i]()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，被捕获的是局部变量i，而且除了初始化赋值(i:=0)外还被修改(i++)过.</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221220232033063.png" alt="image-20221220232033063"></p><p>闭包函数指令入口addrf，main函数栈帧中，局部变量fs是一个长度为2的function value类型数组，返回值为零值，到create函数栈帧，由于被闭包捕获并修改，<strong>局部变量i改为堆分配，在栈上只存一个地址</strong>。</p><p>第一次for循环。在堆上创建funcval结构体，捕获i的地址，这样闭包函数就和外层函数操作同一个变量了，返回值第一个元素存储addr0，第一次for循环结束，i自增1</p><p>第二次for循环开始，再次堆分配一个funcval，捕获变量i的地址，第二个元素存储addr1，第二次循环结束，i再次自增1，create函数结束，把返回值拷贝到局部变量fs。</p><p>通过fs[0]调用函数时，把addr0存入寄存器。闭包函数通过寄存器存储的地址加上偏移找到捕获变量i的地址。fs[1]同理，被捕获的地址都指向它，所以每次都会打印2。</p><p><strong>闭包导致的局部变量堆分配，也是变量逃逸的一种场景。</strong></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221220232513995.png" alt="image-20221220232513995"></p><h3 id="有修改并被捕获的是参数"><a href="#有修改并被捕获的是参数" class="headerlink" title="有修改并被捕获的是参数"></a>有修改并被捕获的是参数</h3><p>如果有修改并被捕获的是参数，涉及到函数原型，就不能像局部变量那样处理了。</p><p>参数依然通过调用者栈帧传入，但是编译器会把栈上这个参数拷贝到堆上一份。然后外层函数和闭包函数都使用堆上分配的这一个。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221220232609842.png" alt="image-20221220232609842"></p><h3 id="被捕获的是返回值"><a href="#被捕获的是返回值" class="headerlink" title="被捕获的是返回值"></a>被捕获的是返回值</h3><p>如果被捕获的是返回值，处理方式又有些不同</p><p>调用者栈帧上依然会分配返回值的空间，不过闭包的外层函数会在堆上也分配一个，外层函数和闭包函数都使用堆上这个，但是在外层函数返回前，需要把堆上的返回值拷贝到栈上的返回值空间</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221220232752505.png" alt="image-20221220232752505"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>处理方式虽然多样，但是目标只有一个，就是保存捕获变量在外层函数和闭包函数中的一致性.</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>幼麟实验室bilibili：<a href="https://www.bilibili.com/video/BV1hv411x7we/?spm_id_from=333.999.0.0&amp;vd_source=44bd80a738e14b1c370a0a540eb6975f">https://space.bilibili.com/567195437/?spm_id_from=333.999.0.0</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-Golang幼麟实验室笔记(函数调用栈)</title>
      <link href="/archives/fb9b7de7.html"/>
      <url>/archives/fb9b7de7.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h1><p>我们在编程中写的函数，会被编译器编译为机器指令，写入可执行文件，程序执行的时候，会把这个可执行文件加载到内存，在虚拟地址空间中的<code>代码段</code>存放。</p><p>如果在一个函数中调用另一个函数，编译器就会对应生成一条<code>call</code>指令，当程序执行到这条call指令时，就会跳到对应的函数入口处开始执行，而每一个函数的最后，都有一条<code>ret</code>指令，负责在函数结束后跳回到调用处继续执行。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219212335264.png" alt="image-20221219212335264"></p><h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p>函数执行的时候需要有足够的内存空间来存放局部变量，参数，返回值等数据，这些数据存在上图中的栈中。</p><p>栈先入后出，先入栈的在底部。</p><p>虚拟地址空间的栈区，上面是高地址，下面是低地址，栈底通常称为栈基，栈顶又叫栈指针。</p><p>具体的栈帧布局是：</p><ul><li>调用者栈基地址（也就是谁调用了这个函数）</li><li>局部变量</li><li>调用函数的返回值</li><li>参数</li></ul><p><strong>通过栈指针加上偏移来定位到每个参数和返回值。</strong></p><p>比如栈指针+8字节处，就是栈指针的上一格，通过这种方式来进行偏移。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219212525789.png" alt="image-20221219212525789"></p><p>当在A函数中调用B函数时，会在A函数中插入一条<code>call</code>指令，当执行到<code>call</code>指令的时候，会去B函数开始处运行。那么<code>call</code>指令做的事情就是：</p><ol><li>首先把A函数中下一条指令的地址入栈（栈基地址，当B函数执行完之后，可以再通过这个地址回到A函数的调用处继续执行A函数。）</li><li>跳转到被调用函数的入口处执行（也就是被调用函数的栈帧，而所有的函数栈帧布局都遵循统一的结构约定。）</li></ol><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219213123110.png" alt="image-20221219213123110"></p><h2 id="入栈策略"><a href="#入栈策略" class="headerlink" title="入栈策略"></a>入栈策略</h2><p>程序执行时，CPU通过特定的寄存器来存运行时的栈基和栈指针，也有指令指针寄存器用来存储下一条要执行的指令地址。</p><p>执行指令的过程有两种，第一种是逐步扩张：</p><h3 id="逐步扩张"><a href="#逐步扩张" class="headerlink" title="逐步扩张"></a>逐步扩张</h3><ul><li>如果要执行入栈3这条指令，CPU读取之后，会先把指令指针移向下一条指令，然后栈指针向下移动，入栈数字3。</li><li>然后再执行入栈4这条指令，CPU读取之后，再把指令指针移向下一条指令，然后栈指针向下移动，入栈数字4。</li><li>一直往复。</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219213138921.png" alt="image-20221219213138921"></p><h3 id="一次性分配"><a href="#一次性分配" class="headerlink" title="一次性分配"></a>一次性分配</h3><p>Go语言中的是第二种——<code>一次性分配</code>，它会直接将栈指针移动到所需最大栈空间的位置，然后通过右边这种相对寻址的方式，来把对应的值入栈。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219213201227.png" alt="image-20221219213201227"></p><p>Go语言选择使用一次性分配的策略是有原因的，拿下图来讲，下面三个goroutine，初始分配的栈空间只有那么大，如果要逐步扩张的话，如果g2执行到最后了，但是接下来要执行的函数又要用掉很多的空间，如果函数栈是逐步扩张的，执行时就可能会发生栈访问越界。</p><p>函数栈帧的大小可以在编译时期确定， 对于栈消耗大的函数，Go编译器会在函数头部插入检测代码，如果发现需要进行栈增长，则会另外分配一段足够大的空间，然后把原来的内容移过来，并释放原来的空间。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219213226288.png" alt="image-20221219213226288"></p><h2 id="call和ret"><a href="#call和ret" class="headerlink" title="call和ret"></a>call和ret</h2><p>首先我们可以看到，下面是<code>栈区</code>和<code>代码段</code>。</p><p>当代码段执行到对应的指令时，就会给栈中添加对应的元素，最终再把栈全部出栈。</p><p>假如说，我们是在函数A中的a1处调用函数B（函数B开始位置为b1）。</p><p>首先，在最开始的时候，寄存器在栈中的情况是这样的：</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219213244278.png" alt="image-20221219213244278"></p><p>ip寄存器中存的是下一条要运行的指令，那么当我们的代码段运行到<code>a1</code>的call指令时，会做两件事：</p><p>首先会入栈返回地址a2，然后栈指针sp向下一格，然后给ip寄存器b1的指令地址，接下来要去B函数的开始处运行。call指令就结束了。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219213303593.png" alt=""></p><p>接下来就要运行四步函数都要做的事：</p><ul><li>第一步是先把栈指针sp移动到足够大的位置——<code>s7</code>上。</li><li>第二步是存储一下之前栈基<code>bp</code>寄存器的值，这样可以在运行完之后，还能回到原来的栈基地址。</li><li>第三步是把<code>s5</code>存入栈基地址。</li><li>接下来就要做函数剩下的指令了——参数，代码等，并一一入栈。</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219213320906.png" alt=""></p><p>在函数B运行到最后——ret指令之前，编译器还会插入两条指令：</p><ul><li>恢复调用者栈基。最开始我们分配了多少空间，此时就释放多少空间，修改bp寄存器为之前入栈的s1，bp继续指向s1处。</li><li>然后就到ret指令了，它首先会弹出call指令压栈的返回地址a2，sp赋值为s3。然后跳转到这个返回地址a2，把ip寄存器赋值为a2。 接下来可以从a2这里继续执行了。</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219213340705.png" alt=""></p><p>简单来说，call指令会分配栈帧，ret指令又会释放栈帧，恢复到call之前的样子。通过这些指令的配合，就能实现函数的层层嵌套了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>幼麟实验室bilibili：<a href="https://www.bilibili.com/video/BV1hv411x7we/?spm_id_from=333.999.0.0&amp;vd_source=44bd80a738e14b1c370a0a540eb6975f">https://space.bilibili.com/567195437/?spm_id_from=333.999.0.0</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Golang幼麟实验室笔记(切片、字符串、结构体、map)</title>
      <link href="/archives/7c9d44f8.html"/>
      <url>/archives/7c9d44f8.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习前的介绍"><a href="#学习前的介绍" class="headerlink" title="学习前的介绍"></a>学习前的介绍</h1><p>通过幼<a href="https://www.bilibili.com/video/BV1hv411x7we/?spm_id_from=333.999.0.0&amp;vd_source=44bd80a738e14b1c370a0a540eb6975f">麟实验室</a>的学习让我更加深刻的去理解Golang的底层原理，看完最深刻的感受就是脑子好痒，非常干，全是干货。自己做的笔记整理出来，方便复习和阅读。</p><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="Unicode字符编码"><a href="#Unicode字符编码" class="headerlink" title="Unicode字符编码"></a>Unicode字符编码</h2><p>变长编码</p><div class="table-container"><table><thead><tr><th>编号</th><th>编码模板</th><th>最高位固定标识位</th></tr></thead><tbody><tr><td>[0, 127]</td><td>0???????</td><td>0</td></tr><tr><td>[128, 2047]</td><td>110????? 10??????</td><td>110 和 10</td></tr><tr><td>[2048,  65535]</td><td>1110???? 10?????? 10??????</td><td>1110 和 10 和 10</td></tr></tbody></table></div><p>例如</p><p><strong>界</strong> 编号：30028——-&gt;二进制（01110101 01001100）</p><p>将其填如对应的？位置——&gt;得到<strong>界</strong>UTF-8编码：1110<strong>0111</strong>  10<strong>010101</strong>  10<strong>001100</strong></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221217171220957.png" alt="image-20221217171220957"></p><h2 id="string的数据结构"><a href="#string的数据结构" class="headerlink" title="string的数据结构"></a>string的数据结构</h2><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221217171701076.png" alt="image-20221217171701076"></p><ul><li>golang不用特定标识符表示字符串的结尾。</li><li>golang采用string结构体来共同描述一个字符串。</li><li>data是指向字符串开始位置的指针。</li><li>len表示字符串的字节个数（非字符个数），因为golang采用utf8的变长编码方式，故不能采用字符个数。</li></ul><h2 id="string的底层细节"><a href="#string的底层细节" class="headerlink" title="string的底层细节"></a>string的底层细节</h2><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221217223823504.png" alt="image-20221217223823504"></p><ul><li>golang将string类型分配到只读内存段，因此不能通过下标的方式修改。</li><li>s2的起始地址是第3个字节，字节数目是8（起始地址到s1结尾字节数目）</li><li>多个string变量可以共用同一个字符串的某个部分。（如上图s2：如果s1修改eggo为egoo，那么s2也会受影响）</li><li>可以给变量整体附新值<code>s1=&quot;Hello&quot;</code>,那么s1就会指向新的地址。</li><li>可转为字节切片对字符串内容进行修改，不过改动的是拷贝后的字符串（上图bs切片）</li></ul><h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><h2 id="slice结构"><a href="#slice结构" class="headerlink" title="slice结构"></a>slice结构</h2><p>slice分三部分：【存哪里】【存了多少元素】【可以存多少元素】(data, len, cap)</p><ul><li><p><code>var a []int</code>：变量a —&gt; (data=nil, 0, 0)</p></li><li><p><code>var a = make([]int, 3, 5)</code> 变量—&gt;（data=起始地址, 3, 5）</p></li><li><p>new一个slice</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221217231319635.png" alt="image-20221217231319635"></p></li></ul><h2 id="slice扩容机制"><a href="#slice扩容机制" class="headerlink" title="slice扩容机制"></a>slice扩容机制</h2><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221217231911340.png" alt="image-20221217231911340"></p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li></ul><p><strong>扩容之后的数组一定是新的么</strong></p><ol><li>情况一：切片的cap还够用，则扩容后还是原来的底层数组。</li><li>情况二：切片的cap不够用，则扩容后会开辟新的数组，将原来的值拷贝后再扩容，此时的底层数组是新开辟的而不是原来的。</li></ol><p><strong>如上图中扩容后cap=5后发生什么（假如机器是64位）</strong></p><ol><li><strong>内存管理模块</strong>会提前向操作系统申请一批不同规格的内存地址如(8, 16, 32, 48, 64, 80, 96…)</li><li>预估申请的内存会匹配到合适规格的内存，5 * 8 = 40byte, 那么就会匹配到规格为48字节的内存。</li></ol><h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><h2 id="地址总线和数据总线"><a href="#地址总线和数据总线" class="headerlink" title="地址总线和数据总线"></a>地址总线和数据总线</h2><ul><li>CPU是通过地址总线来对存储单元进行寻址的，8根地址总线[0,255]可寻址256Byte内存，32根地址总线[0,2^32-1]可寻址4G内存。</li><li>CPU与内存或者其他器件之间的数据传输时通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传输速度。8根数据总线一次即可传送8位二进制数据（1个字节）；16位即可一次传送两个字节。每次操作的字节数称为机器字长。</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219201837315.png" alt="image-20221219201837315"></p><h2 id="内存对齐-1"><a href="#内存对齐-1" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>现代计算机中内存空间都是按照字节(byte)进行划分的，编译器会把各种类型数据安排合适的地址，并占用合适的长度，这种就称为内存对齐，内存对齐是指首地址对齐。</p><h3 id="为什么要内存对齐"><a href="#为什么要内存对齐" class="headerlink" title="为什么要内存对齐"></a>为什么要内存对齐</h3><ul><li>有些<code>CPU</code>只能在特定地址访问数据，不同硬件平台具有差异性，在编译时将分配的内存进行对齐，这就具有平台可以移植性了。</li><li><code>CPU</code> 访问内存时，并不是逐个字节访问，而是以<strong>字长</strong>（word size）为单位访问，所以数据结构应该尽可能地在<strong>自然边界上对齐</strong>，如果访问未对齐的内存，处理器需要做<strong>两次内存访问</strong>，而<strong>对齐</strong>的内存访问仅需要<strong>一次访问</strong>，内存对齐后可以提升性能。</li></ul><p>现代计算机中内存空间都是按照<strong>字节(byte)</strong>进行划分的，编译器会把各种类型数据安排合适的地址，并占用合适的长度，这种就称为内存对齐，内存对齐是指首地址对齐。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。这么设计的目的，是减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219203537840.png" alt="image-20221219203537840"></p><p>变量 a、b 各占据 3 字节的空间，内存对齐后，a、b 占据 4 字节空间，CPU 读取 b 变量的值只需要进行一次内存访问。如果不进行内存对齐，CPU 读取 b 变量的值需要进行 2 次内存访问。第一次访问得到 b 变量的第 1 个字节，第二次访问得到 b 变量的后两个字节。</p><h3 id="对齐边界"><a href="#对齐边界" class="headerlink" title="对齐边界"></a>对齐边界</h3><ul><li>每种类型的对齐值就是它的对齐边界。</li><li>内存对齐要求<strong>数据存储地址</strong>及<strong>占用的字节数</strong>都要是它<strong>对齐边界</strong>的倍数。</li></ul><p>取类型大小与平台最大对齐边界中较小的值。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219203822561.png" alt="image-20221219203822561"></p><h2 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h2><ul><li>结构体对齐边界是成员中最大的对齐边界</li><li>结构体占用字节数需要是类型对齐边界的倍数</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219203923706.png" alt="image-20221219203923706"></p><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="map的结构"><a href="#map的结构" class="headerlink" title="map的结构"></a>map的结构</h2><p>Go语言中map是散列表的引用。散列表可以用来存储键值对元素。</p><p>map类型是map[k]v，其中k是字典的键，v是字典中值对应的数据类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br></pre></td></tr></table></figure><p>map类型的变量本质上是个指针，这些键值对实际上是通过哈希表来存储的。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219205206601.png" alt="image-20221219205206601"></p><h3 id="Map类型"><a href="#Map类型" class="headerlink" title="Map类型"></a>Map类型</h3><p>Go语言中Map类型的底层实现就是哈希表。实现了快速查找、添加、删除的功能。</p><p>map类型变量本质上是一个指针，指向hmap结构体。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219205822411.png" alt="image-20221219205822411"></p><h3 id="bmap的结构"><a href="#bmap的结构" class="headerlink" title="bmap的结构"></a>bmap的结构</h3><ul><li>8个tophash：对应hash值的高8位</li><li>8个key在一起</li><li>8个value在一起</li><li>bmap类型的指针，指向溢出桶</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219210234239.png" alt="image-20221219210234239"></p><h3 id="溢出桶"><a href="#溢出桶" class="headerlink" title="溢出桶"></a>溢出桶</h3><p>哈希表要分配的桶数目大于2^4时，使用溢出桶的概率较大，会预分配2^(B-4)个溢出桶备用；这些溢出桶与常规桶内存中是连续的，只是前2^4作为常规桶，后面作为溢出桶。</p><p>mapextra：溢出桶信息</p><ul><li>overflow：已使用的溢出桶地址</li><li>oldoverflow：旧桶使用的溢出桶地址</li><li>nextoverflow：下个空闲溢出桶地址</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219210314481.png" alt="image-20221219210314481"></p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol><li>取模法：hash % m</li><li>与运算法：hash &amp; (m-1) ，注意m需要是2的整数次幂，否则会出现空桶(绝对不会选中)</li></ol><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><ol><li>开放地址法： 当冲突时，查找下一个位置继续判断是否冲突，直到无冲突为止</li><li>拉链法：冲突时在位置上再建立一条链，存储相应映射到该位置的数据，查找时，也是对于链上元素进行<a href="https://so.csdn.net/so/search?q=遍历&amp;spm=1001.2101.3001.7020">遍历</a>，删除时只需要打上标记，通常不实际进行删除。</li></ol><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219205247417.png" alt="image-20221219205247417"></p><p>哈希冲突会影响哈希表的读写效率，解决方法：</p><ul><li>选择散列均匀的哈希函数</li><li>适时进行扩容</li></ul><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><h3 id="何时扩容"><a href="#何时扩容" class="headerlink" title="何时扩容"></a>何时扩容</h3><p>哈希表中存储的键值对数量和桶数量的比值会作为判断哈希表是否需要扩容的依据，这个依据叫做<strong>负载因子</strong>（Load Factor）通常需要设定一个触发扩容的最大负载因子。<strong>Go语言默认负载因子是6.5</strong>。</p><blockquote><p>负载因子 = 填入哈希表中的元素个数 / 哈希表的长度</p></blockquote><h3 id="如何扩容"><a href="#如何扩容" class="headerlink" title="如何扩容"></a>如何扩容</h3><p><strong>渐进式扩容</strong>：把键值对迁移时间分摊到多次哈希表操作中的方式。可以避免一次性扩容带来的性能瞬时抖动。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219210045567.png" alt="image-20221219210045567"></p><p><strong>翻倍扩容</strong>：Go语言默认负载因子是6.5，超过这个数会触发翻倍扩容</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221219210452986.png" alt="image-20221219210452986"></p><p><strong>等量扩容</strong>：负载因子没有超标，但溢出桶较多，会触发等量扩容。</p><p>常规桶数量 = 2 的 B 次方</p><p>解释：若溢出桶过多也会触发 map 的扩容, 这是基于这样的考虑, 向 map 中插入大量的元素, 哈希桶将逐渐被填满, 这个过程中也可能创建了一些溢出桶, 但此时装载因子并没有超过设定的阈值, 然后对这些 map 做删除操作, 删除元素之后, map 中的元素数目变少, 使得装载因子降低, 而后又重复上述的过程, 最终使得整体的装载因子不大, 但整个 map 中存在了大量的溢出桶, 因此当溢出桶数目过多时, 即便没有达到装载因子 6.5 的阈值也会触发扩容,其目的是整理map桶。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>幼麟实验室bilibili：<a href="https://www.bilibili.com/video/BV1hv411x7we/?spm_id_from=333.999.0.0&amp;vd_source=44bd80a738e14b1c370a0a540eb6975f">https://space.bilibili.com/567195437/?spm_id_from=333.999.0.0</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-错误恢复（实现一个GoWeb框架Gee）</title>
      <link href="/archives/3bab1fc2.html"/>
      <url>/archives/3bab1fc2.html</url>
      
        <content type="html"><![CDATA[<h1 id="错误恢复"><a href="#错误恢复" class="headerlink" title="错误恢复"></a>错误恢复</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>实现错误处理机制。</li></ul><h2 id="panic、defer、recover"><a href="#panic、defer、recover" class="headerlink" title="panic、defer、recover"></a>panic、defer、recover</h2><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><p><strong>介绍：</strong></p><p>panic 是一个 Go 内置函数，它用来停止当前常规控制流并启动 panicking（运行时恐慌）过程。当函数 F 调用 panic 函数时，函数 F 的执行停止，函数 F 中已进行了求值的 defer 函数都将得到正常执行，然后函数 F 将控制权返还给其调用者。函数 F 之后的行为就如同调用者调用的函数是 panic 一样，该 panicking（运行时恐慌）过程将继续在栈上进行下去，直到当前 goroutine 中的所有函数都返回为止，此时程序将崩溃退出。</p><p>Go 语言中，比较常见的错误处理方法是返回 error，由调用者决定后续如何处理。但是如果是无法恢复的错误，可以手动触发 panic，当然如果在程序运行过程中出现了类似于数组越界的错误，panic 也会被触发。panic 会中止当前执行的程序，退出。</p><p>主动触发panic的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;before panic&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;crash&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;after panic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr[<span class="number">4</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// panic: runtime error: index out of range [4] with length 3</span></span><br></pre></td></tr></table></figure><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>panic 会导致程序被中止，但是在退出前，会先处理完当前协程上已经defer 的任务，执行完成后再退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;defer func&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr[<span class="number">4</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">defer func</span></span><br><span class="line"><span class="comment">panic: runtime error: index out of range [4] with length 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><p>Recover 是一个Go语言的内建函数，可以让进入宕机流程中的 goroutine 恢复过来，recover 仅在延迟函数 defer 中有效，在正常的执行过程中，调用 recover 会返回 nil 并且没有其他任何效果，如果当前的 goroutine 陷入恐慌，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test_recover</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;defer func&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;recover success&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(arr[<span class="number">4</span>])</span><br><span class="line">fmt.Println(<span class="string">&quot;after panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test_recover()</span><br><span class="line">fmt.Println(<span class="string">&quot;after recover&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">defer func</span></span><br><span class="line"><span class="comment">recover success</span></span><br><span class="line"><span class="comment">after recover</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>recover 捕获了 panic，程序正常结束。<em>test_recover()</em> 中的 <em>after panic</em> 没有打印，这是正确的，当 panic 被触发时，控制权就被交给了 defer 。在 <em>main()</em> 中打印了 <em>after recover</em>，说明程序已经恢复正常，继续往下执行直到结束。</p><h2 id="设计错误处理机制"><a href="#设计错误处理机制" class="headerlink" title="设计错误处理机制"></a>设计错误处理机制</h2><p>对一个 Web 框架而言，错误处理机制是非常必要的。如果框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。我们要避免因为这些原因导致系统宕机。</p><p>添加一个非常简单的错误处理机制，即在此类错误发生时，向用户返回 <em>Internal Server Error</em>，并且在日志中打印必要的错误信息，方便进行错误定位。</p><p><strong>将错误处理设置成中间件</strong></p><p><strong>recovery.go</strong></p><p><code>Recovery</code> 的实现:</p><ol><li>使用 defer 挂载上错误恢复的函数。</li><li>在这个函数中调用 <em>recover()</em>，捕获 panic，并且将堆栈信息打印在日志中，向用户返回 <em>Internal Server Error</em>。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取触发 panic 的堆栈信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(message <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> pcs [<span class="number">32</span>]<span class="type">uintptr</span></span><br><span class="line">n := runtime.Callers(<span class="number">3</span>, pcs[:]) <span class="comment">// skip first 3 caller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str strings.Builder</span><br><span class="line">str.WriteString(message + <span class="string">&quot;\nTraceback:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, pc := <span class="keyword">range</span> pcs[:n] &#123;</span><br><span class="line">fn := runtime.FuncForPC(pc)</span><br><span class="line">file, line := fn.FileLine(pc)</span><br><span class="line">str.WriteString(fmt.Sprintf(<span class="string">&quot;\n\t%s:%d&quot;</span>, file, line))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recovery</span><span class="params">()</span></span> HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 使用 defer 挂载上错误恢复的函数。</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">message := fmt.Sprintf(<span class="string">&quot;%s&quot;</span>, err)</span><br><span class="line">                <span class="comment">// 捕获 panic，并且将堆栈信息打印在日志中</span></span><br><span class="line">log.Printf(<span class="string">&quot;%s\n\n&quot;</span>, trace(message))</span><br><span class="line">c.Fail(http.StatusInternalServerError, <span class="string">&quot;Internal Server Error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;gee&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gee.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;Hello jpc\n&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 越界触发panic测试</span></span><br><span class="line">r.GET(<span class="string">&quot;/panic&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">names := []<span class="type">string</span>&#123;<span class="string">&quot;jpc&quot;</span>&#125;</span><br><span class="line">c.String(http.StatusOK, names[<span class="number">100</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后访问，发现程序没有因为错误而宕机，而是返回”Internal Server Error”。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221213203513579.png" alt="image-20221213203513579"></p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/jpc901/Gee/tree/master/demo07">项目地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> GoWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-模板（实现一个GoWeb框架Gee）</title>
      <link href="/archives/30e5e055.html"/>
      <url>/archives/30e5e055.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>实现静态资源服务。</li><li>支持HTML模板渲染。</li></ul><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>模板可以理解为事先定义好的HTML文档文件，模板渲染的作用机制可以简单理解为文本替换操作–使用相应的数据去替换HTML文档中事先准备好的标记。</p><p><strong>前后端分离的开发模式</strong>：即 Web 后端提供 <strong>RESTful</strong> 接口，返回结构化的数据(通常为 JSON 或者 XML)。前端使用 <strong>AJAX</strong> 技术请求到所需的数据，利用 JavaScript 进行渲染。</p><p><strong>前后端分离开发模式的优势</strong>：<strong>前后端解耦</strong>，前端注于界面设计实现，只需要考虑拿到数据后如何渲染即可。后端专心解决资源利用，并发，数据库等问题，只需要考虑数据如何生成。同一套后端服务能够同时支撑小程序、移动APP、PC端 Web 页面，以及对外提供的接口。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><h3 id="处理静态文件"><a href="#处理静态文件" class="headerlink" title="处理静态文件"></a>处理静态文件</h3><p>将所有的静态文件放在<code>/usr/web</code>目录下，映射到真实的文件后，将文件返回。</p><p>返回：通过<code>net/http</code>库解析请求的地址，映射到服务器上文件的真实地址，交给<code>http.FileServer</code>处理。</p><p>gee.go</p><p><code>Static</code>这个方法：用户可以将磁盘上的某个文件夹<code>root</code>映射到路由<code>relativePath</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r := gee.New()</span><br><span class="line">r.Static(<span class="string">&quot;/assets&quot;</span>, <span class="string">&quot;/usr/jpc/blog/static&quot;</span>)</span><br><span class="line"><span class="comment">// 或相对路径 r.Static(&quot;/assets&quot;, &quot;./static&quot;)</span></span><br><span class="line">r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line"><span class="comment">// 用户访问localhost:9999/assets/xxx.js，最终返回/usr/jpc/blog/static/xxx.js。</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建静态处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> createStaticHandler(relativePath <span class="type">string</span>, fs http.FileSystem) HandlerFunc &#123;</span><br><span class="line">absolutePath := path.Join(group.prefix, relativePath)</span><br><span class="line">fileServer := http.StripPrefix(absolutePath, http.FileServer(fs))</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">file := c.Param(<span class="string">&quot;filepath&quot;</span>)</span><br><span class="line"><span class="comment">// 检查文件是否存在或者我们是否有权限访问它</span></span><br><span class="line"><span class="keyword">if</span> _, err := fs.Open(file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.Status(http.StatusNotFound)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileServer.ServeHTTP(c.Writer, c.Req)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Static 提供静态文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Static(relativePath <span class="type">string</span>, root <span class="type">string</span>) &#123;</span><br><span class="line">handler := group.createStaticHandler(relativePath, http.Dir(root))</span><br><span class="line">urlPattern := path.Join(relativePath, <span class="string">&quot;/*filepath&quot;</span>)</span><br><span class="line"><span class="comment">// 注册GET处理程序</span></span><br><span class="line">group.GET(urlPattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTML-模板渲染"><a href="#HTML-模板渲染" class="headerlink" title="HTML 模板渲染"></a>HTML 模板渲染</h3><p>go语言提供了<code>html/template</code>模板库，为 HTML 提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">*RouterGroup</span><br><span class="line">router        *router</span><br><span class="line">groups        []*RouterGroup     <span class="comment">// 存储所有路由组</span></span><br><span class="line">htmlTemplates *template.Template <span class="comment">// html render</span></span><br><span class="line">funcMap       template.FuncMap   <span class="comment">// html render</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义模板渲染函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> SetFuncMap(funcMap template.FuncMap) &#123;</span><br><span class="line">engine.funcMap = funcMap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有模板加载进内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> LoadHTMLGlob(pattern <span class="type">string</span>) &#123;</span><br><span class="line">engine.htmlTemplates = template.Must(template.New(<span class="string">&quot;&quot;</span>).Funcs(engine.funcMap).ParseGlob(pattern))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context.go支持根据模板文件名选择模板进行渲染。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// engine pointer</span></span><br><span class="line">engine *Engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> HTML(code <span class="type">int</span>, name <span class="type">string</span>, data <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line"><span class="keyword">if</span> err := c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.Fail(<span class="number">500</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gee.go实例化 Context 时，还需要给 <code>c.engine</code> 赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">c := newContext(w, req)</span><br><span class="line">c.handlers = middlewares</span><br><span class="line">c.engine = engine</span><br><span class="line">engine.router.handle(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;gee&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatAsDate</span><span class="params">(t time.Time)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">year, month, day := t.Date()</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%d-%02d-%02d&quot;</span>, year, month, day)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gee.New()</span><br><span class="line">r.Use(gee.Logger())</span><br><span class="line">r.SetFuncMap(template.FuncMap&#123;</span><br><span class="line"><span class="string">&quot;FormatAsDate&quot;</span>: FormatAsDate,</span><br><span class="line">&#125;)</span><br><span class="line">r.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>)</span><br><span class="line">r.Static(<span class="string">&quot;/assets&quot;</span>, <span class="string">&quot;./static&quot;</span>)</span><br><span class="line"></span><br><span class="line">stu1 := &amp;student&#123;Name: <span class="string">&quot;jpc&quot;</span>, Age: <span class="number">20</span>&#125;</span><br><span class="line">stu2 := &amp;student&#123;Name: <span class="string">&quot;Jack&quot;</span>, Age: <span class="number">22</span>&#125;</span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;css.tmpl&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/students&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;arr.tmpl&quot;</span>, gee.H&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>:  <span class="string">&quot;gee&quot;</span>,</span><br><span class="line"><span class="string">&quot;stuArr&quot;</span>: [<span class="number">2</span>]*student&#123;stu1, stu2&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/date&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;custom_func.tmpl&quot;</span>, gee.H&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>: <span class="string">&quot;gee&quot;</span>,</span><br><span class="line"><span class="string">&quot;now&quot;</span>:   time.Date(<span class="number">2019</span>, <span class="number">8</span>, <span class="number">17</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问页面</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221213193944336.png" alt="image-20221213193944336"></p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/jpc901/Gee/tree/master/demo06">项目地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> GoWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-中间件（实现一个GoWeb框架Gee）</title>
      <link href="/archives/c43c0113.html"/>
      <url>/archives/c43c0113.html</url>
      
        <content type="html"><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>设计并实现 Web 框架的中间件机制。</li><li>实现通用的<code>Logger</code>中间件，能够记录请求到响应所花费的时间。</li></ul><h2 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h2><p>中间件，就是非业务的技术类组件。Web 框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此，框架需要有一个插口，允许用户自己定义功能，嵌入到框架中，仿佛这个功能是框架原生支持的一样。因此，对中间件而言，需要考虑2个比较关键的点：</p><ul><li>插入点在哪？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件逻辑就会非常复杂。如果插入点离用户太近，那和用户直接定义一组函数，每次在 Handler 中手工调用没有多大的优势了。</li><li>中间件的输入是什么？中间件的输入，决定了扩展能力。暴露的参数太少，用户发挥空间有限。</li></ul><p>那对于一个 Web 框架而言，中间件应该设计成什么样呢？接下来的实现，基本参考了 Gin 框架。</p><h2 id="中间件设计"><a href="#中间件设计" class="headerlink" title="中间件设计"></a>中间件设计</h2><p>Gee 的中间件的定义与路由映射的 Handler 一致，处理的输入是<code>Context</code>对象。插入点是框架接收到请求初始化<code>Context</code>对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对<code>Context</code>进行二次加工。另外通过调用<code>(*Context).Next()</code>函数，中间件可等待用户自己定义的 <code>Handler</code>处理结束后，再做一些额外的操作，例如计算本次处理所用时间等。即 Gee 的中间件支持用户在请求被处理的前后，做一些额外的操作。举个例子，我们希望最终能够支持如下定义的中间件，<code>c.Next()</code>表示等待执行其他的中间件或用户的<code>Handler</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Logger</span><span class="params">()</span></span> HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 开始时间</span></span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="comment">//执行next</span></span><br><span class="line">c.Next()</span><br><span class="line"><span class="comment">// 计算总时间</span></span><br><span class="line">log.Printf(<span class="string">&quot;[%d] %s in %v&quot;</span>, c.StatusCode, c.Req.RequestURI, time.Since(t))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间件的调用顺序以及介绍可以看这篇<a href="https://jpcly.cn/archives/4533f4b0.html">文章</a></p><h3 id="gin框架注册中间件"><a href="#gin框架注册中间件" class="headerlink" title="gin框架注册中间件"></a>gin框架注册中间件</h3><p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129142317272.png" alt="image-20221129142317272"></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129142332221.png" alt="image-20221129142332221"></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129142348794.png" alt="image-20221129142348794"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>: <span class="string">&quot;index&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 in ...&quot;</span>)</span><br><span class="line">c.Next() <span class="comment">// 调用后续的处理函数</span></span><br><span class="line"><span class="comment">//c.Abort() // 阻止调用后续的处理函数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;m2 out ...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 in ...&quot;</span>)</span><br><span class="line">c.Next() <span class="comment">// 调用后续的处理函数</span></span><br><span class="line"><span class="comment">//c.Abort() // 阻止调用后续的处理函数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;m1 out ...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, m1, m2, indexHandler)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上程序运行结果为：</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129142506736.png" alt="image-20221129142506736"></p><h3 id="此Web框架中间件设计"><a href="#此Web框架中间件设计" class="headerlink" title="此Web框架中间件设计"></a>此Web框架中间件设计</h3><p>需要支持设置多个中间件，依次进行调用。</p><p><strong>设计思路</strong>：当接收到请求后，匹配路由，该请求的所有信息都保存在<code>Context</code>中。中间件也不例外，接收到请求后，应查找所有应作用于该路由的中间件，保存在<code>Context</code>中，依次进行调用。</p><p>context.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// origin objects</span></span><br><span class="line">Writer http.ResponseWriter</span><br><span class="line">Req    *http.Request</span><br><span class="line"><span class="comment">// request info</span></span><br><span class="line">Path   <span class="type">string</span></span><br><span class="line">Method <span class="type">string</span></span><br><span class="line">Params <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="comment">// response info</span></span><br><span class="line">StatusCode <span class="type">int</span></span><br><span class="line"><span class="comment">// middleware</span></span><br><span class="line">handlers []HandlerFunc</span><br><span class="line">index    <span class="type">int</span><span class="comment">// 记录当前执行到第几个中间件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newContext</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> *Context &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;</span><br><span class="line">Path:   req.URL.Path,</span><br><span class="line">Method: req.Method,</span><br><span class="line">Req:    req,</span><br><span class="line">Writer: w,</span><br><span class="line">index:  <span class="number">-1</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次调用中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Next() &#123;</span><br><span class="line">c.index++</span><br><span class="line">s := <span class="built_in">len</span>(c.handlers)</span><br><span class="line"><span class="keyword">for</span> ; c.index &lt; s; c.index++ &#123;</span><br><span class="line">c.handlers[c.index](c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">    part1</span><br><span class="line">    c.Next()</span><br><span class="line">    part2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">    part3</span><br><span class="line">    c.Next()</span><br><span class="line">    part4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行顺序就是<code>part1 -&gt; part3 -&gt; Handler -&gt; part 4 -&gt; part2</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="将中间件应用到某个-Group"><a href="#将中间件应用到某个-Group" class="headerlink" title="将中间件应用到某个 Group"></a>将中间件应用到某个 Group</h3><p>gee.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将中间件应用到某个 Group </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Use(middlewares ...HandlerFunc) &#123;</span><br><span class="line">group.middlewares = <span class="built_in">append</span>(group.middlewares, middlewares...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ServeHTTP 函数当接收到一个具体请求时，要判断该请求适用于哪些中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line"><span class="keyword">var</span> middlewares []HandlerFunc</span><br><span class="line">    <span class="comment">// 在这里我们简单通过 URL 的前缀来判断。</span></span><br><span class="line"><span class="keyword">for</span> _, group := <span class="keyword">range</span> engine.groups &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(req.URL.Path, group.prefix) &#123;</span><br><span class="line">middlewares = <span class="built_in">append</span>(middlewares, group.middlewares...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c := newContext(w, req)</span><br><span class="line">c.handlers = middlewares <span class="comment">// 得到中间件列表后，赋值给 c.handlers。</span></span><br><span class="line">engine.router.handle(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>router.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> handle(c *Context) &#123;</span><br><span class="line">n, params := r.getRoute(c.Method, c.Path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">key := c.Method + <span class="string">&quot;-&quot;</span> + n.pattern</span><br><span class="line">c.Params = params</span><br><span class="line">c.handlers = <span class="built_in">append</span>(c.handlers, r.handlers[key])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.handlers = <span class="built_in">append</span>(c.handlers, <span class="function"><span class="keyword">func</span><span class="params">(c *Context)</span></span> &#123;</span><br><span class="line">c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/jpc901/Gee/tree/master/demo05">代码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> GoWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-分组控制（实现一个GoWeb框架Gee）</title>
      <link href="/archives/de03f0bd.html"/>
      <url>/archives/de03f0bd.html</url>
      
        <content type="html"><![CDATA[<h1 id="路由分组控制"><a href="#路由分组控制" class="headerlink" title="路由分组控制"></a>路由分组控制</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>实现路由分组控制</li></ul><h2 id="分组控制的意义"><a href="#分组控制的意义" class="headerlink" title="分组控制的意义"></a>分组控制的意义</h2><p>分组控制(Group Control)是 Web 框架应提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。</p><p>真实的业务场景中，往往某一组路由需要相似的处理。例如：</p><ul><li>以<code>/post</code>开头的路由匿名可访问。</li><li>以<code>/admin</code>开头的路由需要鉴权。</li><li>以<code>/api</code>开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</li></ul><p>大部分情况下的路由分组，是以相同的前缀来区分的。因此，我们今天实现的分组控制也是以前缀来区分，并且支持分组的嵌套。例如<code>/post</code>是一个分组，<code>/post/a</code>和<code>/post/b</code>可以是该分组下的子分组。作用在<code>/post</code>分组上的中间件(middleware)，也都会作用在子分组，子分组还可以应用自己特有的中间件。</p><p>中间件可以给框架提供无限的扩展能力，应用在分组上，可以使得分组控制的收益更为明显，而不是共享相同的路由前缀这么简单。例如<code>/admin</code>的分组，可以应用鉴权中间件；<code>/</code>分组应用日志中间件，<code>/</code>是默认的最顶层的分组，也就意味着给所有的路由，即整个框架增加了记录日志的能力。</p><h2 id="分组嵌套"><a href="#分组嵌套" class="headerlink" title="分组嵌套"></a>分组嵌套</h2><ol><li>找到当前分组的父亲（parent）。</li><li>存储应用在该分组的中间件。</li></ol><h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><h3 id="Group的定义"><a href="#Group的定义" class="headerlink" title="Group的定义"></a>Group的定义</h3><p>在Group中，保存一个指针，指向<code>Engine</code>，整个框架的所有资源都是由<code>Engine</code>统一协调的，那么就可以通过<code>Engine</code>间接地访问各种接口了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">prefix      <span class="type">string</span></span><br><span class="line">middlewares []HandlerFunc <span class="comment">// 中支持间件</span></span><br><span class="line">parent      *RouterGroup  <span class="comment">// 支持嵌套</span></span><br><span class="line">engine      *Engine       <span class="comment">// 所有组共享一个Engine实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">*RouterGroup</span><br><span class="line">router *router</span><br><span class="line">groups []*RouterGroup <span class="comment">// 存储所有的组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现RouterGroup"><a href="#实现RouterGroup" class="headerlink" title="实现RouterGroup"></a>实现RouterGroup</h3><p><code>Engine</code>作为最顶层的分组，也就是说<code>Engine</code>拥有<code>RouterGroup</code>所有的能力。</p><p><code>Engine</code>从某种意义上继承了<code>RouterGroup</code>的所有属性和方法，因为 (*Engine).engine 是指向自己的。这样实现，我们既可以像原来一样添加路由，也可以通过分组添加路由。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New 构造函数 gee.Engine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line">   engine := &amp;Engine&#123;router: newRouter()&#125;</span><br><span class="line">   engine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;</span><br><span class="line">   engine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;</span><br><span class="line">   <span class="keyword">return</span> engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Group 定义一个新的 RouterGroup</span></span><br><span class="line"><span class="comment">// 存储所有组共享相同的Engine实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> Group(prefix <span class="type">string</span>) *RouterGroup &#123;</span><br><span class="line">   engine := group.engine</span><br><span class="line">   newGroup := &amp;RouterGroup&#123;</span><br><span class="line">      prefix: group.prefix + prefix,</span><br><span class="line">      parent: group,</span><br><span class="line">      engine: engine,</span><br><span class="line">   &#125;</span><br><span class="line">   engine.groups = <span class="built_in">append</span>(engine.groups, newGroup) <span class="comment">// 添加一个分组</span></span><br><span class="line">   <span class="keyword">return</span> newGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> addRoute(method <span class="type">string</span>, comp <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">   pattern := group.prefix + comp</span><br><span class="line">   log.Printf(<span class="string">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class="line">   <span class="comment">// 通过group去调用engine实例再去添加路由</span></span><br><span class="line">   group.engine.router.addRoute(method, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET GET请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">   group.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST POST请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(group *RouterGroup)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">   group.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := gee.New()</span><br><span class="line">   r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">      c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Index Page&lt;/h1&gt;&quot;</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   v1 := r.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      v1.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">         c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      v1.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">         c.String(http.StatusOK, <span class="string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Query(<span class="string">&quot;name&quot;</span>), c.Path)</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   v2 := r.Group(<span class="string">&quot;/v2&quot;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      v2.GET(<span class="string">&quot;/hello/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">         c.String(http.StatusOK, <span class="string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Param(<span class="string">&quot;name&quot;</span>), c.Path)</span><br><span class="line">      &#125;)</span><br><span class="line">      v2.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">         c.JSON(http.StatusOK, gee.H&#123;</span><br><span class="line">            <span class="string">&quot;username&quot;</span>: c.PostForm(<span class="string">&quot;username&quot;</span>),</span><br><span class="line">            <span class="string">&quot;password&quot;</span>: c.PostForm(<span class="string">&quot;password&quot;</span>),</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> GoWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-Trie树实现动态路由（实现一个GoWeb框架Gee）</title>
      <link href="/archives/9475d074.html"/>
      <url>/archives/9475d074.html</url>
      
        <content type="html"><![CDATA[<h1 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>使用 Trie 树实现动态路由(dynamic route)解析。</li><li>支持两种模式<code>:name</code>和<code>*filepath</code>。</li></ul><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><ul><li><p>前面使用map构建路由表，通过map索引只能实现简单的<strong>静态路由</strong>。但是<strong>动态路由</strong>就需要用另一种方法（trie树）。</p></li><li><p>在之前学习算法的时候每个节点存放的是一个字符，这个路由无非就是把每个节点存放路由对应的字符串（路由中的一部分）。并且添加两种模式<strong>参数匹配</strong><code>:name</code>和<strong>通配</strong><code>*filepath</code>。</p></li></ul><p><img src="D:\typora\images\image-20221203205818813.png" alt="image-20221203205818813"></p><h3 id="trie-go"><a href="#trie-go" class="headerlink" title="trie.go"></a>trie.go</h3><p>每个节点结构体信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">pattern  <span class="type">string</span> <span class="comment">// 待匹配路由，例如 /p/:lang</span></span><br><span class="line">part     <span class="type">string</span> <span class="comment">// 路由中的一部分，例如 :lang</span></span><br><span class="line">children []*node <span class="comment">// 子节点，例如 [doc, tutorial, intro]</span></span><br><span class="line">isWild   <span class="type">bool</span> <span class="comment">// 是否精确匹配，part 含有 : 或 * 时为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个匹配成功的节点，用于插入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> matchChild(part <span class="type">string</span>) *node &#123;</span><br><span class="line">   <span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">      <span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line">         <span class="keyword">return</span> child</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有匹配成功的节点，用于查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> matchChildren(part <span class="type">string</span>) []*node &#123;</span><br><span class="line">   nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">for</span> _, child := <span class="keyword">range</span> n.children &#123;</span><br><span class="line">      <span class="keyword">if</span> child.part == part || child.isWild &#123;</span><br><span class="line">         nodes = <span class="built_in">append</span>(nodes, child)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入和查找函数</p><ul><li>插入：递归查找每一层的节点，如果没有匹配到当前<code>part</code>的节点，则新建一个。</li><li>查找：递归查询每一层的节点，退出规则是，匹配到了<code>*</code>，匹配失败，或者匹配到了第<code>len(parts)</code>层节点。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> insert(pattern <span class="type">string</span>, parts []<span class="type">string</span>, height <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="comment">// 如果height已经到达字符串数组末尾直接返回</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(parts) == height &#123;</span><br><span class="line">      n.pattern = pattern</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当前节点对应的part</span></span><br><span class="line">   part := parts[height]</span><br><span class="line">   child := n.matchChild(part) <span class="comment">// 第一个匹配成功的节点</span></span><br><span class="line">   <span class="keyword">if</span> child == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 新建一个结点加入到当前节点的孩子数组中去</span></span><br><span class="line">      child = &amp;node&#123;part: part, isWild: part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> || part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>&#125;</span><br><span class="line">      n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">   &#125;</span><br><span class="line">   child.insert(pattern, parts, height+<span class="number">1</span>) <span class="comment">// 继续往下找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span></span> search(parts []<span class="type">string</span>, height <span class="type">int</span>) *node &#123;</span><br><span class="line">   <span class="comment">// 如果是height已经遍历完parts或者n.part包含字符*前缀就直接返回当前节点</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> n.pattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   part := parts[height]</span><br><span class="line">   children := n.matchChildren(part) <span class="comment">// 当前节点的孩子节点的数组</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, child := <span class="keyword">range</span> children &#123;</span><br><span class="line">      result := child.search(parts, height+<span class="number">1</span>) <span class="comment">// 递归往下找节点</span></span><br><span class="line">      <span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> result</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Router路由"><a href="#Router路由" class="headerlink" title="Router路由"></a>Router路由</h2><p>将Trie树应用到路由中</p><ul><li>roots存储每种请求方式的Trie树的根节点</li><li>handlers存储每种请求方式的HandlerFunc</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">roots    <span class="keyword">map</span>[<span class="type">string</span>]*node</span><br><span class="line">handlers <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="router-go"><a href="#router-go" class="headerlink" title="router.go"></a>router.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRouter</span><span class="params">()</span></span> *router &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;router&#123;</span><br><span class="line">      roots:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*node),</span><br><span class="line">      handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc),</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将pattern拆分并返回一个parts字符串数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parsePattern</span><span class="params">(pattern <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">   vs := strings.Split(pattern, <span class="string">&quot;/&quot;</span>) <span class="comment">// 按照&quot;/&quot;拆分</span></span><br><span class="line"></span><br><span class="line">   parts := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">for</span> _, item := <span class="keyword">range</span> vs &#123;</span><br><span class="line">      <span class="keyword">if</span> item != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">         parts = <span class="built_in">append</span>(parts, item)</span><br><span class="line">         <span class="keyword">if</span> item[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> parts</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加路由信息，并将路由信息映射到对应的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">   parts := parsePattern(pattern) <span class="comment">// 获取路径数组</span></span><br><span class="line"></span><br><span class="line">   key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">   _, ok := r.roots[method] <span class="comment">// 检查这个方法是否有对应的根节点，没有就创建一个根节点</span></span><br><span class="line">   <span class="keyword">if</span> !ok &#123;                 <span class="comment">// 如果不存在</span></span><br><span class="line">      r.roots[method] = &amp;node&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   r.roots[method].insert(pattern, parts, <span class="number">0</span>) <span class="comment">// 将路径插入到trie树中去</span></span><br><span class="line">   r.handlers[key] = handler                 <span class="comment">// 将路由信息映射到对应的处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路由信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> getRoute(method <span class="type">string</span>, path <span class="type">string</span>) (*node, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>) &#123;</span><br><span class="line">   searchParts := parsePattern(path) <span class="comment">// 获取路径数组</span></span><br><span class="line">   params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">   root, ok := r.roots[method]</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   n := root.search(searchParts, <span class="number">0</span>) <span class="comment">// 从根节点往下查询，直至查找到节点</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">      parts := parsePattern(n.pattern)</span><br><span class="line">      <span class="keyword">for</span> index, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">         <span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span> &#123; <span class="comment">// 模糊匹配</span></span><br><span class="line">            params[part[<span class="number">1</span>:]] = searchParts[index] <span class="comment">// 查找下去</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="built_in">len</span>(part) &gt; <span class="number">1</span> &#123; <span class="comment">// 直接匹配到*</span></span><br><span class="line">            params[part[<span class="number">1</span>:]] = strings.Join(searchParts[index:], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> n, params</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> getRoutes(method <span class="type">string</span>) []*node &#123;</span><br><span class="line">   root, ok := r.roots[method]</span><br><span class="line">   <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   nodes := <span class="built_in">make</span>([]*node, <span class="number">0</span>)</span><br><span class="line">   root.travel(&amp;nodes)</span><br><span class="line">   <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> handle(c *Context) &#123;</span><br><span class="line">   n, params := r.getRoute(c.Method, c.Path)</span><br><span class="line">   <span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">      c.Params = params</span><br><span class="line">      key := c.Method + <span class="string">&quot;-&quot;</span> + n.pattern</span><br><span class="line">      r.handlers[key](c)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="context-go"><a href="#context-go" class="headerlink" title="context.go"></a>context.go</h3><p>需要对 Context 对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数存储到<code>Params</code>中，通过<code>c.Param(&quot;lang&quot;)</code>的方式获取到对应的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// origin objects</span></span><br><span class="line">Writer http.ResponseWriter</span><br><span class="line">Req    *http.Request</span><br><span class="line"><span class="comment">// request info</span></span><br><span class="line">Path   <span class="type">string</span></span><br><span class="line">Method <span class="type">string</span></span><br><span class="line">Params <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"><span class="comment">// response info</span></span><br><span class="line">StatusCode <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Param(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">value, _ := c.Params[key]</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   r := gee.New()</span><br><span class="line">   r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">      c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">      c.String(http.StatusOK, <span class="string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Query(<span class="string">&quot;name&quot;</span>), c.Path)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   r.GET(<span class="string">&quot;/hello/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">      c.String(http.StatusOK, <span class="string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Param(<span class="string">&quot;name&quot;</span>), c.Path)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   r.GET(<span class="string">&quot;/assets/*filepath&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">      c.JSON(http.StatusOK, gee.H&#123;<span class="string">&quot;filepath&quot;</span>: c.Param(<span class="string">&quot;filepath&quot;</span>)&#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   r.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> GoWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-上下文Context（实现一个GoWeb框架Gee）</title>
      <link href="/archives/e54117d5.html"/>
      <url>/archives/e54117d5.html</url>
      
        <content type="html"><![CDATA[<h1 id="上下文Context"><a href="#上下文Context" class="headerlink" title="上下文Context"></a>上下文Context</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>将<code>路由(router)</code>独立出来，方便之后增强。</li><li>设计<code>上下文(Context)</code>，封装 Request 和 Response ，提供对 JSON、HTML 等返回类型的支持。</li></ul><h2 id="设计Context"><a href="#设计Context" class="headerlink" title="设计Context"></a>设计Context</h2><ul><li><p>Web服务是根据请求<code>*http.Request</code>，构造响应<code>http.ResponseWriter</code>。</p></li><li><p>要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要设置的信息。</p></li><li>若不进行有效的封装，那么框架的用户将需要写大量重复，繁杂的代码，而且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。</li></ul><p>栗子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装之前</span></span><br><span class="line">obj = <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;geektutu&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;1234&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)<span class="comment">//设置 http response 响应头</span></span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line">encoder := json.NewEncoder(w) <span class="comment">// 编码的一个实例</span></span><br><span class="line"><span class="keyword">if</span> err := encoder.Encode(obj); err != <span class="literal">nil</span> &#123; <span class="comment">// 编码</span></span><br><span class="line">    http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装之后</span></span><br><span class="line">c.JSON(http.StatusOK, gee.H&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: c.PostForm(<span class="string">&quot;username&quot;</span>),</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: c.PostForm(<span class="string">&quot;password&quot;</span>),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>Context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。</li><li>设计 Context 结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都统一使用 Context 实例， Context 就像一次会话的百宝箱，可以找到任何东西。</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gee/</span><br><span class="line">  |--gee.go</span><br><span class="line">  |--context.go</span><br><span class="line">  |--router.go</span><br><span class="line">  |--go.mod</span><br><span class="line">main.go</span><br><span class="line">go.mod</span><br></pre></td></tr></table></figure><h3 id="context-go"><a href="#context-go" class="headerlink" title="context.go"></a>context.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// H 给map[string]interface&#123;&#125;起了一个别名gee.H 用来存放各种响应数据gin中源码也是类似</span></span><br><span class="line"><span class="keyword">type</span> H <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// origin objects</span></span><br><span class="line">Writer http.ResponseWriter</span><br><span class="line">Req    *http.Request</span><br><span class="line"><span class="comment">// 请求信息</span></span><br><span class="line">Path   <span class="type">string</span></span><br><span class="line">Method <span class="type">string</span></span><br><span class="line"><span class="comment">// 响应信息</span></span><br><span class="line">StatusCode <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个Context实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newContext</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> *Context &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;</span><br><span class="line">Writer: w,</span><br><span class="line">Req:    req,</span><br><span class="line">Path:   req.URL.Path,</span><br><span class="line">Method: req.Method,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PostForm 获取Query和PostForm参数的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> PostForm(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Req.FormValue(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query 获取Query和PostForm参数的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Query(key <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Req.URL.Query().Get(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status 设置响应头状态码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Status(code <span class="type">int</span>) &#123;</span><br><span class="line">c.StatusCode = code</span><br><span class="line">c.Writer.WriteHeader(code)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetHeader 设置响应头返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> SetHeader(key <span class="type">string</span>, value <span class="type">string</span>) &#123;</span><br><span class="line">c.Writer.Header().Set(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造String响应方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> String(code <span class="type">int</span>, format <span class="type">string</span>, value ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line">c.Writer.Write([]<span class="type">byte</span>(fmt.Sprintf(format, value)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 构造JSON响应方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> JSON(code <span class="type">int</span>, obj <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line">encoder := json.NewEncoder(c.Writer)</span><br><span class="line"><span class="keyword">if</span> err := encoder.Encode(obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(c.Writer, err.Error(), <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Data 构造Data响应方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> Data(code <span class="type">int</span>, data []<span class="type">byte</span>) &#123;</span><br><span class="line">c.Status(code)</span><br><span class="line">c.Writer.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML 构造HTML响应方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span></span> HTML(code <span class="type">int</span>, html <span class="type">string</span>) &#123;</span><br><span class="line">c.SetHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">c.Status(code)</span><br><span class="line">c.Writer.Write([]<span class="type">byte</span>(html))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="router-go"><a href="#router-go" class="headerlink" title="router.go"></a>router.go</h3><p>路由：将和路由相关的方法和结构提取了出来，放到了一个新的文件中<code>router.go</code>，方便我们下一次对 router 的功能进行增强，例如提供动态路由的支持。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">handlers <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRouter</span><span class="params">()</span></span> *router &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;router&#123;handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class="line">key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">r.handlers[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *router)</span></span> handle(c *Context) &#123;</span><br><span class="line">key := c.Method + <span class="string">&quot;-&quot;</span> + c.Path</span><br><span class="line"><span class="keyword">if</span> handler, ok := r.handlers[key]; ok &#123;</span><br><span class="line">handler(c)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.String(http.StatusNotFound, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="gee-go"><a href="#gee-go" class="headerlink" title="gee.go"></a>gee.go</h3><p>框架入口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc 定义gee使用的请求处理程序</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine 实现了ServeHTTP接口</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">router *router</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 是gee.Engine的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Engine&#123;router: newRouter()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路由和处理方法注册到映射表 *router* 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.router.addRoute(method, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET 定义添加GET请求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST 定义添加POST请求的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run 定义启动HTTP服务的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr <span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">c := newContext(w, req)</span><br><span class="line">engine.router.handle(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;gee&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gee.New()</span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">c.String(http.StatusOK, <span class="string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Query(<span class="string">&quot;name&quot;</span>), c.Path)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gee.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gee.H&#123;</span><br><span class="line"><span class="string">&quot;username&quot;</span>: c.PostForm(<span class="string">&quot;username&quot;</span>),</span><br><span class="line"><span class="string">&quot;password&quot;</span>: c.PostForm(<span class="string">&quot;password&quot;</span>),</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>将<code>router</code>相关的代码独立。</li><li>通过实现了 ServeHTTP 接口，接管了所有的 HTTP 请求。</li><li>在调用 router.handle 之前，构造了一个 Context 对象。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> GoWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-HTTP基础（实现一个GoWeb框架Gee）</title>
      <link href="/archives/5c07cf63.html"/>
      <url>/archives/5c07cf63.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要写这个项目"><a href="#为什么要写这个项目" class="headerlink" title="为什么要写这个项目"></a>为什么要写这个项目</h1><p>​        使用 Go 语言实现一个简单的 Web 框架，通过这个<a href="https://github.com/jpc901/Gee">项目</a>可以让我更好的去理解Go语言是如何实现一个简单的Web框架的。</p><p>​        当我们离开框架，使用基础库时，需要频繁手工处理的地方，就是框架的价值所在。但并不是每一个频繁处理的地方都适合在框架中完成。此时理解一个框架的特性是非常重要的，这也是我想要通过Go去实现一个框架的真正原因。</p><p><a href="https://github.com/jpc901/Gee">项目地址</a></p><h1 id="HTTP基础"><a href="#HTTP基础" class="headerlink" title="HTTP基础"></a>HTTP基础</h1><h2 id="一个简单的Web服务"><a href="#一个简单的Web服务" class="headerlink" title="一个简单的Web服务"></a>一个简单的Web服务</h2><p>Go语言内置了 <code>net/http</code>库，封装了HTTP网络编程的基础的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprintln(w, <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/&quot;</span>, index)</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="http-HandleFunc"><a href="#http-HandleFunc" class="headerlink" title="http.HandleFunc"></a><strong>http.HandleFunc</strong></h3><p><code>http.HandleFunc(&quot;/&quot;, index)</code>注册路径处理函数，这里将路径<code>/</code>的处理函数设置为<code>index</code>。</p><p>处理函数的类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br></pre></td></tr></table></figure><p><code>*http.Request</code>表示 HTTP 请求对象，该对象包含请求的所有信息，如 URL、首部、表单内容、请求的其他内容等。</p><p><code>http.ResponseWriter</code>是一个接口类型：（去看一看源码）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/http/server.go</span></span><br><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">  Header() Header</span><br><span class="line">  Write([]<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br><span class="line">  WriteHeader(statusCode <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于向客户端发送响应，实现了<code>ResponseWriter</code>接口的类型显然也实现了<code>io.Writer</code>接口。所以在处理函数<code>index</code>中，可以调用<code>fmt.Fprintln()</code>向<code>ResponseWriter</code>写入响应信息。</p><h3 id="http-ListenAndServe"><a href="#http-ListenAndServe" class="headerlink" title="http.ListenAndServe"></a><strong>http.ListenAndServe</strong></h3><p><code>http.ListenAndServe</code> 用以监听本地 9090 端口以提供服务。标准的 HTTP 端口是 80 端口，如 <code>baidu.com:80</code>，另一个 Web 常用是 HTTPS 的 443 端口，如 <code>baidu.com:443</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line"><span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看源码得知，http.ListenAndServe第二个参数是Handler类型，Handler需要实现ServeHTTP方法。所以我们需要传入一个<em>ServerHTTP</em> 接口的实例，就可以将HTTP请求传给这个实例处理。</p><h2 id="实现一个ServeHTTP"><a href="#实现一个ServeHTTP" class="headerlink" title="实现一个ServeHTTP"></a>实现一个ServeHTTP</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine is the uni handler for all requests</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line"><span class="keyword">switch</span> req.URL.Path &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/hello&quot;</span>:</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">engine := <span class="built_in">new</span>(Engine)</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, engine))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServeHTTP方法的两个参数</p><ul><li>Request包含了该HTTP请求的所有信息（请求地址、Header、Body等）</li><li>ResponseWriter可以构造针对该请求的响应</li></ul><p>LisrenAndServe方法的第二个参数传入了engine实例。engine这个实例拦截了所有的HTTP请求，有了统一的控制入口。我们就可以自定义路由映射规则，也可以统一添加一些处理逻辑，如日志、异常处理等。</p><h2 id="Gee框架雏形"><a href="#Gee框架雏形" class="headerlink" title="Gee框架雏形"></a>Gee框架雏形</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gee/</span><br><span class="line">  |--gee.go</span><br><span class="line">  |--go.mod</span><br><span class="line">main.go</span><br><span class="line">go.mod</span><br></pre></td></tr></table></figure><h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p>在 <code>go.mod</code> 中使用 <code>replace</code> 将 gee 指向 <code>./gee</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module demo01</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.18</span></span><br><span class="line"></span><br><span class="line">require gee v0<span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">replace gee =&gt; ./gee</span><br></pre></td></tr></table></figure><h3 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h3><p>main.go的内容和当初使用gin框架的时候感觉是一摸一样，因为gee设计参考了gin。</p><ol><li>使用New()创建gee实例（创建gin实例）</li><li>使用GET()方法添加路由。</li><li>使用Run()启动Web服务。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;gee&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gee.New()</span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;URL.Path = %q\n&quot;</span>, req.URL.Path)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Header[%q] = %q\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gee-go"><a href="#gee-go" class="headerlink" title="gee.go"></a>gee.go</h3><ul><li>gee.go通过Engine实现了ServeHTTP方法，解析请求路径，查找路由映射表<ul><li>若查找到就执行注册的处理方法</li><li>若没查找到返回404</li></ul></li><li>定义自定义类型HandlerFunc</li><li><code>router map[string]HandlerFunc</code>作为路由映射表</li><li>key是请求方法如：<code>GET-/</code>，<code>GET-/hello</code>，<code>POST-/hello</code>，value是映射处理的方法。</li><li><code>(*Engine).GET()</code>方法时，会将路由和处理方法注册到映射表 <em>router</em> 中。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerFunc defines the request handler used by gee</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Engine implement the interface of ServeHTTP</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">router <span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New is the constructor of gee.Engine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Engine&#123;router: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]HandlerFunc)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> addRoute(method <span class="type">string</span>, pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">key := method + <span class="string">&quot;-&quot;</span> + pattern</span><br><span class="line">engine.router[key] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET defines the method to add GET request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> GET(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// POST defines the method to add POST request</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> POST(pattern <span class="type">string</span>, handler HandlerFunc) &#123;</span><br><span class="line">engine.addRoute(<span class="string">&quot;POST&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run defines the method to start a http server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Run(addr <span class="type">string</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> http.ListenAndServe(addr, engine)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">key := req.Method + <span class="string">&quot;-&quot;</span> + req.URL.Path</span><br><span class="line"><span class="keyword">if</span> handler, ok := engine.router[key]; ok &#123;</span><br><span class="line">handler(w, req)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是Gee框架的原型。实现了路由映射表，提供了用户注册静态路由的方法，包装了服务启动函数。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> GoWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-gorm对象关系映射</title>
      <link href="/archives/eec3b437.html"/>
      <url>/archives/eec3b437.html</url>
      
        <content type="html"><![CDATA[<h1 id="gorm对象关系映射"><a href="#gorm对象关系映射" class="headerlink" title="gorm对象关系映射"></a>gorm对象关系映射</h1><h2 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h2><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129230754556.png" alt="image-20221129230754556"></p><h3 id="ORM优缺点"><a href="#ORM优缺点" class="headerlink" title="ORM优缺点"></a>ORM优缺点</h3><ul><li>优点<ul><li>提高开发效率</li></ul></li><li>缺点<ul><li>牺牲执行性能</li><li>牺牲灵活性</li><li>弱化SQL能力</li></ul></li></ul><h2 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h2><h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go get -u gorm.io/gorm</span><br><span class="line">go get -u gorm.io/driver/sqlite</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line">go get -u github.com/jinzhu/gorm</span><br><span class="line">go get -u github.com/go-sql-driver/mysql</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">  <span class="string">&quot;gorm.io/driver/sqlite&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo 用户信息</span></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="type">uint</span></span><br><span class="line">Name   <span class="type">string</span></span><br><span class="line">Gender <span class="type">string</span></span><br><span class="line">Hobby  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line">db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:password@(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动迁移（相当于创建数据库）</span></span><br><span class="line">db.AutoMigrate(&amp;UserInfo&#123;&#125;)</span><br><span class="line"></span><br><span class="line">u1 := UserInfo&#123;<span class="number">1</span>, <span class="string">&quot;贾小白&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;羽毛球&quot;</span>&#125;</span><br><span class="line">u2 := UserInfo&#123;<span class="number">0</span>, <span class="string">&quot;梅西&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;足球&quot;</span>&#125;</span><br><span class="line">u3 := UserInfo&#123;<span class="number">0</span>, <span class="string">&quot;c罗&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;足球&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 创建记录</span></span><br><span class="line">db.Create(&amp;u1)</span><br><span class="line">db.Create(&amp;u2)</span><br><span class="line">db.Create(&amp;u3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询第一个user</span></span><br><span class="line"><span class="keyword">var</span> u = <span class="built_in">new</span>(UserInfo)</span><br><span class="line">db.First(u)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;第一个user是: %v\n&quot;</span>, u)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uu UserInfo</span><br><span class="line">db.Find(&amp;uu, <span class="string">&quot;hobby=?&quot;</span>, <span class="string">&quot;足球&quot;</span>)</span><br><span class="line"><span class="comment">// 查找hobby是足球的user</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;查找hobby是足球的user: %v\n&quot;</span>, uu)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line">db.Model(&amp;u).Update(<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;蓝球&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;修改后第一个user：%v\n&quot;</span>, u)</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="comment">//db.Delete(&amp;u)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129195847490.png" alt="image-20221129195847490"></p><h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h2><h3 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h3><p>GORM 定义一个 <code>gorm.Model</code> 结构体，其包括字段 <code>ID</code>、<code>CreatedAt</code>、<code>UpdatedAt</code>、<code>DeletedAt</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gorm.Model 的定义</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span>           <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name         <span class="type">string</span></span><br><span class="line">  Age          sql.NullInt64</span><br><span class="line">  Birthday     *time.Time</span><br><span class="line">  Email        <span class="type">string</span>  <span class="string">`gorm:&quot;type:varchar(100);unique_index&quot;`</span></span><br><span class="line">  Role         <span class="type">string</span>  <span class="string">`gorm:&quot;size:255&quot;`</span> <span class="comment">// 设置字段大小为255</span></span><br><span class="line">  MemberNumber *<span class="type">string</span> <span class="string">`gorm:&quot;unique;not null&quot;`</span> <span class="comment">// 设置会员号（member number）唯一并且不为空</span></span><br><span class="line">  Num          <span class="type">int</span>     <span class="string">`gorm:&quot;AUTO_INCREMENT&quot;`</span> <span class="comment">// 设置 num 为自增类型</span></span><br><span class="line">  Address      <span class="type">string</span>  <span class="string">`gorm:&quot;index:addr&quot;`</span> <span class="comment">// 给address字段创建名为addr的索引</span></span><br><span class="line">  IgnoreMe     <span class="type">int</span>     <span class="string">`gorm:&quot;-&quot;`</span> <span class="comment">// 忽略本字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌入结构体"><a href="#嵌入结构体" class="headerlink" title="嵌入结构体"></a>嵌入结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span>           <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h3><p>声明 model 时，tag 是可选的，GORM 支持以下 tag： tag 名大小写不敏感，但建议使用 <code>camelCase</code> 风格</p><div class="table-container"><table><thead><tr><th style="text-align:left">标签名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">column</td><td style="text-align:left">指定 db 列名</td></tr><tr><td style="text-align:left">type</td><td style="text-align:left">列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td></tr><tr><td style="text-align:left">serializer</td><td style="text-align:left">指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td></tr><tr><td style="text-align:left">size</td><td style="text-align:left">定义列数据类型的大小或长度，例如 <code>size: 256</code></td></tr><tr><td style="text-align:left">primaryKey</td><td style="text-align:left">将列定义为主键</td></tr><tr><td style="text-align:left">unique</td><td style="text-align:left">将列定义为唯一键</td></tr><tr><td style="text-align:left">default</td><td style="text-align:left">定义列的默认值</td></tr><tr><td style="text-align:left">precision</td><td style="text-align:left">指定列的精度</td></tr><tr><td style="text-align:left">scale</td><td style="text-align:left">指定列大小</td></tr><tr><td style="text-align:left">not null</td><td style="text-align:left">指定列为 NOT NULL</td></tr><tr><td style="text-align:left">autoIncrement</td><td style="text-align:left">指定列为自动增长</td></tr><tr><td style="text-align:left">autoIncrementIncrement</td><td style="text-align:left">自动步长，控制连续记录之间的间隔</td></tr><tr><td style="text-align:left">embedded</td><td style="text-align:left">嵌套字段</td></tr><tr><td style="text-align:left">embeddedPrefix</td><td style="text-align:left">嵌入字段的列名前缀</td></tr><tr><td style="text-align:left">autoCreateTime</td><td style="text-align:left">创建时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>/<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoCreateTime:nano</code></td></tr><tr><td style="text-align:left">autoUpdateTime</td><td style="text-align:left">创建/更新时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>/<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoUpdateTime:milli</code></td></tr><tr><td style="text-align:left">index</td><td style="text-align:left">根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 <a href="https://gorm.io/zh_CN/docs/indexes.html">索引</a> 获取详情</td></tr><tr><td style="text-align:left">uniqueIndex</td><td style="text-align:left">与 <code>index</code> 相同，但创建的是唯一索引</td></tr><tr><td style="text-align:left">check</td><td style="text-align:left">创建检查约束，例如 <code>check:age &gt; 13</code>，查看 <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a> 获取详情</td></tr><tr><td style="text-align:left">&lt;-</td><td style="text-align:left">设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无写入权限、<code>&lt;-</code> 创建和更新权限</td></tr><tr><td style="text-align:left">-&gt;</td><td style="text-align:left">设置字段读的权限，<code>-&gt;:false</code> 无读权限</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td></tr><tr><td style="text-align:left">comment</td><td style="text-align:left">迁移时为字段添加注释</td></tr></tbody></table></div><h2 id="CRUD基础操作"><a href="#CRUD基础操作" class="headerlink" title="CRUD基础操作"></a>CRUD基础操作</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="检索单个对象"><a href="#检索单个对象" class="headerlink" title="检索单个对象"></a>检索单个对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">   _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo 用户信息</span></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">   ID     <span class="type">uint</span></span><br><span class="line">   Name   <span class="type">string</span></span><br><span class="line">   Gender <span class="type">string</span></span><br><span class="line">   Hobby  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 连接数据库</span></span><br><span class="line">   db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:password@(127.0.0.1:3306)/web2?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 自动迁移（相当于创建数据库）</span></span><br><span class="line">   db.AutoMigrate(&amp;UserInfo&#123;&#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 查询第一个user</span></span><br><span class="line">   <span class="keyword">var</span> u UserInfo</span><br><span class="line">   db.First(&amp;u)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;第一个user是: %v\n&quot;</span>, u)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> u2 UserInfo</span><br><span class="line">   db.Last(&amp;u2)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;最后一个user是: %v\n&quot;</span>, u2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>First</code> 和 <code>Last</code> 会根据主键排序，分别查询第一条和最后一条记录。</p><p>上面程序输出结果</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129201847122.png" alt="image-20221129201847122"></p><h4 id="根据主键检索"><a href="#根据主键检索" class="headerlink" title="根据主键检索"></a>根据主键检索</h4><p>如果主键是数字类型，您可以使用 <a href="https://gorm.io/zh_CN/docs/query.html#inline_conditions">内联条件</a> 来检索对象。 传入字符串参数时，需要特别注意 SQL 注入问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129202753373.png" alt="image-20221129202753373"></p><p>如果主键是字符串（例如像 uuid），查询将被写成这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;1b74413f-f3b8-409f-ac47-e8c062e3472a&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = &quot;1b74413f-f3b8-409f-ac47-e8c062e3472a&quot;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="检索全部对象"><a href="#检索全部对象" class="headerlink" title="检索全部对象"></a>检索全部对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get all records</span></span><br><span class="line">result := db.Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line">result.RowsAffected <span class="comment">// returns found records count, equals `len(users)`</span></span><br><span class="line">result.Error        <span class="comment">// returns error</span></span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129202753373.png" alt="image-20221129202854180"></p><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><p>String 条件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get first matched record</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all matched records</span></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name IN (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h4 id="保存所有字段"><a href="#保存所有字段" class="headerlink" title="保存所有字段"></a>保存所有字段</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存所有字段</span></span><br><span class="line"><span class="keyword">var</span> u UserInfo</span><br><span class="line">db.First(&amp;u)</span><br><span class="line">u.Name = <span class="string">&quot;jpc&quot;</span></span><br><span class="line">db.Save(&amp;u)</span><br><span class="line"><span class="comment">// UPDATE user_info SET name=&#x27;jpc&#x27; WHERE id=1</span></span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129204246740.png" alt="image-20221129204246740"></p><h4 id="更新单个列"><a href="#更新单个列" class="headerlink" title="更新单个列"></a>更新单个列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新单个列</span></span><br><span class="line">db.Model(&amp;UserInfo&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jpc&quot;</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;贾小白&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE user_info SET name=&#x27;贾小白&#x27; WHERE active=&#x27;jpc&#x27;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="更新多列"><a href="#更新多列" class="headerlink" title="更新多列"></a>更新多列</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新多个列</span></span><br><span class="line">db.Model(&amp;UserInfo&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;贾小白&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jpc&quot;</span>, <span class="string">&quot;hobby&quot;</span>: <span class="string">&quot;羽毛球&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE user_info SET name=&#x27;jpc&#x27;, hobby=&#x27;羽毛球&#x27; WHERE name=&quot;贾小白&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="根据主键删除"><a href="#根据主键删除" class="headerlink" title="根据主键删除"></a>根据主键删除</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> gin </tag>
            
            <tag> gorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-gin中间件</title>
      <link href="/archives/4533f4b0.html"/>
      <url>/archives/4533f4b0.html</url>
      
        <content type="html"><![CDATA[<h1 id="gin中间件"><a href="#gin中间件" class="headerlink" title="gin中间件"></a>gin中间件</h1><p>首先感谢<strong>七米老师</strong>的讲解：<a href="https://www.bilibili.com/video/BV1gJ411p7xC?p=18&amp;vd_source=44bd80a738e14b1c370a0a540eb6975f">视频地址</a>这个视频让我更加清晰的了解了gin中间件。</p><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p><h2 id="定义中间件"><a href="#定义中间件" class="headerlink" title="定义中间件"></a>定义中间件</h2><p>Gin中的中间件必须是一个<code>gin.HandlerFunc</code>类型。例如我们像下面的代码一样定义一个统计请求耗时的中间件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authMiddleware</span><span class="params">(doCheck <span class="type">bool</span>)</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> doCheck &#123;</span><br><span class="line"><span class="comment">// 存放具体的逻辑</span></span><br><span class="line"><span class="comment">// 是否登录的判断</span></span><br><span class="line"><span class="comment">// if 是用户登录</span></span><br><span class="line"><span class="comment">// c.Next()</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// c.Abort()</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.Abort()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h2><p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129142317272.png" alt="image-20221129142317272"></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129142332221.png" alt="image-20221129142332221"></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129142348794.png" alt="image-20221129142348794"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>: <span class="string">&quot;index&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m2 in ...&quot;</span>)</span><br><span class="line">c.Next() <span class="comment">// 调用后续的处理函数</span></span><br><span class="line"><span class="comment">//c.Abort() // 阻止调用后续的处理函数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;m2 out ...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;m1 in ...&quot;</span>)</span><br><span class="line">c.Next() <span class="comment">// 调用后续的处理函数</span></span><br><span class="line"><span class="comment">//c.Abort() // 阻止调用后续的处理函数</span></span><br><span class="line">fmt.Println(<span class="string">&quot;m1 out ...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, m1, m2, indexHandler)</span><br><span class="line"></span><br><span class="line">r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上程序运行结果为：</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129142506736.png" alt="image-20221129142506736"></p><h3 id="为全局路由注册"><a href="#为全局路由注册" class="headerlink" title="为全局路由注册"></a>为全局路由注册</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Use(m1, m2, authMiddleware(<span class="literal">true</span>)) <span class="comment">//全局注册中间件</span></span><br></pre></td></tr></table></figure><h3 id="为某个路由单独注册"><a href="#为某个路由单独注册" class="headerlink" title="为某个路由单独注册"></a>为某个路由单独注册</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给/test2路由单独注册中间件（可注册多个）</span></span><br><span class="line">r.GET(<span class="string">&quot;/test2&quot;</span>, StatCost(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">name := c.MustGet(<span class="string">&quot;name&quot;</span>).(<span class="type">string</span>) <span class="comment">// 从上下文取值</span></span><br><span class="line">log.Println(name)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="为路由组注册中间件"><a href="#为路由组注册中间件" class="headerlink" title="为路由组注册中间件"></a>为路由组注册中间件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>, StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">shopGroup.Use(StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-gin框架基础学习</title>
      <link href="/archives/c00a47ee.html"/>
      <url>/archives/c00a47ee.html</url>
      
        <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>配置代理和安装<a href="https://goproxy.io/zh/">gin包</a></p><ol><li>go env -w GO111MODULE=on</li><li>go env -w GOPROXY=<a href="https://goproxy.io,direct">https://goproxy.io,direct</a></li><li>安装 gin 包 go get -u github.com/gin-gonic/gin</li></ol><p>将 gin 引入到代码中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br></pre></td></tr></table></figure><p>第一个Gin程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">   <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">   r := gin.Default()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// GET请求方式；/hello:请求路径</span></span><br><span class="line">   <span class="comment">// 客户端请求/hello路径是，会执行后面的的匿名函数</span></span><br><span class="line">   r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">      <span class="comment">// c.JSON:返回JSON格式的数据</span></span><br><span class="line">      <span class="comment">// gin.H是一个map（type H map[string]any）</span></span><br><span class="line">      c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">         <span class="string">&quot;message&quot;</span>: <span class="string">&quot;hello world!&quot;</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 启动http服务，默认是8080端口</span></span><br><span class="line">   r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="html渲染"><a href="#html渲染" class="headerlink" title="html渲染"></a>html渲染</h1><ol><li><p>引入静态文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Static(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;./statics&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/static/index.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/static/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>解析模板文件（在此之前可以自定义模板函数）</p><p>Gin框架中使用<code>LoadHTMLGlob()</code>或者<code>LoadHTMLFiles()</code>方法进行HTML模板渲染。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析模板文件</span></span><br><span class="line">r.LoadHTMLFiles(<span class="string">&quot;templates/index.tmpl&quot;</span>)</span><br><span class="line">r.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>模板渲染</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板渲染</span></span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;posts/index.tmpl&quot;</span>, gin.H&#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;贾某某&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>一个栗子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个默认的路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"><span class="comment">// 调用r.Static()方法去引入静态文件</span></span><br><span class="line">r.Static(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;./statics&quot;</span>)</span><br><span class="line"><span class="comment">// 自定义模板函数</span></span><br><span class="line">r.SetFuncMap(template.FuncMap&#123;</span><br><span class="line"><span class="string">&quot;safe&quot;</span>: <span class="function"><span class="keyword">func</span><span class="params">(str <span class="type">string</span>)</span></span> template.HTML &#123;</span><br><span class="line"><span class="keyword">return</span> template.HTML(str)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析模板文件</span></span><br><span class="line"><span class="comment">//r.LoadHTMLFiles(&quot;templates/index.tmpl&quot;)</span></span><br><span class="line">r.LoadHTMLGlob(<span class="string">&quot;templates/**/*&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET请求方式；/hello:请求路径</span></span><br><span class="line"><span class="comment">// 客户端请求/hello路径是，会执行后面的的匿名函数</span></span><br><span class="line">r.GET(<span class="string">&quot;/posts/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// HTTP请求</span></span><br><span class="line"><span class="comment">// gin.H试一个map（type H map[string]any）</span></span><br><span class="line"><span class="comment">// 模板渲染</span></span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;posts/index.tmpl&quot;</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>: <span class="string">&quot;贾某某&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/users/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// HTTP请求</span></span><br><span class="line"><span class="comment">// gin.H试一个map（type H map[string]any）</span></span><br><span class="line"><span class="comment">// 模板渲染</span></span><br><span class="line">c.HTML(http.StatusOK, <span class="string">&quot;users/index.tmpl&quot;</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span>: <span class="string">&quot;&lt;a href=&#x27;https://jpcly.top&#x27;&gt;贾小白&lt;/a&gt;&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动http服务</span></span><br><span class="line">r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="gin框架返回JSON"><a href="#gin框架返回JSON" class="headerlink" title="gin框架返回JSON"></a>gin框架返回JSON</h1><p><code>gin.H&#123;&#125;</code>其实就是map，我们可以将数据封装成map然后再序列化发送给前端。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建默认路由引擎</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/aJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;hello world!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Gender <span class="type">string</span> <span class="string">`json:&quot;gender&quot;`</span></span><br><span class="line">Age    <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/bJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">data := User&#123;</span><br><span class="line">Name:   <span class="string">&quot;梅西&quot;</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">Age:    <span class="number">36</span>,</span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h1><h2 id="get获取url参数"><a href="#get获取url参数" class="headerlink" title="get获取url参数"></a>get获取url参数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    username := c.DefaultQuery(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;jpc&quot;</span>)</span><br><span class="line">    address := c.Query(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">        <span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129110858905.png" alt="image-20221129110858905"></p><h2 id="获取表单参数"><a href="#获取表单参数" class="headerlink" title="获取表单参数"></a>获取表单参数</h2><p><code>main.go</code>文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/index2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.HTML(http.StatusOK, <span class="string">&quot;index2.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2.post方法获取form参数</span></span><br><span class="line">r.POST(<span class="string">&quot;/index2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    password := c.PostForm(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>:      <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>index2.html</code>文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/index2&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>password:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129110741618.png" alt="image-20221129110741618"></p><h2 id="获取url路径参数"><a href="#获取url路径参数" class="headerlink" title="获取url路径参数"></a>获取url路径参数</h2><p><code>main.go</code>文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/user/:username/:address&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    username := c.Param(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">    address := c.Param(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">    <span class="comment">//输出json结果给调用方</span></span><br><span class="line">    c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">        <span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><p><code>ShouldBind()</code>能够基于请求自动提取<code>JSON</code>、<code>form表单</code>和<code>QueryString</code>类型的数据，并把值绑定到指定的结构体对象。</p><p>下面的例子是提取quertstring数据绑定到制定的结构体对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">   <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Binding from JSON</span></span><br><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">   User     <span class="type">string</span> <span class="string">`form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;`</span></span><br><span class="line">   Password <span class="type">string</span> <span class="string">`form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   router := gin.Default()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 绑定QueryString</span></span><br><span class="line">   router.GET(<span class="string">&quot;/loginForm&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">      <span class="keyword">var</span> login Login</span><br><span class="line">      <span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line">      <span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">         c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;user&quot;</span>:     login.User,</span><br><span class="line">            <span class="string">&quot;password&quot;</span>: login.Password,</span><br><span class="line">         &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   router.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221129111851787.png" alt="image-20221129111851787"></p><h1 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h1><p>HTTP 重定向很容易。 内部、外部重定向均支持。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Redirect(http.StatusMovedPermanently, <span class="string">&quot;http://www.google.com/&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>路由重定向，使用 <code>HandleContext</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.Request.URL.Path = <span class="string">&quot;/test2&quot;</span></span><br><span class="line">    r.HandleContext(c)</span><br><span class="line">&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/test2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="路由和路由组"><a href="#路由和路由组" class="headerlink" title="路由和路由组"></a>路由和路由组</h1><h2 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h2><p>404界面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    c.HTML(http.StatusNotFound, <span class="string">&quot;views/404.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此 handler 将匹配 /user/john 但不会匹配 /user/ 或者 /user</span></span><br><span class="line">    router.GET(<span class="string">&quot;/user/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        c.String(http.StatusOK, <span class="string">&quot;Hello %s&quot;</span>, name)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此 handler 将匹配 /user/john/ 和 /user/john/send</span></span><br><span class="line">    <span class="comment">// 如果没有其他路由匹配 /user/john，它将重定向到 /user/john/</span></span><br><span class="line">    router.GET(<span class="string">&quot;/user/:name/*action&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        action := c.Param(<span class="string">&quot;action&quot;</span>)</span><br><span class="line">        message := name + <span class="string">&quot; is &quot;</span> + action</span><br><span class="line">        c.String(http.StatusOK, message)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的路由组: v1</span></span><br><span class="line">    v1 := router.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.POST(<span class="string">&quot;/login&quot;</span>, loginEndpoint)</span><br><span class="line">        v1.POST(<span class="string">&quot;/submit&quot;</span>, submitEndpoint)</span><br><span class="line">        v1.POST(<span class="string">&quot;/read&quot;</span>, readEndpoint)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单的路由组: v2</span></span><br><span class="line">    v2 := router.Group(<span class="string">&quot;/v2&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v2.POST(<span class="string">&quot;/login&quot;</span>, loginEndpoint)</span><br><span class="line">        v2.POST(<span class="string">&quot;/submit&quot;</span>, submitEndpoint)</span><br><span class="line">        v2.POST(<span class="string">&quot;/read&quot;</span>, readEndpoint)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-模板(gin框架学习前置)</title>
      <link href="/archives/2aa5a355.html"/>
      <url>/archives/2aa5a355.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板template"><a href="#模板template" class="headerlink" title="模板template"></a>模板template</h1><h2 id="模板基础"><a href="#模板基础" class="headerlink" title="模板基础"></a>模板基础</h2><p><code>html/template</code>包实现了数据驱动的模板，用于生成可防止代码注入的安全的HTML内容。它提供了和<code>text/template</code>包相同的接口，Go语言中输出HTML的场景都应使用<code>html/template</code>这个包。</p><ol><li>模板文件通常定义为<code>.tmpl</code>和<code>.tpl</code>为后缀（也可以使用其他的后缀），必须使用<code>UTF8</code>编码。</li><li>模板文件中使用<code>&#123;&#123;`和`&#125;&#125;</code>包裹和标识需要传入的数据。</li><li>传给模板这样的数据就可以通过点号（<code>.</code>）来访问，如果数据是复杂类型的数据，可以通过{ { .FieldName }}来访问它的字段。</li><li>除<code>&#123;&#123;`和`&#125;&#125;</code>包裹的内容外，其他内容均不做修改原样输出。</li></ol><h3 id="模板使用三部曲"><a href="#模板使用三部曲" class="headerlink" title="模板使用三部曲"></a>模板使用三部曲</h3><ol><li><p>定义模板</p></li><li><p>解析模板</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFiles</span><span class="params">(filenames ...<span class="type">string</span>)</span></span> (*Template, <span class="type">error</span>)</span><br></pre></td></tr></table></figure></li><li><p>渲染模板</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Template)</span></span> Execute(wr io.Writer, data <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="一个小栗子"><a href="#一个小栗子" class="headerlink" title="一个小栗子"></a>一个小栗子</h3><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="type">string</span></span><br><span class="line">Gender <span class="type">string</span></span><br><span class="line">Age    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1.解析指定文件生成模板对象</span></span><br><span class="line">tmpl, err := template.ParseFiles(<span class="string">&quot;./hello.tmpl&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;create template failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.利用给定数据渲染模板，并将结果写入w</span></span><br><span class="line"></span><br><span class="line">u1 := User&#123;</span><br><span class="line">Name:   <span class="string">&quot;梅西&quot;</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">Age:    <span class="number">36</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">mp[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;c罗&quot;</span></span><br><span class="line">mp[<span class="string">&quot;gender&quot;</span>] = <span class="string">&quot;男&quot;</span></span><br><span class="line">mp[<span class="string">&quot;age&quot;</span>] = <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个slice</span></span><br><span class="line">arr := []<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;足球&quot;</span>, <span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;羽毛球&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传出数据并且渲染数据（用map封装起来）</span></span><br><span class="line">err = tmpl.Execute(w, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">&quot;u1&quot;</span>:  u1,</span><br><span class="line"><span class="string">&quot;mp&quot;</span>:  mp,</span><br><span class="line"><span class="string">&quot;arr&quot;</span>: arr,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;传递参数出错,err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, sayHello)</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;HTTP server failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>hello.tmpl文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; .u1.Name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; .u1.Gender &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; .u1.Age &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; .mp.name &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; .mp.gender &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;&#123; .mp.age &#125;&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &#123;&#123; range $idx,$hobby := .arr &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;$idx&#125;&#125; - &#123;&#123;$hobby&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123; end &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221128153347586.png" alt="image-20221128153347586"></p><h3 id="基础模板语法"><a href="#基础模板语法" class="headerlink" title="基础模板语法"></a>基础模板语法</h3><ul><li><p>注释:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="comment">/* a comment */</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>pipeline：管道<code>|</code></p></li><li><p>变量：<code>$obj := &#123;&#123;.&#125;&#125;</code></p></li><li><p>移除空格：<code>&#123;&#123;- .Name -&#125;&#125;</code></p></li><li><p>条件判断:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="keyword">if</span> ...&#125;&#125;</span><br><span class="line">&#123;&#123;<span class="keyword">else</span> <span class="keyword">if</span> ...&#125;&#125;</span><br><span class="line">&#123;&#123;<span class="keyword">else</span>&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>range:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;rang ...&#125;&#125;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>比较函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eq      如果arg1 == arg2则返回真</span><br><span class="line">ne      如果arg1 != arg2则返回真</span><br><span class="line">lt      如果arg1 &lt; arg2则返回真</span><br><span class="line">le      如果arg1 &lt;= arg2则返回真</span><br><span class="line">gt      如果arg1 &gt; arg2则返回真</span><br><span class="line">ge      如果arg1 &gt;= arg2则返回真</span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line">&#123;&#123;eq arg1 arg2&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="模板嵌套"><a href="#模板嵌套" class="headerlink" title="模板嵌套"></a>模板嵌套</h2><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;html/template&quot;</span></span><br><span class="line">   <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">   <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name   <span class="type">string</span></span><br><span class="line">   Gender <span class="type">string</span></span><br><span class="line">   Age    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   fByte, err := ioutil.ReadFile(<span class="string">&quot;./f.tmpl&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;read html failed, err:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 自定义一个模板函数</span></span><br><span class="line">   fun1 := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arg + <span class="string">&quot;是球王&quot;</span>, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 采用链式操作在Parse之前嗲用Funcs添加自定义函数</span></span><br><span class="line">   tmpl, err := template.New(<span class="string">&quot;f&quot;</span>).</span><br><span class="line">      Funcs(template.FuncMap&#123;<span class="string">&quot;fun1&quot;</span>: fun1&#125;).</span><br><span class="line">      Parse(<span class="type">string</span>(fByte))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;create template failed, err:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   user := User&#123;</span><br><span class="line">      Name:   <span class="string">&quot;梅西&quot;</span>,</span><br><span class="line">      Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">      Age:    <span class="number">35</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用user渲染模板，并将结果写入w</span></span><br><span class="line">   tmpl.Execute(w, user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   http.HandleFunc(<span class="string">&quot;/&quot;</span>, f)</span><br><span class="line">   err := http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;failed err:&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;fun1 .Name&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221128153142088.png" alt="image-20221128153142088"></p><h3 id="嵌套模板"><a href="#嵌套模板" class="headerlink" title="嵌套模板"></a>嵌套模板</h3><p>我们可以在template中嵌套其他的template。这个template可以是单独的文件，也可以是通过<code>define</code>定义的template。</p><p><code>f.tmpl</code>文件内容如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>tmpl test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试嵌套template语法<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    &#123;&#123;template &quot;ul.tmpl&quot;&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    &#123;&#123;template &quot;ol.tmpl&quot;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;&#123; define &quot;ol.tmpl&quot;&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>吃饭<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>睡觉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>打豆豆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure><p><code>ul.tmpl</code>文件内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>注释<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>日志<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main.go文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name   <span class="type">string</span></span><br><span class="line">Gender <span class="type">string</span></span><br><span class="line">Age    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">tmpl, err := template.ParseFiles(<span class="string">&quot;./f.tmpl&quot;</span>, <span class="string">&quot;./ul.tmpl&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;create failed, err :&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">user := User&#123;</span><br><span class="line">Name:   <span class="string">&quot;梅西&quot;</span>,</span><br><span class="line">Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">Age:    <span class="number">36</span>,</span><br><span class="line">&#125;</span><br><span class="line">tmpl.Execute(w, user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/tmpl&quot;</span>, fun1)</span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Http server failed,  err:&quot;</span>, err);</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221128154740137.png" alt="image-20221128154740137"></p><h2 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h2><p>block: <code>block</code>是定义模板<code>&#123;&#123;define "name"&#125;&#125; T1 &#123;&#123;end&#125;&#125;</code>和执行<code>&#123;&#123;template "name" pipeline&#125;&#125;</code>缩写，典型的用法是定义一组根模板，然后通过在其中重新定义块模板进行自定义。</p><ol><li><p>定义根模板base.tmpl</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Go Templates<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>模板继承<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;block &quot;content&quot; . &#125;&#125;&#123;&#123;end&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义一个<code>home.tmpl</code>继承<code>base.tmpl</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;template <span class="string">&quot;base.tmpl&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;define <span class="string">&quot;content&quot;</span>&#125;&#125;</span><br><span class="line">    &lt;div&gt;Hello world!&lt;/div&gt;</span><br><span class="line">&#123;&#123;end&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析模板和渲染模板</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">home</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">tmpl, err := template.ParseGlob(<span class="string">&quot;templates/*.tmpl&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;create failed err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err = tmpl.ExecuteTemplate(w, <span class="string">&quot;home.tmpl&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;render template failed, err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14-静态类型与动态类型(go基础)</title>
      <link href="/archives/4ebf629.html"/>
      <url>/archives/4ebf629.html</url>
      
        <content type="html"><![CDATA[<h1 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h1><h2 id="静态类型-static-type"><a href="#静态类型-static-type" class="headerlink" title="静态类型(static type)"></a>静态类型(static type)</h2><p><strong>静态类型</strong>就是变量声明时候的类型。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 是静态类型</span></span><br><span class="line"><span class="keyword">var</span> n <span class="type">int</span></span><br></pre></td></tr></table></figure><h2 id="动态类型-concrete-type"><a href="#动态类型-concrete-type" class="headerlink" title="动态类型(concrete type)"></a>动态类型(concrete type)</h2><p><strong>动态类型</strong>是程序运行时系统才能看见的类型。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in 的静态类型为 interface&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">// in 的静态类型为 interface&#123;&#125; 动态类型为 int</span></span><br><span class="line">in = <span class="number">100</span></span><br><span class="line"><span class="comment">// in 的静态类型为 interface&#123;&#125; 动态类型为 string</span></span><br><span class="line">in = <span class="string">&quot;jpc&quot;</span></span><br></pre></td></tr></table></figure><p>​    我们定义了一个空接口 <code>in</code> ，它的静态类型永远是 <code>interface&#123;&#125;</code> ，但它可以接受任何类型，接受整型数据时，它的动态类型就为 <code>int</code> ；接受字符串型数据时，它的动态类型就变为 <code>string</code> 。</p><h2 id="接口组成"><a href="#接口组成" class="headerlink" title="接口组成"></a>接口组成</h2><p>每个接口变量实际上都是由一 <code>pair</code> 对组成，其中记录了实际变量的值和类型。</p><p>这里声明了一个类型为 <code>int</code> 的变量，变量名叫 <code>number</code> 值为 <code>100</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    number := (<span class="type">int</span>)(<span class="number">100</span>)</span><br><span class="line">    <span class="comment">// 或者写成 number := (interface&#123;&#125;)(100)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;number type: %T, data: %v&quot;</span>, number, number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出number type: int, data: 100</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-错误与异常(go基础)</title>
      <link href="/archives/8887c6d6.html"/>
      <url>/archives/8887c6d6.html</url>
      
        <content type="html"><![CDATA[<h1 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h1><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p><p>error类型是一个接口类型，这是它的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>error</code> 有了一个签名为 <code>Error() string</code> 的方法。所有实现该接口的类型都可以当作一个错误类型。<code>Error()</code> 方法给出了错误的描述。<code>fmt.Println</code> 在打印错误时，会在内部调用 <code>Error() string</code> 方法来得到该错误的描述。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 尝试打开文件</span></span><br><span class="line">    file, err := os.Open(<span class="string">&quot;/a.txt&quot;</span>)</span><br><span class="line">    <span class="comment">// 如果打开文件时发生错误 返回一个不等于 nil 的错误</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果打开文件成功 返回一个文件句柄 和 一个值为 nil 的错误</span></span><br><span class="line">    fmt.Println(file.Name(), <span class="string">&quot;opened successfully&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里没有存在一个文件 <code>a.txt</code> ，所以尝试打开文件将会返回一个不等于 <code>nil</code> 的错误。</p><h3 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;计算错误, 长度或宽度，不能小于0.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a * b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">100</span></span><br><span class="line">    b := <span class="number">-10</span></span><br><span class="line">    r, err := area(a, b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area =&quot;</span>, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算错误, 长度或宽度，不能小于0.</span></span><br></pre></td></tr></table></figure><h3 id="给错误添加更多信息"><a href="#给错误添加更多信息" class="headerlink" title="给错误添加更多信息"></a>给错误添加更多信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;计算错误, 长度%d或宽度%d，不能小于0&quot;</span>, a, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a * b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">100</span></span><br><span class="line">    b := <span class="number">-10</span></span><br><span class="line">    area, err := area(a, b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area =&quot;</span>, area)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算错误, 长度100或宽度-10，不能小于0</span></span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>错误和异常是两个不同的概念，非常容易混淆。错误指的是可能出现问题的地方出现了问题；而异常指的是不应该出现问题的地方出现了问题。</p><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><p>在有些情况，当程序发生异常时，无法继续运行。在这种情况下，我们会使用 <code>panic</code> 来终止程序。当函数发生 <code>panic</code> 时，它会终止运行，在执行完所有的延迟函数后，程序返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 <code>panic</code> 信息，接着打印出堆栈跟踪，最后程序终止。</p><p>我们应该尽可能地使用错误，而不是使用 <code>panic</code> 和 <code>recover</code> 。只有当程序不能继续运行的时候，才应该使用 <code>panic</code> 和 <code>recover</code> 机制。</p><p><code>panic</code> 有两个合理的用例：</p><ul><li>发生了一个不能恢复的错误，此时程序不能继续运行。一个例子就是 web 服务器无法绑定所要求的端口。在这种情况下，就应该使用 <code>panic</code> ，因为如果不能绑定端口，啥也做不了。</li><li>发生了一个编程上的错误。假如我们有一个接收指针参数的方法，而其他人使用 <code>nil</code> 作为参数调用了它。在这种情况下，我们可以使用 <code>panic</code> ，因为这是一个编程错误：用 <code>nil</code> 参数调用了一个只能接收合法指针的方法。</li></ul><h3 id="触发-panic"><a href="#触发-panic" class="headerlink" title="触发 panic"></a>触发 panic</h3><p>下面是内建函数 <code>panic</code> 的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><p>当程序终止时，会打印传入 <code>panic</code> 的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出传入 panic 函数的信息，并打印出堆栈跟踪：</span></span><br><span class="line"><span class="comment">//panic: panic error</span></span><br></pre></td></tr></table></figure><h3 id="发生-panic-时的-defer"><a href="#发生-panic-时的-defer" class="headerlink" title="发生 panic 时的 defer"></a>发生 panic 时的 defer</h3><p>上面已经提到了，当函数发生 <code>panic</code> 时，它会终止运行，在执行完所有的延迟函数后，程序返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 <code>panic</code> 信息，接着打印出堆栈跟踪，最后程序终止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer myTest&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panic myTest&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer main&quot;</span>)</span><br><span class="line">    myTest()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">defer myTest</span></span><br><span class="line"><span class="comment">defer main</span></span><br><span class="line"><span class="comment">panic: panic myTest</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><p><code>recover</code> 是一个内建函数，用于重新获得 <code>panic</code> 协程的控制。下面是内建函数 <code>recover</code> 的签名：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>recover</code> 必须在 <code>defer</code> 函数中才能生效，在其他作用域下，它是不工作的。在延迟函数内调用 <code>recover</code> ，可以取到 <code>panic</code> 的错误信息，并且停止 <code>panic</code> 续发事件，程序运行恢复正常。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outOfArray</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// recover() 可以将捕获到的 panic 信息打印</span></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> array [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    array[x] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 故意制造数组越界 触发 panic</span></span><br><span class="line">    outOfArray(<span class="number">20</span>)</span><br><span class="line">    <span class="comment">// 如果能执行到这句 说明 panic 被捕获了</span></span><br><span class="line">    <span class="comment">// 后续的程序能继续运行</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-线程同步(go基础)</title>
      <link href="/archives/2b7fbed4.html"/>
      <url>/archives/2b7fbed4.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>在 Go 语言中，经常会遇到并发的问题，当然我们会优先考虑使用通道，同时 Go 语言也给出了传统的解决方式 <strong>Mutex(互斥锁)</strong> 和 <strong>RWMutex(读写锁)</strong> 来处理竞争条件。</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>​    首先我们要理解并发编程中临界区的概念。当程序并发地运行时，多个 Go 协程不应该同时访问那些修改共享资源的代码。这些修改共享资源的代码称为<strong>临界区</strong> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bank <span class="keyword">struct</span> &#123;</span><br><span class="line">   balance <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bank)</span></span> Deposit(amount <span class="type">int</span>) &#123;</span><br><span class="line">   b.balance += amount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bank)</span></span> Balance() <span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> b.balance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   b := &amp;Bank&#123;&#125;</span><br><span class="line"></span><br><span class="line">   n := <span class="number">1000</span></span><br><span class="line">   wg.Add(n)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         b.Deposit(<span class="number">1000</span>)</span><br><span class="line">         wg.Done()</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line">   wg.Wait()</span><br><span class="line">   fmt.Println(b.Balance()) <span class="comment">//969000,990000,941000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当然，对于只有一个协程的程序来说，上面的代码没有任何问题。但是，如果有多个协程并发运行时，就会发生错误，这种情况就称之为<strong>数据竞争</strong>(data race)。使用下面的互斥锁 <code>Mutex</code> 就能避免这种情况的发生。</p><h2 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h2><p><strong>互斥锁(Mutex，mutual exclusion)</strong> 用于提供一种 <strong>加锁机制(Locking Mechanism)</strong> ，可确保在某时刻只有一个协程在临界区运行，以防止出现竞争。也是为了来保护一个资源不会因为并发操作而引起冲突导致数据不准确。</p><p><code>Mutex</code> 有两个方法，分别是 <code>Lock()</code> 和 <code>Unlock()</code> ，即对应的加锁和解锁。在 <code>Lock()</code> 和 <code>Unlock()</code> 之间的代码，都只能由一个协程执行，就能避免竞争条件。</p><p>如果有一个协程已经持有了<strong>锁(Lock)</strong>，当其他协程试图获得该锁时，这些协程会被阻塞，直到<code>Mutex</code>解除锁定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bank <span class="keyword">struct</span> &#123;</span><br><span class="line">balance <span class="type">int</span></span><br><span class="line">m       sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bank)</span></span> Deposit(amount <span class="type">int</span>) &#123;</span><br><span class="line">b.m.Lock()</span><br><span class="line">b.balance += amount</span><br><span class="line">b.m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bank)</span></span> Balance() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> b.balance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">b := &amp;Bank&#123;&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="number">1000</span></span><br><span class="line">wg.Add(n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">b.Deposit(<span class="number">1000</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(b.Balance()) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出1000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关键代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bank <span class="keyword">struct</span> &#123;</span><br><span class="line">balance <span class="type">int</span></span><br><span class="line">m       sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bank)</span></span> Deposit(amount <span class="type">int</span>) &#123;</span><br><span class="line">b.m.Lock()</span><br><span class="line">b.balance += amount</span><br><span class="line">b.m.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        注意同一协程里不要在尚未解锁时再次加锁，也不要对已经解锁的锁再次解锁。当然，使用通道也可以处理竞争条件。</p><h2 id="读写锁-RWMutex"><a href="#读写锁-RWMutex" class="headerlink" title="读写锁 RWMutex"></a>读写锁 RWMutex</h2><p><code>sync.RWMutex</code> 类型实现读写互斥锁，适用于读多写少的场景，它规定了当有人还在读取数据（即读锁占用）时，不允许有人更新这个数据（即写锁会阻塞）；为了保证程序的效率，多个人（协程）读取数据（拥有读锁）时，互不影响不会造成阻塞，它不会像 <code>Mutex</code> 那样只允许有一个人（协程）读取同一个数据。<strong>读锁与读锁兼容，读锁与写锁互斥，写锁与写锁互斥。</strong></p><ul><li>可以同时申请多个读锁。</li><li>有读锁时申请写锁将阻塞，有写锁时申请读锁将阻塞。</li><li>只要有写锁，后续申请读锁和写锁都将阻塞。</li></ul><p>定义一个 <strong>RWMuteux</strong> 读写锁：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rwMutex sync.RWMutex</span><br></pre></td></tr></table></figure><p><strong>RWMutex</strong> 里提供了两种锁，每种锁分别对应两个方法，为了避免死锁，两个方法应成对出现，必要时请使用 <code>defer</code> 。</p><ul><li>读锁：调用 <code>RLock</code> 方法开启锁，调用 <code>RUnlock</code> 释放锁；</li><li>写锁：调用 <code>Lock</code> 方法开启锁，调用 <code>Unlock</code> 释放锁。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bank <span class="keyword">struct</span> &#123;</span><br><span class="line">balance <span class="type">int</span></span><br><span class="line">rwMutex sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bank)</span></span> Deposit(amount <span class="type">int</span>) &#123;</span><br><span class="line">b.rwMutex.Lock() <span class="comment">// write lock</span></span><br><span class="line">b.balance += amount</span><br><span class="line">b.rwMutex.Unlock() <span class="comment">// write unlock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bank)</span></span> Balance() (balance <span class="type">int</span>) &#123;</span><br><span class="line">b.rwMutex.RLock() <span class="comment">// read lock</span></span><br><span class="line">balance = b.balance</span><br><span class="line">b.rwMutex.RUnlock() <span class="comment">// read unlock</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">b := &amp;Bank&#123;&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="number">1000</span></span><br><span class="line">wg.Add(n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">b.Deposit(<span class="number">1000</span>)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(b.Balance()) </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="条件变量-sync-Cond"><a href="#条件变量-sync-Cond" class="headerlink" title="条件变量 sync.Cond"></a>条件变量 sync.Cond</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>​    与互斥量不同，条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。<strong>条件变量总是与互斥量组合使用</strong>。<strong>互斥量为共享数据的访问提供互斥支持，而条件变量可以就共享数据的状态的变化向相关线程发出通知。</strong></p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">cond := sync.NewCond(lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">cond := sync.NewCond(<span class="built_in">new</span>(sync.Mutex))</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>​    Cond 实现了一个条件变量，在 Locker 的基础上增加的一个消息通知的功能，保存了一个通知列表，用来唤醒一个或所有因等待条件变量而阻塞的 Go 程，以此来实现多个 Go 程间的同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个带锁的条件变量，Locker 通常是一个 *Mutex 或 *RWMutex</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒所有因等待条件变量 c 阻塞的 goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒一个因等待条件变量 c 阻塞的 goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 c.L 解锁并挂起 goroutine，在稍后恢复执行后，Wait 返回前锁定 c.L，</span></span><br><span class="line"><span class="comment">// 只有当被 Broadcast 和 Signal 唤醒，Wait 才能返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait()</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/signal&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(name <span class="type">string</span>, s []<span class="type">string</span>, c *sync.Cond)</span></span> &#123;</span><br><span class="line">c.L.Lock()</span><br><span class="line">c.Wait()</span><br><span class="line">fmt.Println(name, <span class="string">&quot;姓名：&quot;</span>, s)</span><br><span class="line">c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(event <span class="type">string</span>, c *sync.Cond)</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">c.L.Lock()</span><br><span class="line">fmt.Println(event)</span><br><span class="line">c.Broadcast()</span><br><span class="line">c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := []<span class="type">string</span>&#123;<span class="string">&quot;张三&quot;</span>&#125;</span><br><span class="line">s2 := []<span class="type">string</span>&#123;<span class="string">&quot;赵四&quot;</span>&#125;</span><br><span class="line">s3 := []<span class="type">string</span>&#123;<span class="string">&quot;刘能&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个带锁的条件变量， Locker通常是Mutex或者RWMutex</span></span><br><span class="line">cond := sync.NewCond(&amp;m)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Broadcast 唤醒所有因等待条件变量c阻塞的goroutine</span></span><br><span class="line"><span class="comment">Signal 唤醒所有因等待条件变量c阻塞的goroutine</span></span><br><span class="line"><span class="comment">Wait 等待c.L解锁并且挂起goroutine, 在稍后恢复执行后， Wait返回锁定c.L, 只有当被Broadcast或者Signal唤醒， wait才返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// listener 1</span></span><br><span class="line"><span class="keyword">go</span> listen(<span class="string">&quot;室友1&quot;</span>, s1, cond)</span><br><span class="line"><span class="keyword">go</span> listen(<span class="string">&quot;室友2&quot;</span>, s2, cond)</span><br><span class="line"><span class="keyword">go</span> listen(<span class="string">&quot;室友3&quot;</span>, s3, cond)</span><br><span class="line"><span class="keyword">go</span> broadcast(<span class="string">&quot;唤醒:&quot;</span>, cond)</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(ch, os.Interrupt)</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="channel和sync区别"><a href="#channel和sync区别" class="headerlink" title="channel和sync区别"></a><strong>channel和sync区别</strong></h3><p>一般并发就是指多个程序逻辑上同时运行，但肯定会遇到一些非线程安全的东西需要做同步（无法并行，只能串行），这个时候就有sync和channel2种方式实现同步。只不过channel除了做同步，还能用于传递变量（即通过通信来共享变量），而sync只有同步作用（通过共享变量来通信）</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-Select(go基础)</title>
      <link href="/archives/ccd2c60a.html"/>
      <url>/archives/ccd2c60a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h1><p><strong>select</strong> 语句用在多个发送/接收通道操作中进行选择。</p><ul><li><p><code>select</code> 语句会一直阻塞，直到发送/接收操作准备就绪。</p></li><li><p>如果有多个通道操作准备完毕， <code>select</code> 会随机地选取其中之一执行。</p></li></ul><p>例子：</p><p>程序创建了 3 个通道，并在执行 <code>select</code> 语句之前往通道 1 、通道 2 和 通道 3 分别发送数据，在执行 <code>select</code> 语句时，如果有机会的话会运行所有表达式，只要其中一个通道接收到数据，那么就会执行对应的 <code>case</code> 代码，然后退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建三个通道</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往通道发送数据</span></span><br><span class="line">ch1 &lt;- <span class="string">&quot;111&quot;</span></span><br><span class="line">ch2 &lt;- <span class="string">&quot;222&quot;</span></span><br><span class="line">ch3 &lt;- <span class="string">&quot;333&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">fmt.Println(<span class="string">&quot;ch1 received: &quot;</span>, msg1)</span><br><span class="line"><span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">fmt.Println(<span class="string">&quot;ch2 received: &quot;</span>, msg2)</span><br><span class="line"><span class="keyword">case</span> msg3 := &lt;-ch3:</span><br><span class="line">fmt.Println(<span class="string">&quot;ch3 received: &quot;</span>, msg3)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="select-的应用"><a href="#select-的应用" class="headerlink" title="select 的应用"></a>select 的应用</h2><p>每个任务执行的时间不同，使用 <code>select</code> 语句等待相应的通道发出响应。<code>select</code> 会选择首先响应先完成的 task，而忽略其它的响应。使用这种方法，我们可以做多个 task，并给用户返回最快的 task 结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    ch &lt;- <span class="string">&quot;111&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task2</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">7</span> * time.Second)</span><br><span class="line">    ch &lt;- <span class="string">&quot;222&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task3</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    ch &lt;- <span class="string">&quot;333&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建两个通道</span></span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> task1(ch1)</span><br><span class="line">    <span class="keyword">go</span> task2(ch2)</span><br><span class="line">    <span class="keyword">go</span> task3(ch3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="comment">// 如果从通道 1 收到数据</span></span><br><span class="line">        <span class="keyword">case</span> message1 := &lt;-ch1:</span><br><span class="line">            fmt.Println(<span class="string">&quot;ch1 received:&quot;</span>, message1)</span><br><span class="line">        <span class="comment">// 如果从通道 2 收到数据</span></span><br><span class="line">        <span class="keyword">case</span> message2 := &lt;-ch2:</span><br><span class="line">            fmt.Println(<span class="string">&quot;ch2 received:&quot;</span>, message2)</span><br><span class="line">        <span class="comment">// 如果从通道 3 收到数据</span></span><br><span class="line">        <span class="keyword">case</span> message3 := &lt;-ch3:</span><br><span class="line">            fmt.Println(<span class="string">&quot;ch3 received:&quot;</span>, message3)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为如果加了该默认分支，如果还没从通道接收到数据， <code>select</code> 语句就会直接执行 <code>default</code> 分支然后退出，而不是被阻塞。</p><p>当 <code>select</code> 由多个 <code>case</code> 准备就绪时，将会随机地选取其中之一去执行。</p><h2 id="select-超时处理"><a href="#select-超时处理" class="headerlink" title="select 超时处理"></a>select 超时处理</h2><p>当 <code>case</code> 里的通道始终没有接收到数据时，而且也没有 <code>default</code> 语句时， <code>select</code> 整体就会阻塞，但是有时我们并不希望 <code>select</code> 一直阻塞下去，这时候就可以手动设置一个超时时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeTimeout</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">bool</span>, t <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second * time.Duration(t))</span><br><span class="line">    ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    c3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    timeout := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> makeTimeout(timeout, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg1 := &lt;-c1:</span><br><span class="line">        fmt.Println(<span class="string">&quot;c1 received: &quot;</span>, msg1)</span><br><span class="line">    <span class="keyword">case</span> msg2 := &lt;-c2:</span><br><span class="line">        fmt.Println(<span class="string">&quot;c2 received: &quot;</span>, msg2)</span><br><span class="line">    <span class="keyword">case</span> msg3 := &lt;-c3:</span><br><span class="line">        fmt.Println(<span class="string">&quot;c3 received: &quot;</span>, msg3)</span><br><span class="line">    <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Timeout, exit.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取-写入数据"><a href="#读取-写入数据" class="headerlink" title="读取/写入数据"></a>读取/写入数据</h2><p><code>select</code> 里的 <code>case</code> 表达式只能对通道进行操作，不管你是往通道写入数据，还是从通道读出数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    c1 &lt;- <span class="string">&quot;111&quot;</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> c1 &lt;- <span class="string">&quot;222&quot;</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;c1 received: &quot;</span>, &lt;-c1)</span><br><span class="line">        fmt.Println(<span class="string">&quot;c1 received: &quot;</span>, &lt;-c1)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;channel blocking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-协程和通道(go基础)</title>
      <link href="/archives/4c33ecfb.html"/>
      <url>/archives/4c33ecfb.html</url>
      
        <content type="html"><![CDATA[<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p><strong>Go 语言的 协程(Groutine)</strong> 是与其他函数或方法一起并发运行的工作方式。协程可以看作是轻量级线程。与线程相比，创建一个协程的成本很小。因此在 Go 应用中，常常会看到会有很多协程并发地运行。</p><h2 id="启动一个协程"><a href="#启动一个协程" class="headerlink" title="启动一个协程"></a>启动一个协程</h2><p>主函数运行在一个特殊的协程上，这个协程称之为 <strong>主协程(Main Goroutine)</strong> 。</p><p>启动一个新的协程时，协程的调用会立即返回。与函数不同，程序控制不会去等待 Go 协程执行完毕。在调用 Go 协程之后，程序控制会立即返回到代码的下一行，忽略该协程的任何返回值。如果 Go 主协程终止，则程序终止，于是其他 Go 协程也会终止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;另一个协程&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">go</span> fun()</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;主协程&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动多个-Go-协程"><a href="#启动多个-Go-协程" class="headerlink" title="启动多个 Go 协程"></a>启动多个 Go 协程</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintNum</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Println(num)</span><br><span class="line"><span class="comment">// 避免观察不到并发效果 加个休眠</span></span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 开启 1 号协程</span></span><br><span class="line"><span class="keyword">go</span> PrintNum(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 开启 2 号协程</span></span><br><span class="line"><span class="keyword">go</span> PrintNum(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 使主协程休眠 1 秒</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p><strong>通道(channel)</strong> ，就是一个管道，可以想像成 Go 协程之间通信的管道。它是一种队列式的数据结构，遵循先入先出的规则。</p><h2 id="通道的声明"><a href="#通道的声明" class="headerlink" title="通道的声明"></a>通道的声明</h2><p>每个通道都只能传递一种数据类型的数据，在你声明的时候，我们要指定通道的类型。<code>chan Type</code> 表示 <code>Type</code> 类型的通道。通道的零值为 <code>nil</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel_name <span class="keyword">chan</span> channel_types</span><br></pre></td></tr></table></figure><p>下面的语句声明了一个类型为 <code>string</code> 的通道 <code>nameChan</code> ，该通道 <code>nameChan</code> 的值为 <code>nil</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">string</span></span><br></pre></td></tr></table></figure><h2 id="通道的初始化"><a href="#通道的初始化" class="headerlink" title="通道的初始化"></a>通道的初始化</h2><p>声明完通道后，通道的值为 <code>nil</code> ，我们不能直接使用，必须先使用 <code>make</code> 函数对通道进行初始化操作。</p><p>使用下面的语句我们可以对上面声明过的通道 <code>ch</code> 进行初始化：(这样，我们就已经定义好了一个 <code>string</code> 类型的通道 <code>nameChan</code> )</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br></pre></td></tr></table></figure><p>可以用简短声明一次性定义一个通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br></pre></td></tr></table></figure><h2 id="使用通道发送和接收数据"><a href="#使用通道发送和接收数据" class="headerlink" title="使用通道发送和接收数据"></a>使用通道发送和接收数据</h2><ul><li><p>往通道发送数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把data数据发送到channel_name中</span></span><br><span class="line"><span class="comment">// 即把 data 数据写入到 channel_name 通道中</span></span><br><span class="line">channel_name &lt;- data</span><br></pre></td></tr></table></figure></li><li><p>从通道接收数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 channel_name 通道中接收数据到 value</span></span><br><span class="line"><span class="comment">// 即从 channel_name 通道中读取数据到 value</span></span><br><span class="line">value := &lt;- channel_name</span><br></pre></td></tr></table></figure></li></ul><p>通道旁的箭头方向指定了是发送数据还是接收数据。箭头指向通道，代表数据写入到通道中；箭头往通道指向外，代表从通道读数据出去。</p><p>例子：</p><p>该程序模拟了两个协程并发调用的场景：</p><ol><li>在 <code>main</code> 函数中，创建了一个通道，在 <code>main</code> 函数中先打印了 <strong>开始</strong> ，然后开启协程运行 <code>PrintChan</code> 函数，而 <code>main</code> 函数通过协程接收数据，<strong>主协程发生了阻塞</strong>，等待通道 <code>ch</code> 发送的数据。</li><li>在函数中，数据 <strong>abcd</strong> 传入通道中，当写入完成时，<strong>主协程接收了数据</strong>，<strong>解除了阻塞状态</strong>，打印出从通道接收到的数据 <strong>abcd</strong> ，最后打印 <strong>结束</strong>。</li></ol><p>==<strong>发送与接收默认是阻塞的</strong>==</p><p>从下面的例子我们知道，如果从通道接收数据没接收完主协程是不会继续执行下去的。当把数据发送到通道时，会在发送数据的语句处发生阻塞，直到有其它协程从通道读取到数据，才会解除阻塞。与此类似，当读取通道的数据时，如果没有其它的协程把数据写入到这个通道，那么读取过程就会一直阻塞着。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintChan</span><span class="params">(c <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 往通道传入数据“abcd”</span></span><br><span class="line">c &lt;- <span class="string">&quot;abcd&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个通道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;开始：&quot;</span>)</span><br><span class="line"><span class="comment">// 开启协程</span></span><br><span class="line"><span class="keyword">go</span> PrintChan(ch)</span><br><span class="line"><span class="comment">// 从通道接收数据</span></span><br><span class="line">rec := &lt;-ch</span><br><span class="line"><span class="comment">// 打印从通道接收的数据</span></span><br><span class="line">fmt.Println(rec)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">开始：</span></span><br><span class="line"><span class="comment">abcd</span></span><br><span class="line"><span class="comment">结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="通道的关闭"><a href="#通道的关闭" class="headerlink" title="通道的关闭"></a>通道的关闭</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于一个已经使用完毕的通道，我们要将其进行关闭。</span></span><br><span class="line"><span class="built_in">close</span>(channel_name)</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong>对于一个已经关闭的通道如果再次关闭会导致报错，我们可以在接收数据时，判断通道是否已经关闭，从通道读取数据返回的第二个值表示通道是否没被关闭，如果已经关闭，返回值为 <code>false</code> ；如果还未关闭，返回值为 <code>true</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := &lt;- channel_name</span><br></pre></td></tr></table></figure><h2 id="通道的容量与长度"><a href="#通道的容量与长度" class="headerlink" title="通道的容量与长度"></a>通道的容量与长度</h2><p>我们在前面讲过 <code>make</code> 函数是可以接收两个参数的，同理，创建通道可以传入第二个参数——容量。</p><ul><li>当容量为 <code>0</code> 时，说明通道中不能存放数据，在发送数据时，必须要求立马有人接收，否则会报错。此时的通道称之为无缓冲通道。</li><li>当容量为 <code>1</code> 时，说明通道只能缓存一个数据，若通道中已有一个数据，此时再往里发送数据，会造成程序阻塞。利用这点可以利用通道来做锁。</li><li>当容量大于 <code>1</code> 时，通道中可以存放多个数据，可以用于多个协程之间的通信管道，共享资源。</li></ul><p>既然通道有容量和长度，那么我们可以通过 <code>cap</code> 函数和 <code>len</code> 函数获取通道的容量和长度。</p><h2 id="缓冲通道与无缓冲通道"><a href="#缓冲通道与无缓冲通道" class="headerlink" title="缓冲通道与无缓冲通道"></a>缓冲通道与无缓冲通道</h2><p>按照是否可缓冲数据可分为：<strong>缓冲通道</strong> 与 <strong>无缓冲通道</strong> 。</p><ul><li><p><strong>无缓冲通道</strong>在通道里无法存储数据，接收端必须先于发送端准备好，以确保你发送完数据后，有人立马接收数据，否则发送端就会造成阻塞，原因很简单，通道中无法存储数据。也就是说发送端和接收端是同步运行的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>缓冲通道</strong>允许通道里存储一个或多个数据，设置缓冲区后，发送端和接收端可以处于异步的状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="双向通道"><a href="#双向通道" class="headerlink" title="双向通道"></a>双向通道</h2><p>上面定义的都是双向通道，既可以发送数据也可以接收数据。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个通道</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;send: 1&quot;</span>)</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := &lt;-c</span><br><span class="line">fmt.Println(<span class="string">&quot;receive:&quot;</span>, n)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主协程休眠</span></span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">send: 1</span></span><br><span class="line"><span class="comment">receive: 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h2><p>单向通道只能发送或者接收数据。所以可以具体细分为<strong>只读通道</strong>和<strong>只写通道</strong>。</p><ul><li><p><code>&lt;-chan</code> 表示只读通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义只读通道</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="comment">// 定义类型</span></span><br><span class="line"><span class="keyword">type</span> Receiver = &lt;-<span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> receiver Receiver = c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者简单写成下面的形式</span></span><br><span class="line"><span class="keyword">type</span> Receiver = &lt;-<span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">receiver := <span class="built_in">make</span>(Receiver)</span><br></pre></td></tr></table></figure></li><li><p><code>chan&lt;-</code> 表示只写通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义只写通道</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="comment">// 定义类型</span></span><br><span class="line"><span class="keyword">type</span> Sender = <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> sender Sender = c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者简单写成下面的形式</span></span><br><span class="line"><span class="keyword">type</span> Sender = <span class="keyword">chan</span>&lt;- <span class="type">int</span></span><br><span class="line">sender := <span class="built_in">make</span>(Sender)</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sender = <span class="keyword">chan</span>&lt;- <span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> Receiver = &lt;-<span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个双向通道</span></span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一个协程</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只写通道</span></span><br><span class="line"><span class="keyword">var</span> sender Sender = ch</span><br><span class="line">fmt.Println(<span class="string">&quot;即将开始：&quot;</span>)</span><br><span class="line">sender &lt;- <span class="string">&quot;go语言&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一个协程</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读通道</span></span><br><span class="line"><span class="keyword">var</span> receiver Receiver = ch</span><br><span class="line">message := &lt;-receiver</span><br><span class="line">fmt.Println(<span class="string">&quot;开始：&quot;</span>, message)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主协程休眠</span></span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">即将开始：</span></span><br><span class="line"><span class="comment">开始： go语言</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="遍历通道"><a href="#遍历通道" class="headerlink" title="遍历通道"></a>遍历通道</h2><p>使用 <code>for range</code> 循环可以遍历通道，但在遍历时要确保通道是处于关闭状态，否则循环会被阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">looPrint</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">c &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记得要关闭通道</span></span><br><span class="line"><span class="comment">// 否则主协程遍历完不会结束，而会阻塞</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">go</span> looPrint(ch2)</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch2 &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="用通道做锁"><a href="#用通道做锁" class="headerlink" title="用通道做锁"></a>用通道做锁</h2><p>上面讲过，当通道容量为 <code>1</code> 时，说明通道只能缓存一个数据，若通道中已有一个数据，此时再往里发送数据，会造成程序阻塞。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 x = x+1 不是原子操作</span></span><br><span class="line"><span class="comment">// 所以应避免多个协程对 x 进行操作</span></span><br><span class="line"><span class="comment">// 使用容量为 1 的通道可以达到锁的效果</span></span><br><span class="line"><span class="comment">// 可以设置成大于1但是最后结果就不是10000了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">bool</span>, x *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">*x = *x + <span class="number">1</span></span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> increment(ch3, &amp;x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">fmt.Println(<span class="string">&quot;x =&quot;</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果是x = 10000</span></span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>当协程给一个通道发送数据时，照理说会有其他 Go 协程来接收数据。如果没有的话，程序就会在运行时触发 <code>panic</code> ，形成死锁。同理，当有协程等着从一个通道接收数据时，我们期望其他的 Go 协程会向该通道写入数据，要不然程序也会触发 <code>panic</code> 。</p><p>一个造成死锁的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：<code>fatal error: all goroutines are asleep - deadlock!</code></p><p>另一个报错的例子：</p><p>原因：使用 <code>make</code> 函数创建通道时默认不传递第二个参数，通道中不能存放数据，在发送数据时，必须要求立马有人接收，即该通道为无缓冲通道。所以在接收者没有准备好前，发送操作会被阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">ch &lt;- <span class="literal">true</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：<code>fatal error: all goroutines are asleep - deadlock!</code></p><p>可以将代码修改如下，使用协程，将接收者代码放在另一个协程里：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcRecieve</span><span class="params">(c <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> funcRecieve(ch4)</span><br><span class="line">ch4 &lt;- <span class="literal">true</span></span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义了通道的容量，但通道里的容量已经放不下新的数据，而没有接收者接收数据，就会造成阻塞，而对于一个协程来说就会造成死锁：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">ch6 &lt;- <span class="literal">true</span></span><br><span class="line">ch6 &lt;- <span class="literal">false</span></span><br><span class="line">fmt.Println(&lt;-ch6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，当程序一直在等待从通道里读取数据，而此时并没有发送者会往通道中写入数据。此时程序就会陷入死循环，造成死锁。</p><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>在实际开发中我们并不能保证每个协程执行的时间，如果需要等待多个协程，全部结束任务后，再执行某个业务逻辑。下面我们介绍处理这种情况的方式。</p><p><code>WaitGroup</code> 有几个方法：</p><ul><li><code>Add</code>：初始值为 <code>0</code> ，这里直接传入子协程的数量，你传入的值会往计数器上加。</li><li><code>Done</code>：当某个子协程完成后，可调用此方法，会从计数器上减一，即子协程的数量减一，通常使用 <code>defer</code> 来调用。</li><li><code>Wait</code>：阻塞当前协程，直到实例里的计数器归零。</li></ul><h3 id="使用信道"><a href="#使用信道" class="headerlink" title="使用信道"></a>使用信道</h3><p>信道可以实现多个协程间的通信，于是乎我们可以定义一个信道，在任务执行完成后，往信道中写入 <code>true</code> ，然后在主协程中获取到 <code>true</code> ，就可以认为子协程已经执行完毕。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">isDone := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">isDone &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-isDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用-WaitGroup"><a href="#用-WaitGroup" class="headerlink" title="用 WaitGroup"></a>用 WaitGroup</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(taskNum <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="comment">// 延迟调用 执行完子协程计数器减一</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">// 输出任务号</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;task %d: %d\n&quot;</span>, taskNum, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 实例化 sync.WaitGroup</span></span><br><span class="line"><span class="keyword">var</span> waitGroup sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入子协程数量</span></span><br><span class="line">waitGroup.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启一个子协程 以及实例waitGroup</span></span><br><span class="line"><span class="keyword">go</span> task(<span class="number">1</span>, &amp;waitGroup)</span><br><span class="line"><span class="keyword">go</span> task(<span class="number">2</span>, &amp;waitGroup)</span><br><span class="line"><span class="keyword">go</span> task(<span class="number">3</span>, &amp;waitGroup)</span><br><span class="line"><span class="comment">// 实例 waitGroup 阻塞当前协程 等待所有子协程执行完</span></span><br><span class="line">waitGroup.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">task 3: 0</span></span><br><span class="line"><span class="comment">task 3: 1</span></span><br><span class="line"><span class="comment">task 3: 2</span></span><br><span class="line"><span class="comment">task 1: 0</span></span><br><span class="line"><span class="comment">task 1: 1</span></span><br><span class="line"><span class="comment">task 1: 2</span></span><br><span class="line"><span class="comment">task 2: 0</span></span><br><span class="line"><span class="comment">task 2: 1</span></span><br><span class="line"><span class="comment">task 2: 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9-方法和接口(go基础)</title>
      <link href="/archives/468e9c5e.html"/>
      <url>/archives/468e9c5e.html</url>
      
        <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><strong>方法</strong> 其实就是一个函数，在 <code>func</code> 这个关键字和方法名中间加入了一个特殊的接收器类型。接收器可以是结构体类型或者是非结构体类型。接收器是可以在方法的内部访问的。</p><h2 id="方法基础应用"><a href="#方法基础应用" class="headerlink" title="方法基础应用"></a>方法基础应用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a myInt)</span></span> add(b myInt) myInt &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x myInt = <span class="number">50</span></span><br><span class="line">    <span class="keyword">var</span> y myInt = <span class="number">7</span></span><br><span class="line">    fmt.Println(x.add(y))   <span class="comment">// 57</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法在结构体上应用"><a href="#方法在结构体上应用" class="headerlink" title="方法在结构体上应用"></a>方法在结构体上应用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span> <span class="comment">// 学生姓名</span></span><br><span class="line">sno  <span class="type">string</span> <span class="comment">// 学生学号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span> <span class="comment">// 教师姓名</span></span><br><span class="line">gz   <span class="type">int</span>    <span class="comment">//教师工资</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span></span> show() &#123;</span><br><span class="line">fmt.Println(stu.name)</span><br><span class="line">fmt.Println(stu.sno)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(th Teacher)</span></span> show() &#123;</span><br><span class="line">fmt.Println(th.name)</span><br><span class="line">fmt.Println(th.gz)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := Student&#123;<span class="string">&quot;jpc&quot;</span>, <span class="string">&quot;123456&quot;</span>&#125;</span><br><span class="line">th := Teacher&#123;<span class="string">&quot;xhr&quot;</span>, <span class="number">12000</span>&#125;</span><br><span class="line">stu.show()</span><br><span class="line">th.show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>Go 语言不是一种 “传统” 的面向对象编程语言：它里面没有类和继承的概念,</p><p>Go 语言里有非常灵活的 接口 概念,通过它可以实现很多<strong><em>面向对象的特性\</em></strong>, <strong><em>接口提供了一种方式来说明对象的行为\</em></strong>,</p><ul><li>接口定义了一组方法（方法集）,但是这些方法不包含（实现）代码。</li><li>接口方法没有被实现（它们是抽象的）。</li><li>接口里也不能包含变量。</li></ul><h2 id="接口隐式实现"><a href="#接口隐式实现" class="headerlink" title="接口隐式实现"></a>接口隐式实现</h2><p>隐式实现了 <code>People</code> 接口，实现的内容是打印语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">fun()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span></span> fun() &#123;</span><br><span class="line">fmt.Println(stu.name, stu.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := Student&#123;</span><br><span class="line">name: <span class="string">&quot;jpc&quot;</span>,</span><br><span class="line">age:  <span class="number">21</span>,</span><br><span class="line">&#125;</span><br><span class="line">stu.fun()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="接口实现多态"><a href="#接口实现多态" class="headerlink" title="接口实现多态"></a>接口实现多态</h2><p>利用的接口实现了不同的功能，这就是多态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">interface</span> &#123;</span><br><span class="line">fun()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">gz   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span></span> fun() &#123;</span><br><span class="line">fmt.Println(stu.name, stu.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(th Teacher)</span></span> fun() &#123;</span><br><span class="line">fmt.Println(th.name, th.gz)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := Student&#123;</span><br><span class="line">name: <span class="string">&quot;jpc&quot;</span>,</span><br><span class="line">age:  <span class="number">21</span>,</span><br><span class="line">&#125;</span><br><span class="line">th := Teacher&#123;</span><br><span class="line">name: <span class="string">&quot;xhr&quot;</span>,</span><br><span class="line">gz:   <span class="number">10010</span>,</span><br><span class="line">&#125;</span><br><span class="line">stu.fun()</span><br><span class="line">th.fun()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p><strong>空接口</strong> 是特殊形式的接口类型，没有定义任何方法的接口就称为空接口，可以说所有类型都至少实现了空接口，空接口表示为 <code>interface&#123;&#125;</code> 。例如，我们之前的写过的空接口参数函数，可以接受任何类型的参数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowType</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;类型: %T, 值: %v\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;11111&quot;</span></span><br><span class="line">    ShowType(str)</span><br><span class="line">    num := <span class="number">3.14</span></span><br><span class="line">    ShowType(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序中我们定义了函数 <code>ShowType</code> 使用空接口作为参数，所以可以给这个函数传递任何类型的参数。</p><p>直接使用 <code>interface&#123;&#125;</code> 作为类型声明一个实例，这个实例就能承载任何类型的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;111111&quot;</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">i = <span class="number">3.14</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们也可以定义一个接收任何类型的 <code>array</code> 、 <code>slice</code> 、 <code>map</code> 、 <code>strcut</code> 。例如：</p><p><strong>当空接口承载数组和切片后，该对象无法再进行切片。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;dsa1&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">21</span></span><br><span class="line">a[<span class="number">2</span>] = []<span class="type">int</span>&#123;<span class="number">21</span>, <span class="number">231</span>&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言用于提取接口的底层值(Underlying Value)。使用 <code>interface.(Type)</code> 可以获取接口的底层值，其中接口 <code>interface</code> 的具体类型是 <code>Type</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assert</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    value, ok := i.(<span class="type">int</span>)</span><br><span class="line">    fmt.Println(value, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="number">3</span></span><br><span class="line">    assert(x)</span><br><span class="line">    <span class="keyword">var</span> y <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">    assert(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-流程控制(go基础)</title>
      <link href="/archives/97c33ac0.html"/>
      <url>/archives/97c33ac0.html</url>
      
        <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span> &#123;</span><br><span class="line">  逻辑代码<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>  条件<span class="number">2</span> &#123;</span><br><span class="line">  逻辑代码<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 条件 ... &#123;</span><br><span class="line">  逻辑代码 ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  逻辑代码 <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> 表达式 &#123;</span><br><span class="line">    <span class="keyword">case</span> 表达式值<span class="number">1</span>:</span><br><span class="line">        业务逻辑代码<span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> 表达式值<span class="number">2</span>:</span><br><span class="line">        业务逻辑代码<span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> 表达式值<span class="number">3</span>:</span><br><span class="line">        业务逻辑代码<span class="number">3</span></span><br><span class="line">    <span class="keyword">case</span> 表达式值 ...:</span><br><span class="line">        业务逻辑代码 ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        业务逻辑代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>只有for：四种用法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for 接三个表达式</span></span><br><span class="line"><span class="keyword">for</span> initialisation; condition; post &#123;</span><br><span class="line">   code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 接一个条件表达式</span></span><br><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">   code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 接一个 range 表达式</span></span><br><span class="line"><span class="keyword">for</span> range_expression &#123;</span><br><span class="line">   code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 不接表达式</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">   code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defer-延迟调用"><a href="#defer-延迟调用" class="headerlink" title="defer 延迟调用"></a>defer 延迟调用</h2><p>含有 <code>defer</code> 语句的函数，会在该函数将要返回之前，调用另一个函数。简单点说就是 <code>defer</code> 语句后面跟着的函数会延迟到<strong>当前函数执行完后再执行</strong>。</p><ul><li><code>defer</code> 不仅能够延迟函数的执行，也能延迟方法的执行。</li><li>使用 <code>defer</code> 只是延时调用函数，传递给函数里的变量，不应该受到后续程序的影响。</li><li>当一个函数内多次调用 <code>defer</code> 时，Go 会把 <code>defer</code> 调用放入到一个栈中，随后按照 <strong>后进先出</strong> 的顺序执行。</li><li><strong>defer 在 return 后调用</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;fun函数...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fun()</span><br><span class="line">    fmt.Println(<span class="string">&quot;main函数...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="goto-无条件跳转"><a href="#goto-无条件跳转" class="headerlink" title="goto 无条件跳转"></a>goto 无条件跳转</h2><ul><li>在 Go 语言中保留 <code>goto</code> 。<code>goto</code> 后面接的是标签，表示下一步要执行哪里的代码。</li><li><code>goto</code> 语句与标签之间不能有变量声明，否则编译错误。编译下面的程序会报错。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">goto</span> label</span><br><span class="line">fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">label:</span><br><span class="line">    fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-函数(go基础)</title>
      <link href="/archives/59c5ec07.html"/>
      <url>/archives/59c5ec07.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回一个无名变量，返回值列表的括号省略</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := add(<span class="number">1</span>, <span class="number">23</span>)</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><h3 id="多个类型一致的参数"><a href="#多个类型一致的参数" class="headerlink" title="多个类型一致的参数"></a>多个类型一致的参数</h3><p>在参数类型前面加 <code>...</code> 表示一个切片，用来接收调用者传入的参数。注意，如果该函数下有其他类型的参数，这些其他参数必须放在参数列表的前面，切片必须放在最后。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(args ...<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> args &#123;</span><br><span class="line">        fmt.Println(item)</span><br><span class="line">sum += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(show(<span class="string">&quot;111&quot;</span>,<span class="string">&quot;222&quot;</span>,<span class="string">&quot;333&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个类型不一致的参数"><a href="#多个类型不一致的参数" class="headerlink" title="多个类型不一致的参数"></a>多个类型不一致的参数</h3><p>如果传多个参数的类型都不一样，可以指定类型为 <code>...interface&#123;&#125;</code> ，然后再遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> args &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">sum++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(show(<span class="string">&quot;jpc&quot;</span>, <span class="number">21</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解序列"><a href="#解序列" class="headerlink" title="解序列"></a>解序列</h2><p>使用 <code>...</code> 可以用来解序列，能将函数的可变参数(即切片)一个一个取出来，传递给另一个可变参数的函数，而不是传递可变参数变量本身。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line">s = <span class="built_in">append</span>(s, []<span class="type">string</span>&#123;<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>&#125;...)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>当函数没有返回值时，函数体可以使用 <code>return</code> 语句返回。在 Go 中一个函数可以返回<strong>多个值</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;名字不能为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> name, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name, err := show(<span class="string">&quot;jpc&quot;</span>, <span class="number">21</span>)</span><br><span class="line">fmt.Println(name, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>没有名字的函数就叫 <strong>匿名函数</strong> ，它只有函数逻辑体，而没有函数名。匿名函数只拥有短暂的生命，一般都是定义后立即使用。</p><h2 id="内部方法与外部方法"><a href="#内部方法与外部方法" class="headerlink" title="内部方法与外部方法"></a>内部方法与外部方法</h2><p>在 Go 语言中，函数名通过首字母大小写实现控制对方法的访问权限。</p><ul><li>当方法的首字母为 <strong>大写</strong> 时，这个方法对于 <strong>所有包</strong> 都是 <strong>Public</strong> ，其他包可以随意调用。</li><li>当方法的首字母为 <strong>小写</strong> 时，这个方法是 <strong>Private</strong> ，其他包是无法访问的。</li></ul><h1 id="头等函数"><a href="#头等函数" class="headerlink" title="头等函数"></a>头等函数</h1><h2 id="把函数赋值给变量"><a href="#把函数赋值给变量" class="headerlink" title="把函数赋值给变量"></a>把函数赋值给变量</h2><p>Go 语言拥有 <strong>头等函数(First-class Function)</strong> ，头等函数是指函数可以被当作变量一样使用，即函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bookFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;这是一个函数&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    bookFunc()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;bookFunc 的类型是 %T\n&quot;</span>, bookFunc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">《Go语言极简一本通》</span></span><br><span class="line"><span class="comment">bookFunc 的类型是 func()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="传递一个函数作为参数"><a href="#传递一个函数作为参数" class="headerlink" title="传递一个函数作为参数"></a>传递一个函数作为参数</h2><p>我们把 <strong>接收一个或多个函数作为参数</strong> 或者 <strong>返回值也是一个函数</strong> 的函数称为 <strong>高阶函数(Hiher-order Function)</strong> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Out</span><span class="params">(show <span class="keyword">func</span>(name, hobby <span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line">   fmt.Println(show(<span class="string">&quot;jpc&quot;</span>, <span class="string">&quot;羽毛球&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   f := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y</span><br><span class="line">   &#125;</span><br><span class="line">   Out(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回一个函数"><a href="#返回一个函数" class="headerlink" title="返回一个函数"></a><strong>返回一个函数</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// show返回一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(name, hobby <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := show()</span><br><span class="line">fmt.Println(f(<span class="string">&quot;jpc&quot;</span>, <span class="string">&quot;羽毛球&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 jpc羽毛球</span></span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>闭包(Closure)</strong> 是匿名函数的一个特例。当一个匿名函数所访问的变量定义在函数体的外部时，就称这样的匿名函数为闭包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   x := <span class="number">1000</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      fmt.Println(x)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-结构体(go基础)</title>
      <link href="/archives/4d4a3a7d.html"/>
      <url>/archives/4d4a3a7d.html</url>
      
        <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p><strong>结构体(struct)</strong> 是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。学过 C 或 C++ 的人都知道结构体，但在 Go 中，没有像 C++ 中的 <code>class</code> 类的概念，只有 <code>struct</code> 结构体的概念，所以也没有继承。</p><h2 id="创建一个结构体"><a href="#创建一个结构体" class="headerlink" title="创建一个结构体"></a>创建一个结构体</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span> <span class="comment">// 学生姓名</span></span><br><span class="line">sno  <span class="type">string</span> <span class="comment">// 学生学号</span></span><br><span class="line">age  <span class="type">int</span>    <span class="comment">// 学生年龄</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu1 := Student&#123;</span><br><span class="line">name: <span class="string">&quot;jpc&quot;</span>,</span><br><span class="line">sno:  <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">age:  <span class="number">21</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stu2 := Student&#123;<span class="string">&quot;jzw&quot;</span>, <span class="string">&quot;123123&quot;</span>, <span class="number">22</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(stu1)</span><br><span class="line">fmt.Println(stu2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建匿名结构体"><a href="#创建匿名结构体" class="headerlink" title="创建匿名结构体"></a>创建匿名结构体</h2><ul><li>当定义好的结构体没有被显式初始化时，结构体的字段将会默认赋为相应类型的零值。</li><li>点操作符 <code>.</code> 可以用于对结构体的字段的赋值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">sno  <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">name: <span class="string">&quot;jhy&quot;</span>,</span><br><span class="line">sno:  <span class="string">&quot;222222&quot;</span>,</span><br><span class="line">age:  <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line">stu.sno = <span class="string">&quot;123321&quot;</span></span><br><span class="line">fmt.Println(stu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h2><p>在创建结构体时，字段可以只有类型没有字段名，这种字段称为 <strong>匿名字段</strong> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">string</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := Student&#123;<span class="string">&quot;jpc&quot;</span>, <span class="number">21</span>&#125;</span><br><span class="line">fmt.Println(stu)</span><br><span class="line">fmt.Println(stu.<span class="type">string</span>)</span><br><span class="line">fmt.Println(stu.<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Score <span class="keyword">struct</span> &#123;</span><br><span class="line">math    <span class="type">int</span></span><br><span class="line">english <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="type">string</span></span><br><span class="line">sno   <span class="type">string</span></span><br><span class="line">score Score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体嵌套</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">stu := Student&#123;</span><br><span class="line">name: <span class="string">&quot;jpc&quot;</span>,</span><br><span class="line">sno:  <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">stu.score = Score&#123;<span class="number">98</span>, <span class="number">56</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(stu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出&#123;jpc 123456 &#123;98 56&#125;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="提升字段"><a href="#提升字段" class="headerlink" title="提升字段"></a>提升字段</h2><p>结构体中如果有匿名的结构体类型字段，则该匿名结构体里的字段就称为 <strong>提升字段(Promoted Fields)</strong> 。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。</p><p>对上面程序稍作修改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="type">string</span></span><br><span class="line">sno   <span class="type">string</span></span><br><span class="line">Score</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样访问字段就可以从<code>stu.score.math</code>直接变成<code>stu.math</code></p><h2 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h2><p>结构体比较可以用==运算符可以用 DeeplyEqual()函数</p><h2 id="给结构体定义方法"><a href="#给结构体定义方法" class="headerlink" title="给结构体定义方法"></a>给结构体定义方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">sno  <span class="type">string</span></span><br><span class="line">age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个与 Student 绑定的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu Student)</span></span> Show() &#123;</span><br><span class="line">fmt.Println(stu.name)</span><br><span class="line">fmt.Println(stu.sno)</span><br><span class="line">fmt.Println(stu.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stu *Student)</span></span> AddAge(n <span class="type">int</span>) &#123;</span><br><span class="line">stu.age += n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stu := Student&#123;<span class="string">&quot;jpc&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">21</span>&#125;</span><br><span class="line">stu.AddAge(<span class="number">3</span>)</span><br><span class="line">stu.Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="结构体的-Tag-标签"><a href="#结构体的-Tag-标签" class="headerlink" title="结构体的 Tag 标签"></a>结构体的 Tag 标签</h1><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>Go语言结构体成员Tag来指定对应的JSON名字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Target <span class="type">string</span> <span class="string">`json:&quot;target&quot;`</span></span><br><span class="line">    Spend  <span class="type">int</span>    <span class="string">`json:&quot;spend,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Tag</code> 中 <code>json</code> 对应值的第一部分用于指定 <code>JSON</code> 对象的名字，比如将 Go 语言中的 <code>TotalCount</code> 成员对应到 <code>JSON</code> 中的 <code>total_count</code> 对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">   Addr <span class="type">string</span> <span class="string">`json:&quot;addr&quot;`</span></span><br><span class="line">   Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p1 := People&#123;</span><br><span class="line">      Name: <span class="string">&quot;谢老板&quot;</span>,</span><br><span class="line">      Addr: <span class="string">&quot;海底餐厅&quot;</span>,</span><br><span class="line">      Age:  <span class="number">35</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 结构体转化成json</span></span><br><span class="line">   data1, err := json.Marshal(p1)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, data1)</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// &#123;&quot;name&quot;:&quot;谢老板&quot;,&quot;addr&quot;:&quot;海底餐厅&quot;,&quot;age&quot;:35&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Tag-获取"><a href="#Tag-获取" class="headerlink" title="Tag 获取"></a>Tag 获取</h2><p>Tag 的格式上面已经说了，它是由反引号括起来的一系列用空格分隔的 <code>key:&quot;value&quot;</code> 键值对序列.</p><p>使用反射的方法获取 Tag 步骤如下：</p><ol><li>获取字段</li><li>获取 Tag</li><li>获取键值对</li></ol><p>其中获取字段有三种方式，而获取键值对有两种方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">   Addr <span class="type">string</span> <span class="string">`json:&quot;addr&quot;`</span></span><br><span class="line">   Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   p := reflect.TypeOf(People&#123;&#125;)</span><br><span class="line">   name, _ := p.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">   tag := name.Tag</span><br><span class="line">   fmt.Println(<span class="string">&quot;Name Tag:&quot;</span>, tag)</span><br><span class="line">   keyValue, _ := tag.Lookup(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;key: json, value:&quot;</span>, keyValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-指针(go基础)</title>
      <link href="/archives/138d9d44.html"/>
      <url>/archives/138d9d44.html</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针基础"><a href="#指针基础" class="headerlink" title="指针基础"></a>指针基础</h2><p>指针也是一种类型，也可以创建变量，称之为指针变量。指针变量的类型为 <code>*Type</code>，该指针指向一个 <code>Type</code> 类型的变量。指针变量最大的特点就是存储的某个实际变量的内存地址，通过记录某个变量的地址，从而间接的操作该变量。</p><ul><li>如果指针声明后没有进行初始化，其默认零值是 <code>nil</code></li><li>在函数中对指针参数所做的修改，在函数返回后会保存相应的修改。</li><li>Go 中不支持指针运算例如：<code>p++</code> ，但这在 Go 中是不支持的。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;num</span><br><span class="line">fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针与切片"><a href="#指针与切片" class="headerlink" title="指针与切片"></a>指针与切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">8</span></span><br><span class="line">p := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">p = &amp;num</span><br><span class="line">fmt.Println(p)</span><br><span class="line">fmt.Println(*p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun2</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun3</span><span class="params">(arr *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">(*arr)[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果为[1 0 0 0 2 3]</span></span><br><span class="line">    fun2(arr)</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结果为[1 5 0 0 2 3]</span></span><br><span class="line">fun3(&amp;arr)</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-容器类型(go基础)</title>
      <link href="/archives/88b8ac59.html"/>
      <url>/archives/88b8ac59.html</url>
      
        <content type="html"><![CDATA[<h1 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>数组</strong> 是一个由 <strong>固定长度</strong> 的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。</p><p><strong>[3]int 和 [5]int 是不同的类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">5</span>][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun3</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 直接在声明时对数组进行初始化</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>&#125;</span><br><span class="line">fmt.Println(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用短声明</span></span><br><span class="line">arr2 := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>&#125;</span><br><span class="line">fmt.Println(arr2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分初始化, 未初始化的为零值</span></span><br><span class="line">arr3 := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>&#125; <span class="comment">// [15 20 0 0 0]</span></span><br><span class="line">fmt.Println(arr3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过指定索引，方便地对数组某几个元素赋值</span></span><br><span class="line">arr4 := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">100</span>, <span class="number">4</span>: <span class="number">200</span>&#125;</span><br><span class="line">fmt.Println(arr4) <span class="comment">// [0 100 0 0 200]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用 ... 让编译器为我们计算该数组的长度</span></span><br><span class="line">arr5 := [...]<span class="type">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>&#125;</span><br><span class="line">fmt.Println(arr5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//fun1()</span></span><br><span class="line">fun2()</span><br><span class="line"><span class="comment">//fun3()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="len函数"><a href="#len函数" class="headerlink" title="len函数"></a>len函数</h3><p>使用内置的 <code>len</code> 函数将返回数组中元素的个数，即数组的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr)) <span class="comment">// 数组长度是4</span></span><br></pre></td></tr></table></figure><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>使用 <code>for range</code> 循环可以获取数组每个索引以及索引上对应的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showArr</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;arr[%d]=%s\n&quot;</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;value=%s\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a><strong>数组是值类型</strong></h3><p>Go 中的数组是值类型而不是引用类型。当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。如果对新变量进行更改，不会影响原始数组.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrByValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;02&quot;</span>, <span class="string">&quot;03&quot;</span>&#125;</span><br><span class="line">b := arr</span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&quot;01&quot;</span></span><br><span class="line">fmt.Println(arr)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">[1, 02, 03]</span></span><br><span class="line"><span class="comment">[01, 02, 03]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片(Slice)"></a>切片(Slice)</h2><p>切片是对数组的一个连续片段的引用，所以切片是一个<strong>引用类型</strong>。切片 本身不拥有任何数据，它们只是对现有数组的引用，每个切片值都会将数组作为其底层的数据结构。slice 的语法和数组很像，只是<strong>没有固定长度</strong>而已。</p><h3 id="切片的声明"><a href="#切片的声明" class="headerlink" title="切片的声明"></a>切片的声明</h3><ol><li><code>make</code> 函数构造一个切片，格式为 <code>make([]Type, size, cap)</code> 。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.最常用声明切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr1 []<span class="type">int</span></span><br><span class="line">arr1 = <span class="built_in">append</span>(arr1, <span class="number">1</span>)</span><br><span class="line">fmt.Println(arr1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">fmt.Println(arr2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. make创建切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(arr1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//fun1()</span></span><br><span class="line">fun2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 3</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="切片是引用类型"><a href="#切片是引用类型" class="headerlink" title="切片是引用类型"></a>切片是引用类型</h3><p>由于 slice 是引用类型，所以你不对它进行赋值的话，它的默认值是 <code>nil</code></p><p>切片之间不能比较，因此我们不能使用 <code>==</code> 操作符来判断两个 slice 是否含有全部相等元素。特别注意，如果你需要测试一个 slice 是否是空的，使用 <code>len(s) == 0</code> 来判断，而不应该用 <code>s == nil</code> 来判断。</p><h3 id="元素修改"><a href="#元素修改" class="headerlink" title="元素修改"></a>元素修改</h3><p>切片自己不拥有任何数据。它只是底层数组的一种表示。对切片所做的任何修改都会反映在底层数组中.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [...]<span class="type">string</span>&#123;<span class="string">&quot;11&quot;</span>, <span class="string">&quot;22&quot;</span>, <span class="string">&quot;33&quot;</span>&#125;</span><br><span class="line">s := arr[:] <span class="comment">//[0:len(arr)]</span></span><br><span class="line">fmt.Println(arr) <span class="comment">//[11 22 33]</span></span><br><span class="line">fmt.Println(s) <span class="comment">//[11 22 33]</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;aa&quot;</span></span><br><span class="line">fmt.Println(arr) <span class="comment">//[aa 22 33]</span></span><br><span class="line">fmt.Println(s) <span class="comment">//[aa 22 33]</span></span><br></pre></td></tr></table></figure><h3 id="元素追加"><a href="#元素追加" class="headerlink" title="元素追加"></a>元素追加</h3><p>当新的元素被添加到切片时，如果容量不足，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回新的引用。现在新切片的容量是旧切片的两倍。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//追加切片元素</span></span><br><span class="line">s := []<span class="type">string</span>&#123;<span class="string">&quot;11&quot;</span>&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s)) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;22&quot;</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s))<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;33&quot;</span>, <span class="string">&quot;44&quot;</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s))<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, []<span class="type">string</span>&#123;<span class="string">&quot;55&quot;</span>, <span class="string">&quot;66&quot;</span>&#125;...)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(s))<span class="comment">//8</span></span><br></pre></td></tr></table></figure><h3 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h3><p>删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的copy函数将后面的子slice向前依次移动一位完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(slice []<span class="type">int</span>, i <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="built_in">copy</span>(slice[i:], slice[i+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> slice[:<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    fmt.Println(remove(s, <span class="number">2</span>)) <span class="comment">// &quot;[5 6 8 9]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果删除元素后不用保持原来顺序的话，我们可以简单的用最后一个元素覆盖被删除的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(slice []<span class="type">int</span>, i <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    slice[i] = slice[<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> slice[:<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>在 Go 语言中，map 是散列表(哈希表)的引用(引用类型)。</p><p>使用 <code>make</code> 函数传入键和值的类型，可以创建 map 。具体语法为 <code>make(map[KeyType]ValueType)</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个键类型为 string 值类型为 int 名为 mp1 的 map</span></span><br><span class="line">mp1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">mp2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用 map 字面值的语法创建 map</span></span><br><span class="line"><span class="keyword">var</span> mp3 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;1&quot;</span>: <span class="string">&quot;aa&quot;</span>,</span><br><span class="line"><span class="string">&quot;2&quot;</span>: <span class="string">&quot;bb&quot;</span>,</span><br><span class="line"><span class="string">&quot;3&quot;</span>: <span class="string">&quot;cc&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(mp3)</span><br><span class="line"></span><br><span class="line">mp4 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;aa&quot;</span>: <span class="string">&quot;11&quot;</span>,</span><br><span class="line"><span class="string">&quot;bb&quot;</span>: <span class="string">&quot;22&quot;</span>,</span><br><span class="line"><span class="string">&quot;cc&quot;</span>: <span class="string">&quot;33&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(mp4)</span><br></pre></td></tr></table></figure><h3 id="Map-操作"><a href="#Map-操作" class="headerlink" title="Map 操作"></a>Map 操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="comment">// 可以使用 `map[key] = value` 向 map 添加元素。</span></span><br><span class="line">mp1[<span class="string">&quot;11&quot;</span>] = <span class="string">&quot;aa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更新元素</span></span><br><span class="line"><span class="comment">// 若 key 已存在，使用 map[key] = value 可以直接更新对应 key 的 value 值。</span></span><br><span class="line">mp1[<span class="string">&quot;11&quot;</span>] = <span class="string">&quot;AAA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line">fmt.Println(mp1[<span class="string">&quot;11&quot;</span>] )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="comment">//使用 delete(map, key)可以删除 map 中的对应 key 键值对,如果 key 不存在,delete 函数会静默处理，不会报错。</span></span><br><span class="line"><span class="built_in">delete</span>(mp1, <span class="string">&quot;11&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 key 是否存在</span></span><br><span class="line"><span class="comment">// 如果我们想知道 map 中的某个 key 是否存在，可以使用下面的语法：value, ok := map[key]</span></span><br><span class="line"><span class="comment">// 这个语句说明 `map` 的下标读取可以返回两个值，第一个值为当前 `key` 的 `value` 值，第二个值表示对应的 `key` 是否存在，若存在 `ok` 为 `true` ，若不存在，则 `ok` 为 `false` 。</span></span><br><span class="line">v3, ok := mp1[<span class="string">&quot;22&quot;</span>]</span><br><span class="line">fmt.Println(ok)</span><br><span class="line">fmt.Println(v3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历map</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> mp1 &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;key: %s, value: %d\n&quot;</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取长度</span></span><br><span class="line"> fmt.Println(<span class="built_in">len</span>(mp1))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-基础数据类型(go基础)</title>
      <link href="/archives/91d70fca.html"/>
      <url>/archives/91d70fca.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><p>Go 语言数据类型包含基础类型和复合类型两大类.</p><ul><li><p><strong>基础数据类型</strong>包括：布尔型,整型,浮点型,复数型,字符型,字符串型,错误类型. </p></li><li><p><strong>复合数据类型</strong>包括：指针,数组,切片,字典,通道,结构体,接口.</p></li></ul><h2 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h2><ul><li>有符号整型：int8、int16、int32、int64、int。</li><li>无符号整型：uint8、uint16、uint32、uint64、uint。</li></ul><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><ul><li><code>float32</code> 的精度只能提供大约 <code>6</code> 个十进制数(表示小数点后 <code>6</code> 位)的精度。</li><li><code>float64</code> 的精度能提供大约 <code>15</code> 个十进制数(表示小数点后 <code>15</code> 位)的精度。</li></ul><p>float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差.</p><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1+2i</span></span><br><span class="line"><span class="keyword">var</span> y <span class="type">complex128</span> = <span class="built_in">complex</span>(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 3+4i</span></span><br><span class="line">fmt.Println(x*y)                 <span class="comment">// &quot;(-5+10i)&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">real</span>(x*y))           <span class="comment">// &quot;-5&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">imag</span>(x*y))           <span class="comment">// &quot;10&quot;</span></span><br><span class="line">fmt.Println(<span class="number">1i</span> * <span class="number">1i</span>)  <span class="comment">// &quot;(-1+0i)&quot;, i^2 = -1</span></span><br><span class="line">fmt.Println(cmplx.Sqrt(<span class="number">-1</span>))  <span class="comment">// &quot;(0+1i)&quot;</span></span><br></pre></td></tr></table></figure><h2 id="布尔型、字符串"><a href="#布尔型、字符串" class="headerlink" title="布尔型、字符串"></a>布尔型、字符串</h2><p>布尔型同c++</p><p>但是布尔值并不会隐式转换为数字值0或1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 <span class="type">string</span></span><br><span class="line">s1 = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;1234&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多行字符串</span></span><br><span class="line"><span class="keyword">var</span> s1 <span class="type">string</span></span><br><span class="line">s1 = <span class="string">`</span></span><br><span class="line"><span class="string">    adsas</span></span><br><span class="line"><span class="string">    sdddsds</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><div class="table-container"><table><thead><tr><th>byte</th><th>1</th><th>表示 UTF-8 字符串的单个字节的值，表示的是 ASCII 码表中的一个字符，uint8 的别名类型</th></tr></thead><tbody><tr><td>rune</td><td>4</td><td>表示单个 unicode 字符，int32 的别名类型</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-变量与常量(go基础)</title>
      <link href="/archives/58cc03ab.html"/>
      <url>/archives/58cc03ab.html</url>
      
        <content type="html"><![CDATA[<h1 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>声明变量的一般形式是使用 var 关键字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：声明一个变量, 默认的值是0</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：声明一个变量, 初始化一个值</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：在初始化的时候，可以省去数据类型，通过值去自动匹配当前变量的数据类型</span></span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法四：(常用的方法) 省去var关键字，使用:=，既推导数据类型又赋值</span></span><br><span class="line">    <span class="comment">// 注: 短声明是在函数或方法内部使用, 不支持全局变量声明！！！！</span></span><br><span class="line">    e := <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明多个变量</span></span><br><span class="line">    <span class="keyword">var</span> x, y <span class="type">int</span> = <span class="number">100</span>, <span class="number">200</span></span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>定义一个常量，使用 const 关键字。常量定义的时候就要赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量(只读属性)</span></span><br><span class="line">    <span class="keyword">const</span> length <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const来定义枚举类型</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    BEIJING = <span class="number">0</span></span><br><span class="line">    SHANGHAI = <span class="number">1</span></span><br><span class="line">    SHENZHEN = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>      <span class="keyword">default</span>       <span class="function"><span class="keyword">func</span>     <span class="title">interface</span>   <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>       <span class="keyword">defer</span>         <span class="keyword">go</span>       <span class="keyword">map</span>         <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>       <span class="keyword">else</span>          <span class="keyword">goto</span>     <span class="keyword">package</span>     <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>      <span class="keyword">fallthrough</span>   <span class="keyword">if</span>       <span class="keyword">range</span>       <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>   <span class="keyword">for</span>           <span class="keyword">import</span>   <span class="keyword">return</span>      <span class="keyword">var</span></span><br></pre></td></tr></table></figure><h1 id="make和new的区别"><a href="#make和new的区别" class="headerlink" title="make和new的区别"></a>make和new的区别</h1><h2 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h2><p>内置函数 <code>new</code> 分配内存。该函数只接受一个参数，该参数是一个任意类型(包括自定义类型)，而不是值，返回指向该类型新分配零值的指针。</p><p>使用 <code>new</code> 函数首先会分配内存，并设置类型零值，最后返回指向该类型新分配零值的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line"><span class="comment">// 打印出类型的值</span></span><br><span class="line">fmt.Println(*num)  <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="make-函数"><a href="#make-函数" class="headerlink" title="make 函数"></a>make 函数</h2><p>内置函数 <code>make</code> 只能分配和初始化类型为 <code>slice</code> 、 <code>map</code> 或 <code>chan</code> 的对象。与 <code>new</code> 一样，第一个参数是类型，而不是值。与 <code>new</code> 不同， <code>make</code> 的返回类型与其参数的类型相同，而不是指向它的指针。结果取决于类型：</p><ul><li><code>slice</code>：size 指定长度。切片的容量等于其长度。可提供第三个参数以指定不同的容量；它不能小于长度。</li><li><code>map</code>：为空映射分配足够的空间来容纳指定数量的元素。可以省略大小，在这种情况下，分配一个小的起始大小。</li><li><code>chan</code>：使用指定的缓冲区容量初始化通道的缓冲区。如果为零，或者忽略了大小，则通道是无缓冲的。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slice</span></span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line">b := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// chan</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="new-和-make-的区别"><a href="#new-和-make-的区别" class="headerlink" title="new 和 make 的区别"></a>new 和 make 的区别</h2><p><code>new</code>：为所有的类型分配内存，并初始化为零值，返回指针。</p><p><code>make</code>：只能为 <code>slice</code> 、 <code>map</code> 、 <code>chan</code> 分配内存，并初始化，返回的是类型。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-什么是Go语言(go基础)</title>
      <link href="/archives/41c38990.html"/>
      <url>/archives/41c38990.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言是什么"><a href="#Go语言是什么" class="headerlink" title="Go语言是什么"></a>Go语言是什么</h1><p>Go语言是一个开源的编程语言,它能让构造简单,可靠且高效的软件变得容易。</p><ul><li>Go语言现代,快速,包含强大完善的标准库.</li><li>Go语言内置并发goroutine.</li><li>Go语言使用接口作为代码可重用性的构建块.</li></ul><p>Go语言的优点：</p><ul><li>编译成机器码</li><li><strong>静态类型语言</strong>：静态类型的语言就是可以在编译的时候检查出来隐藏的大多数问题，但是有很多的包可以使用,写起来的效率很高，Go最大的特色, <strong>天生的支持并发</strong>（可以充分的利用多核,很容易的使用并发）</li><li><strong>内置runtime</strong>，支持垃圾回收</li><li><strong>丰富的标准库</strong>（网络库强大）</li><li><strong>跨平台编译</strong></li></ul><p>Go语言学习开始第一步（Hello World!）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Hello, World&quot;</span>)  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈一谈学习Golang的想法是如何产生的</title>
      <link href="/archives/41079645.html"/>
      <url>/archives/41079645.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习go之前的一些七七八八的想法"><a href="#学习go之前的一些七七八八的想法" class="headerlink" title="学习go之前的一些七七八八的想法"></a>学习go之前的一些七七八八的想法</h1><p>​    因为在大一大二主要是学习一些算法。并没有接触到什么非常有技术的东西。而今上了大三，依旧是学习的是学校那一套，走java路线。学会了javaweb里面的相关技术，JDBC,Mybatis等，也了解了springboot框架，但是学的时候发现java这个体系真的是非常庞大。作为一个双非一本的本科生，感觉这样学下去出去的竞争力真的好小，于是我看到了GO!!!</p><p>​    在学习Go之前查阅了不少资料视频介绍，发现中国的go开发大概占17%左右，而且相当一部分是大厂，（这意味着我必须全力投入才可能找到一份工作）。岗位最多的还是java这个老大哥。但是这并不会直接劝退我。</p><p>​    我又找了很多关于go的介绍，介绍了go的各种优点（高并发、简单易懂、支持回收、跨平台等等），也有一些缺点（开源社区支持度有点低）。</p><p>​    但是通过这些，我越来越觉得go是一个大趋势，我不想浪费掉我的时间去求稳，我想更好的利用自己的时间去学习一些新的知识（go）。加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 个人学习感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人学习感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是会话跟踪</title>
      <link href="/archives/cc74ea10.html"/>
      <url>/archives/cc74ea10.html</url>
      
        <content type="html"><![CDATA[<h1 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h1><ul><li><p><strong>会话</strong>:用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。</p></li><li><p><strong>会话跟踪</strong>:一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间<strong>共享数据</strong>。</p></li><li><p>HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享。</p></li><li><p>实现方式:</p><ol><li>客户端会话跟踪技术:Cookie</li><li>服务端会话跟踪技术: Session</li></ol></li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie的实现是基于HTTP协议的</p><ul><li>响应头: set-cookie</li><li>请求头: cookie</li></ul><p><strong>Cookie存活时间</strong><br>默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁<br>setMaxAge(int seconds)：<strong>设置Cookie存活时间</strong></p><ol><li><p>正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除</p></li><li><p>负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁</p></li><li>零：删除对应Cookie</li></ol><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>服务端会话跟踪技术：将数据保存到服务端</p><p>JavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能使用:</p><ol><li>获取Session对象HttpSession session = request.getSession();</li><li>Session对象功能:<ul><li>void setAttribute(String name, Object o)：存储数据到session域中</li><li>Object getAttribute(String name)：根据key，获取值</li><li>void removeAttribute(String name)：根据key，删除该键值对</li></ul></li></ol><p><strong>Session是基于Cookie的</strong></p><p>Session钝化、活化:</p><p>服务器重启后，Session中的数据是否还在?</p><ul><li>钝化：在服务器正常关闭后， Tomcat会自动将Session数据写入硬盘的文件中</li><li>活化：再次启动服务器后，从文件中加载数据到Session中</li></ul><p>Cookie和Session都是来完成一次会话内多次请求间数据共享的</p><p>区别:</p><ul><li>存储位置:Cookie是将数据存储在客户端，Session将数据存储在服务端</li><li>安全性:Cookie不安全，Session安全</li><li>数据大小: Cookie最大3KB，Session无大小限制</li><li>存储时间:Cookie可以长期存储，Session 默认30分钟</li><li>服务器性能: Cookie不占服务器资源，Session占用服务器资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP</title>
      <link href="/archives/78b18e67.html"/>
      <url>/archives/78b18e67.html</url>
      
        <content type="html"><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h2><p>JSP脚本用于在JSP页面内定义Java代码</p><p>JSP脚本分类:</p><ol><li>&lt;%…%&gt;:内容会直接放到_jspService()方法之中</li><li>&lt;%=..%&gt;:内容会放到out.print()中，作为out.print()的参数.</li><li>&lt;%!..%&gt;:内容会放到_jspService()方法之外,被类直接包含.</li></ol><h2 id="JSP缺点"><a href="#JSP缺点" class="headerlink" title="JSP缺点"></a>JSP缺点</h2><p>由于JSP页面内，既可以定义HTML标签，又可以定义Java代码，造成了以下问题:</p><ol><li>书写麻烦：特别是复杂的页面。</li><li>阅读麻烦。</li><li>复杂度高：运行需要依赖于各种环境，JRE，JSP容器，JavaEE…</li><li>占内存和磁盘：JSP会自动生成.java和.class文件占磁盘，运行的是.class文件占内存。</li><li>调试困难：出错后，需要找到自动生成的.java文件进行调试。</li><li>不利于团队协作：前端人员不会Java，后端人员不精HTML。</li></ol><p>jsp已经比较老了，可替换成html+ajax</p><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><ul><li><p>Expression Language表达式语言，用于简化JSP页面内的Java代码</p></li><li><p>主要功能:获取数据</p></li><li><p>语法:${expression}</p><p>${brands}：获取域中存储的key为brands的数据</p></li><li><p>JavaWeb中的四大域对象:</p><ol><li>page:当前页面有效</li><li>request:当前请求有效</li><li>session:当前会话有效</li><li>application:当前应用有效</li></ol></li></ul><p>el表达式获取数据，会依次从这4个域中寻找，直到找到为止</p><h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h2><p>MVC是一种分层开发的模式，其中:</p><ul><li><p>M: Model，业务模型，处理业务</p></li><li><p>V: View，视图，界面展示</p></li><li>C: Controller，控制器，处理请求，调用模型和视图</li></ul><p><strong>MVC好处</strong></p><ul><li>职责单一，互不影响</li><li>有利于分工协作</li><li>有利于组件重用</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221110163134521.png" alt="image-20221110163134521"></p><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><ul><li><p>数据访问层:对数据库的CRUD基本操作</p></li><li><p>业务逻辑层:对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能</p></li><li><p>表现层:接收请求，封装数据，调用业务逻辑层，响应数据</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221111194620652.png" alt="image-20221111194620652"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Request和Response</title>
      <link href="/archives/ac012cb0.html"/>
      <url>/archives/ac012cb0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Request-请求-和Response-响应"><a href="#Request-请求-和Response-响应" class="headerlink" title="Request(请求)和Response(响应)"></a>Request(请求)和Response(响应)</h1><ul><li>Request：获取请求数据</li><li>Response：设置响应数据 </li></ul><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="Request继承体系"><a href="#Request继承体系" class="headerlink" title="Request继承体系"></a>Request继承体系</h3><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221107160322199.png" alt="image-20221107160322199"></p><ol><li>Tomcat需要解析请求数据，封装为request对象，并且创建request对象传递到service方法中</li><li>使用request对象，查阅JavaEE API文档的HttpServletRequest接口</li></ol><h3 id="Request获取请求数据"><a href="#Request获取请求数据" class="headerlink" title="Request获取请求数据"></a>Request获取请求数据</h3><ol><li>请求行:  GET /request-demo/req1?username=zhangsan HTTP/1.1<ul><li>String getMethod()：获取请求方式:GET</li><li>String getContextPath()：获取虚拟目录(项目访问路径):/request-demo</li><li>StringBuffer getRequestURLO：获取URL(统一资源定位符): <a href="http://localhost:8080/request-demo/req1">http://localhost:8080/request-demo/req1</a></li><li>String getRequestURI()：获取URI(统一资源标识符)：/request-demo/req1</li><li>String getQueryString()：获取请求参数(GET方式)：username=zhangsan&amp;password=123</li></ul></li><li>请求头：User-Agent: Mozilla/5.0 Chrome/91.0.4472.106<ul><li>String getHeader(String name):根据请求头名称，获取值</li></ul></li><li>请求体：username=superbaby&amp;password=123<ul><li>ServletInputStream getlnputStream()：获取字节输入流</li><li>BufferedReader getReader()：获取字符输入流</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求行部分</span></span><br><span class="line">        <span class="comment">// 获取请求方式：GET</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取虚拟目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> req.getContextPath();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取URL</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取URI</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queryString</span> <span class="operator">=</span> req.getQueryString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//--------请求头部分</span></span><br><span class="line">        <span class="comment">// 获取请求头：user-agent:浏览器版本信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;user-agent&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(method);</span><br><span class="line">        System.out.println(contextPath);</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        System.out.println(uri);</span><br><span class="line">        System.out.println(queryString);</span><br><span class="line">        System.out.println(header);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求体：</span></span><br><span class="line">        <span class="comment">// 获取字符输入流：</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> req.getReader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(line); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221107162825291.png" alt="image-20221107162825291"></p><h3 id="Request通用方式获取请求参数"><a href="#Request通用方式获取请求参数" class="headerlink" title="Request通用方式获取请求参数"></a>Request通用方式获取请求参数</h3><ul><li>Map<String, String[]>getParameterMap()：获取所有参数Map集合</li><li>String[]  getParameterValues(String name)∶根据名称获取参数值（数组)</li><li>String getParameter(String name)：根据名称获取参数值（单个值)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Map集合</span></span><br><span class="line">        Map&lt;String, String[]&gt; map = req.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet()) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;: &quot;</span>);</span><br><span class="line">            String[] values = map.get(key);</span><br><span class="line">            <span class="keyword">for</span>(String val : values)&#123;</span><br><span class="line">                System.out.print(val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更具key获取参数</span></span><br><span class="line">        String[] hobbies = req.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String hobby : hobbies) &#123;</span><br><span class="line">            System.out.print(hobby + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取单个值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>解决中文乱码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// post解决：设置字符输入流编码</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// get方式因为浏览器编码方式是UTF-8而tomcat解码方式是ISO-8859-1，导致乱码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.url编码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> URLEncoder.encode(username, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.url解码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">decode</span> <span class="operator">=</span> URLDecoder.decode(encode, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.转化为字节数据</span></span><br><span class="line"><span class="type">byte</span>[] bytes = decode.get(<span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.将字节数据转化成字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;utf-8&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// get解决：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">username = <span class="keyword">new</span> <span class="title class_">String</span>(username.get(StandarCharsets.ISO_8859_1), StanderCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221107172108277.png" alt="image-20221107172108277"></p><h3 id="Request请求转发"><a href="#Request请求转发" class="headerlink" title="Request请求转发"></a>Request请求转发</h3><ul><li>请求转发(forward)：一种在服务器内部的资源跳转方式。</li><li>实现方式：req.getRequestDispatcher(“资源B路径”).forward(req,resp);</li><li>请求转发资源间共享数据：使用Request对象<ul><li>void setAttribute(String name, Object o)：存储数据到request域中</li><li>Object getAttribute(String name)：根据key，获取值</li><li>void removeAttribute(String name)：根据key，删除该键值对</li></ul></li><li>请求转发特点:<ul><li>浏览器地址栏路径不发生变化</li><li>只能转发到当前服务器的内部资源</li><li>一次请求，可以在转发的资源间使用request共享数据</li></ul></li></ul><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="Response设置响应数据功能介绍"><a href="#Response设置响应数据功能介绍" class="headerlink" title="Response设置响应数据功能介绍"></a>Response设置响应数据功能介绍</h3><p>响应数据分为3部分:</p><ol><li><p>响应行:HTTP/1.1 200 OK<br>void setStatus(int sc)∶设置响应状态码</p></li><li><p>响应头: Content-Type: text/html<br>void setHeader(String name, String value)∶设置响应头键值对</p></li><li><p>响应体:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PrintWriter getWriter():获取字符输出流<br>ServletOutputStream getOutputStream():获取字节输出流</p></li></ol><h3 id="Response重定向"><a href="#Response重定向" class="headerlink" title="Response重定向"></a>Response重定向</h3><p><strong>重定向是一种资源跳转的方式，与转发有很大的区别</strong></p><p><strong>重定向流程</strong>：浏览器请求资源A，资源A响应（我处理不了，找别人处理《状态码：302 》，那个人的位置是xx）然后浏览器自动请求资源B</p><p><strong>转发</strong>：浏览器请求资源A，资源处理数据资源将数据转发给资源B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 重定向</span></span><br><span class="line"><span class="comment">//        // 设置响应状态码302</span></span><br><span class="line"><span class="comment">//        response.setStatus(302);</span></span><br><span class="line"><span class="comment">//        // 设置响应头</span></span><br><span class="line"><span class="comment">//        response.setHeader(&quot;Location&quot;, &quot;/servlet_demo1_war/resp2&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化方式完成重定向</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;/servlet_demo1_war/resp2&quot;</span>);</span><br></pre></td></tr></table></figure><p>重定向特点:</p><ul><li>浏览器地址栏路径发生变化</li><li>可以重定向到任意位置的资源（服务器内部、外部均可)</li><li>两次请求，不能在多个资源使用request共享数据</li></ul><h3 id="重定向与转发比较"><a href="#重定向与转发比较" class="headerlink" title="重定向与转发比较"></a>重定向与转发比较</h3><ul><li><strong>请求转发</strong>：客户浏览器发送http请求,web服务器接受此请求,调用内部的一个方法在容器内部完成请求处理和转发动作,将目标资源发送给客户;在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。</li><li><strong>重定向过程</strong>：客户浏览器发送http请求,web服务器接受后发送302状态码响应及对应新的location给客户浏览器,客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址,服务器根据此请求寻找资源并发送给客户。在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。</li></ul><div class="table-container"><table><thead><tr><th>区别</th><th>重定向</th><th>请求转发</th></tr></thead><tbody><tr><td>在哪里完成</td><td>客户端完成(可以在不同的服务器下完成)</td><td>服务器端完成(必须是在同一台服务器下完成)</td></tr><tr><td>浏览器发送请求的次数</td><td>2次或者2次以上</td><td>1次</td></tr><tr><td>地址栏URL是否发生改变</td><td>地址栏发生变化</td><td>地址栏的地址不变</td></tr><tr><td>是否共享request</td><td>不共享数据(经过重定向后，request内的对象将无法使用)</td><td>共享数据(以前的request中存放的变量不会失效，就像把两个页面拼到了一起)</td></tr><tr><td>第二次请求发起者</td><td>浏览器</td><td>服务器</td></tr><tr><td>第二次的请求路径方式</td><td>绝对路径</td><td>相对路径</td></tr><tr><td>速度</td><td>因为还要浏览器发送第二次请求，重定向相对慢一点</td><td>快</td></tr><tr><td>语句</td><td>response.sendRedirect(“success.jsp”);</td><td>request.getRequestDispatcher(“success.jsp”).forward(request,response);</td></tr></tbody></table></div><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221107194350119.png" alt="image-20221107194350119"></p><h3 id="Response响应字符"><a href="#Response响应字符" class="headerlink" title="Response响应字符"></a>Response响应字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">       <span class="comment">// 1.获取字符串输出流</span></span><br><span class="line">       <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// content-type,设置头</span></span><br><span class="line">       <span class="comment">// response.setHeader(&quot;content-type&quot;, &quot;text/html&quot;);</span></span><br><span class="line"></span><br><span class="line">       writer.write(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">       writer.write(<span class="string">&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Response响应字节"><a href="#Response响应字节" class="headerlink" title="Response响应字节"></a>Response响应字节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1.读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C://Users//jpc//Desktop//OldDesktop//5.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取response字节输出流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.完成流的copy</span></span><br><span class="line"><span class="comment">//        byte[] buff = new byte[1024];</span></span><br><span class="line"><span class="comment">//        int len = 0;</span></span><br><span class="line"><span class="comment">//        while((len = fis.read(buff)) != -1) &#123;</span></span><br><span class="line"><span class="comment">//            os.write(buff, 0, len);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        IOUtils.copy(fis, os);</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> Servlet </tag>
            
            <tag> Request </tag>
            
            <tag> Response </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet笔记</title>
      <link href="/archives/bc07bc32.html"/>
      <url>/archives/bc07bc32.html</url>
      
        <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="servlet入门"><a href="#servlet入门" class="headerlink" title="servlet入门"></a>servlet入门</h2><ol><li><p>创建web项目，导入Servlet依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupld</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建:定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置:在类上使用@WebServlet注解，配置该Servlet的访问路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问:启动Tomcat，浏览器输入URL访问该Servlet：<a href="http://localhost:8080/web-demo/demo1">http://localhost:8080/web-demo/demo1</a></p></li></ol><h2 id="Servlet执行流程"><a href="#Servlet执行流程" class="headerlink" title="Servlet执行流程"></a>Servlet执行流程</h2><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221106002700469.png" alt="image-20221106002700469"></p><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><ul><li><p>对象的生命周期指一个对象从被创建到被销毁的整个过程。</p></li><li><p>Servlet运行在servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段:</p><ol><li><strong>加载和实例化</strong>：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象。</li><li><strong>初始化</strong>：在Servlet实例化之后，容器将调用Servlet的 init() 方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次。</li><li><strong>请求处理</strong>：每次请求servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理。</li><li><strong>服务终止</strong>：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收。</li></ol></li></ul><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * 1. 调用时机：默认情况下,Servlet被第一次访问的时候调用</span></span><br><span class="line"><span class="comment">     *          loadOnStartup: 默认是启动时创建，可以设置为1（提前创建）</span></span><br><span class="line"><span class="comment">     * 2. 调用次数：1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供服务</span></span><br><span class="line"><span class="comment">     * 1. 调用时机：每次访问时调用</span></span><br><span class="line"><span class="comment">     * 2. 调用次数：多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet hello ~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法：</span></span><br><span class="line"><span class="comment">     * 1. 调用时机：内存释放的时候或者服务器关闭的时候，Servlet对象会被销毁</span></span><br><span class="line"><span class="comment">     * 2. 调用次数：1次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet的urlPattern配置"><a href="#Servlet的urlPattern配置" class="headerlink" title="Servlet的urlPattern配置"></a>Servlet的urlPattern配置</h2><ol><li>精确匹配：<ul><li>配置路径：@WebServlet(“/user/select”)</li><li>访问路径：localhost:8080/web-demo/user/select</li></ul></li><li>目录匹配:<ul><li>配置路径：@WebServlet( “/user/*”)</li><li>访问路径：localhost:8080/web-demd/user/aaa，localhost:8080/web-demd/user/bbb</li></ul></li><li>扩展名匹配:<ul><li>配置路径：@WebServlet( “*.do” )</li><li>访问路径：localhost:8080/web-demo/aaa.do，localhost:8080/web-demo/bbb.do</li></ul></li><li>任意匹配<ul><li>配置路径：@WebServlet(“/“)，@WebServlet(“/*”)</li><li>访问路径：localhost:8080/web-demo/hhh</li><li>/和/*区别:<ul><li>当我们的项目中的Servlet配置了“/”，会覆盖掉tomcat中的DefaultServlet，当其他的url-pattern都匹配不上时都会走这个Servlet.</li><li>当我们的项目中配置了“/*”，意味着匹配任意访问路径</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="/archives/95ecbeba.html"/>
      <url>/archives/95ecbeba.html</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Web服务器<br>Web服务器是一个应该程序（软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让web开发更加便捷。主要功能是“提供网上信息浏览服务”。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221104225648283.png" alt="image-20221104225648283"></p><ul><li><strong>概念:</strong> Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻最级Web服务器，支持Servlet/SP少量JavaEE规范。</li><li>JavaEE： Java Enterprise Edition，Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范:JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java lDL、JTS、JTA、JavaMail、JAF。</li><li>Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖于Tomcat才能运行。</li><li>官网: <a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a></li></ul><ol><li><p>Web服务器作用?</p><p>封装HTTP协议操作，简化开发.<br>可以将web项目部署到服务器中，对外提供网上浏览服务.</p></li><li><p>Tomcat是一个轻量级的Web服务器，支持Servlet/JSP少量JavaEE规范，也称为Web容器，Servlet容器</p></li></ol><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221105223710126.png" alt="image-20221105223710126"></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> Tomcat </tag>
            
            <tag> Web服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="/archives/af3eed3c.html"/>
      <url>/archives/af3eed3c.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP：超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p><h2 id="HTTP协议特点"><a href="#HTTP协议特点" class="headerlink" title="HTTP协议特点"></a>HTTP协议特点</h2><ol><li>基于TCP协议：面向连接，安全。</li><li>基于请求-响应模型的：一次请求对应一次响应。</li><li>HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的。<br>缺点：多次请求间不能共享数据。<br>优点：速度快。</li></ol><h2 id="HTTP-请求数据格式"><a href="#HTTP-请求数据格式" class="headerlink" title="HTTP-请求数据格式"></a>HTTP-请求数据格式</h2><p>请求数据分为3部分:</p><ol><li>请求行：请求数据的第一行。其中GET表示请求方式 ，/ 表示请求资源路径，HTTP/1.1表示协议版本。</li><li>请求头：第二行开始，格式为key: value形式。</li><li>请求体：POST请求的最后一部分，存放请求参数。</li></ol><p>常见的HTTP请求头:</p><ul><li>Host：表示请求的主机名</li><li>User-Agent：浏览器版本，例如Chrome浏览器的标识类似Mozilla/5.0 …Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT …) like Gecko;</li><li>Accept：表示浏览器能接收的资源类型，如text/<em>，image/</em>或者<em>/</em>表示所有;</li><li>Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页;</li><li>Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</li></ul><p>GET请求和POST请求区别:</p><ul><li>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</li><li>get 请求只支持 URL 编码，post 请求支持多种编码格式。</li><li>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li><li>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制。</li><li>get请求请求参数在请求行中，没有请求体。post请求请求参数在请求体中。</li><li>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</li><li>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。</li></ul><h2 id="HTTP-响应数据格式"><a href="#HTTP-响应数据格式" class="headerlink" title="HTTP-响应数据格式"></a>HTTP-响应数据格式</h2><p>响应数据分为3部分:</p><ol><li>响应行：响应数据的第一行。其中HTTP/1.1表示协议版本，200表示响应状态码，OK表示状态码描述。</li><li>响应头：第二行开始，格式为key：value形式</li><li>响应体：最后一部分。存放响应数据。</li></ol><p>状态码查询网站：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaweb学习以及相关框架使用</title>
      <link href="/archives/2615dbfd.html"/>
      <url>/archives/2615dbfd.html</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb技术栈"><a href="#JavaWeb技术栈" class="headerlink" title="JavaWeb技术栈"></a>JavaWeb技术栈</h1><ul><li><strong>B/S架构</strong>： Browser/Server，浏览器/服务器架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。</li><li><strong>好处</strong>：易于维护升级，服务器端升级后，客户端无需任何部署就可以使用到新的版本。</li><li><strong>静态资源</strong>：HTML、CSS、JavaScript、图片等。负责页面展现。</li><li><strong>动态资源</strong>：Servlet、JSP等。负责逻辑处理。</li><li><strong>数据库</strong>：负责存储数据。</li><li><strong>HTTP协议</strong>：定义通信规则。</li><li><strong>Web服务器</strong>：负责解析HTTP协议，解析请求数据，并发送响应数据。</li></ul><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP：超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p><h2 id="HTTP协议特点"><a href="#HTTP协议特点" class="headerlink" title="HTTP协议特点"></a>HTTP协议特点</h2><ol><li>基于TCP协议：面向连接，安全。</li><li>基于请求-响应模型的：一次请求对应一次响应。</li><li>HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的。<br>缺点：多次请求间不能共享数据。<br>优点：速度快。</li></ol><h2 id="HTTP-请求数据格式"><a href="#HTTP-请求数据格式" class="headerlink" title="HTTP-请求数据格式"></a>HTTP-请求数据格式</h2><p>请求数据分为3部分:</p><ol><li>请求行：请求数据的第一行。其中GET表示请求方式 ，/ 表示请求资源路径，HTTP/1.1表示协议版本。</li><li>请求头：第二行开始，格式为key: value形式。</li><li>请求体：POST请求的最后一部分，存放请求参数。</li></ol><p>常见的HTTP请求头:</p><ul><li>Host：表示请求的主机名</li><li>User-Agent：浏览器版本，例如Chrome浏览器的标识类似Mozilla/5.0 …Chrome/79，IE浏览器的标识类似Mozilla/5.0 (Windows NT …) like Gecko;</li><li>Accept：表示浏览器能接收的资源类型，如text/<em>，image/</em>或者<em>/</em>表示所有;</li><li>Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页;</li><li>Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</li></ul><p>GET请求和POST请求区别:</p><ul><li>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</li><li>get 请求只支持 URL 编码，post 请求支持多种编码格式。</li><li>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li><li>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制。</li><li>get请求请求参数在请求行中，没有请求体。post请求请求参数在请求体中。</li><li>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</li><li>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。</li></ul><h2 id="HTTP-响应数据格式"><a href="#HTTP-响应数据格式" class="headerlink" title="HTTP-响应数据格式"></a>HTTP-响应数据格式</h2><p>响应数据分为3部分:</p><ol><li>响应行：响应数据的第一行。其中HTTP/1.1表示协议版本，200表示响应状态码，OK表示状态码描述。</li><li>响应头：第二行开始，格式为key：value形式</li><li>响应体：最后一部分。存放响应数据。</li></ol><p>状态码查询网站：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a></p><h1 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h1><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Web服务器<br>Web服务器是一个应该程序（软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让web开发更加便捷。主要功能是“提供网上信息浏览服务”。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221104225648283.png" alt="image-20221104225648283"></p><ul><li><strong>概念:</strong> Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻最级Web服务器，支持Servlet/SP少量JavaEE规范。</li><li>JavaEE： Java Enterprise Edition，Java企业版。指Java企业级开发的技术规范总和。包含13项技术规范:JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java lDL、JTS、JTA、JavaMail、JAF。</li><li>Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖于Tomcat才能运行。</li><li>官网: <a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a></li></ul><ol><li><p>Web服务器作用?</p><p>封装HTTP协议操作，简化开发.<br>可以将web项目部署到服务器中，对外提供网上浏览服务.</p></li><li><p>Tomcat是一个轻量级的Web服务器，支持Servlet/JSP少量JavaEE规范，也称为Web容器，Servlet容器</p></li></ol><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221105223710126.png" alt="image-20221105223710126"></p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="servlet入门"><a href="#servlet入门" class="headerlink" title="servlet入门"></a>servlet入门</h2><ol><li><p>创建web项目，导入Servlet依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupld</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建:定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置:在类上使用@WebServlet注解，配置该Servlet的访问路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问:启动Tomcat，浏览器输入URL访问该Servlet：<a href="http://localhost:8080/web-demo/demo1">http://localhost:8080/web-demo/demo1</a></p></li></ol><h2 id="Servlet执行流程"><a href="#Servlet执行流程" class="headerlink" title="Servlet执行流程"></a>Servlet执行流程</h2><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221106002700469.png" alt="image-20221106002700469"></p><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><ul><li><p>对象的生命周期指一个对象从被创建到被销毁的整个过程。</p></li><li><p>Servlet运行在servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段:</p><ol><li><strong>加载和实例化</strong>：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象。</li><li><strong>初始化</strong>：在Servlet实例化之后，容器将调用Servlet的 init() 方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次。</li><li><strong>请求处理</strong>：每次请求servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理。</li><li><strong>服务终止</strong>：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收。</li></ol></li></ul><p>测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * 1. 调用时机：默认情况下,Servlet被第一次访问的时候调用</span></span><br><span class="line"><span class="comment">     *          loadOnStartup: 默认是启动时创建，可以设置为1（提前创建）</span></span><br><span class="line"><span class="comment">     * 2. 调用次数：1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供服务</span></span><br><span class="line"><span class="comment">     * 1. 调用时机：每次访问时调用</span></span><br><span class="line"><span class="comment">     * 2. 调用次数：多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet hello ~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法：</span></span><br><span class="line"><span class="comment">     * 1. 调用时机：内存释放的时候或者服务器关闭的时候，Servlet对象会被销毁</span></span><br><span class="line"><span class="comment">     * 2. 调用次数：1次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet的urlPattern配置"><a href="#Servlet的urlPattern配置" class="headerlink" title="Servlet的urlPattern配置"></a>Servlet的urlPattern配置</h2><ol><li>精确匹配：<ul><li>配置路径：@WebServlet(“/user/select”)</li><li>访问路径：localhost:8080/web-demo/user/select</li></ul></li><li>目录匹配:<ul><li>配置路径：@WebServlet( “/user/*”)</li><li>访问路径：localhost:8080/web-demd/user/aaa，localhost:8080/web-demd/user/bbb</li></ul></li><li>扩展名匹配:<ul><li>配置路径：@WebServlet( “*.do” )</li><li>访问路径：localhost:8080/web-demo/aaa.do，localhost:8080/web-demo/bbb.do</li></ul></li><li>任意匹配<ul><li>配置路径：@WebServlet(“/“)，@WebServlet(“/*”)</li><li>访问路径：localhost:8080/web-demo/hhh</li><li>/和/*区别:<ul><li>当我们的项目中的Servlet配置了“/”，会覆盖掉tomcat中的DefaultServlet，当其他的url-pattern都匹配不上时都会走这个Servlet.</li><li>当我们的项目中配置了“/*”，意味着匹配任意访问路径</li></ul></li></ul></li></ol><h1 id="Request-请求-和Response-响应"><a href="#Request-请求-和Response-响应" class="headerlink" title="Request(请求)和Response(响应)"></a>Request(请求)和Response(响应)</h1><ul><li>Request：获取请求数据</li><li>Response：设置响应数据 </li></ul><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="Request继承体系"><a href="#Request继承体系" class="headerlink" title="Request继承体系"></a>Request继承体系</h3><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221107160322199.png" alt="image-20221107160322199"></p><ol><li>Tomcat需要解析请求数据，封装为request对象，并且创建request对象传递到service方法中</li><li>使用request对象，查阅JavaEE API文档的HttpServletRequest接口</li></ol><h3 id="Request获取请求数据"><a href="#Request获取请求数据" class="headerlink" title="Request获取请求数据"></a>Request获取请求数据</h3><ol><li>请求行:  GET /request-demo/req1?username=zhangsan HTTP/1.1<ul><li>String getMethod()：获取请求方式:GET</li><li>String getContextPath()：获取虚拟目录(项目访问路径):/request-demo</li><li>StringBuffer getRequestURLO：获取URL(统一资源定位符): <a href="http://localhost:8080/request-demo/req1">http://localhost:8080/request-demo/req1</a></li><li>String getRequestURI()：获取URI(统一资源标识符)：/request-demo/req1</li><li>String getQueryString()：获取请求参数(GET方式)：username=zhangsan&amp;password=123</li></ul></li><li>请求头：User-Agent: Mozilla/5.0 Chrome/91.0.4472.106<ul><li>String getHeader(String name):根据请求头名称，获取值</li></ul></li><li>请求体：username=superbaby&amp;password=123<ul><li>ServletInputStream getlnputStream()：获取字节输入流</li><li>BufferedReader getReader()：获取字符输入流</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求行部分</span></span><br><span class="line">        <span class="comment">// 获取请求方式：GET</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取虚拟目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> req.getContextPath();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取URL</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">url</span> <span class="operator">=</span> req.getRequestURL();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取URI</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queryString</span> <span class="operator">=</span> req.getQueryString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//--------请求头部分</span></span><br><span class="line">        <span class="comment">// 获取请求头：user-agent:浏览器版本信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> req.getHeader(<span class="string">&quot;user-agent&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(method);</span><br><span class="line">        System.out.println(contextPath);</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        System.out.println(uri);</span><br><span class="line">        System.out.println(queryString);</span><br><span class="line">        System.out.println(header);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求体：</span></span><br><span class="line">        <span class="comment">// 获取字符输入流：</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> req.getReader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(line); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221107162825291.png" alt="image-20221107162825291"></p><h3 id="Request通用方式获取请求参数"><a href="#Request通用方式获取请求参数" class="headerlink" title="Request通用方式获取请求参数"></a>Request通用方式获取请求参数</h3><ul><li>Map<String, String[]>getParameterMap()：获取所有参数Map集合</li><li>String[]  getParameterValues(String name)∶根据名称获取参数值（数组)</li><li>String getParameter(String name)：根据名称获取参数值（单个值)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Map集合</span></span><br><span class="line">        Map&lt;String, String[]&gt; map = req.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet()) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;: &quot;</span>);</span><br><span class="line">            String[] values = map.get(key);</span><br><span class="line">            <span class="keyword">for</span>(String val : values)&#123;</span><br><span class="line">                System.out.print(val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更具key获取参数</span></span><br><span class="line">        String[] hobbies = req.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String hobby : hobbies) &#123;</span><br><span class="line">            System.out.print(hobby + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取单个值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>解决中文乱码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// post解决：设置字符输入流编码</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// get方式因为浏览器编码方式是UTF-8而tomcat解码方式是ISO-8859-1，导致乱码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.url编码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> URLEncoder.encode(username, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.url解码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">decode</span> <span class="operator">=</span> URLDecoder.decode(encode, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.转化为字节数据</span></span><br><span class="line"><span class="type">byte</span>[] bytes = decode.get(<span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.将字节数据转化成字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="string">&quot;utf-8&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// get解决：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">username = <span class="keyword">new</span> <span class="title class_">String</span>(username.get(StandarCharsets.ISO_8859_1), StanderCharsets.UTF_8);</span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221107172108277.png" alt="image-20221107172108277"></p><h3 id="Request请求转发"><a href="#Request请求转发" class="headerlink" title="Request请求转发"></a>Request请求转发</h3><ul><li>请求转发(forward)：一种在服务器内部的资源跳转方式。</li><li>实现方式：req.getRequestDispatcher(“资源B路径”).forward(req,resp);</li><li>请求转发资源间共享数据：使用Request对象<ul><li>void setAttribute(String name, Object o)：存储数据到request域中</li><li>Object getAttribute(String name)：根据key，获取值</li><li>void removeAttribute(String name)：根据key，删除该键值对</li></ul></li><li>请求转发特点:<ul><li>浏览器地址栏路径不发生变化</li><li>只能转发到当前服务器的内部资源</li><li>一次请求，可以在转发的资源间使用request共享数据</li></ul></li></ul><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="Response设置响应数据功能介绍"><a href="#Response设置响应数据功能介绍" class="headerlink" title="Response设置响应数据功能介绍"></a>Response设置响应数据功能介绍</h3><p>响应数据分为3部分:</p><ol><li><p>响应行:HTTP/1.1 200 OK<br>void setStatus(int sc)∶设置响应状态码</p></li><li><p>响应头: Content-Type: text/html<br>void setHeader(String name, String value)∶设置响应头键值对</p></li><li><p>响应体:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PrintWriter getWriter():获取字符输出流<br>ServletOutputStream getOutputStream():获取字节输出流</p></li></ol><h3 id="Response重定向"><a href="#Response重定向" class="headerlink" title="Response重定向"></a>Response重定向</h3><p><strong>重定向是一种资源跳转的方式，与转发有很大的区别</strong></p><p><strong>重定向流程</strong>：浏览器请求资源A，资源A响应（我处理不了，找别人处理《状态码：302 》，那个人的位置是xx）然后浏览器自动请求资源B</p><p><strong>转发</strong>：浏览器请求资源A，资源处理数据资源将数据转发给资源B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 重定向</span></span><br><span class="line"><span class="comment">//        // 设置响应状态码302</span></span><br><span class="line"><span class="comment">//        response.setStatus(302);</span></span><br><span class="line"><span class="comment">//        // 设置响应头</span></span><br><span class="line"><span class="comment">//        response.setHeader(&quot;Location&quot;, &quot;/servlet_demo1_war/resp2&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化方式完成重定向</span></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;/servlet_demo1_war/resp2&quot;</span>);</span><br></pre></td></tr></table></figure><p>重定向特点:</p><ul><li>浏览器地址栏路径发生变化</li><li>可以重定向到任意位置的资源（服务器内部、外部均可)</li><li>两次请求，不能在多个资源使用request共享数据</li></ul><h3 id="重定向与转发比较"><a href="#重定向与转发比较" class="headerlink" title="重定向与转发比较"></a>重定向与转发比较</h3><ul><li><strong>请求转发</strong>：客户浏览器发送http请求,web服务器接受此请求,调用内部的一个方法在容器内部完成请求处理和转发动作,将目标资源发送给客户;在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。</li><li><strong>重定向过程</strong>：客户浏览器发送http请求,web服务器接受后发送302状态码响应及对应新的location给客户浏览器,客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址,服务器根据此请求寻找资源并发送给客户。在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。</li></ul><div class="table-container"><table><thead><tr><th>区别</th><th>重定向</th><th>请求转发</th></tr></thead><tbody><tr><td>在哪里完成</td><td>客户端完成(可以在不同的服务器下完成)</td><td>服务器端完成(必须是在同一台服务器下完成)</td></tr><tr><td>浏览器发送请求的次数</td><td>2次或者2次以上</td><td>1次</td></tr><tr><td>地址栏URL是否发生改变</td><td>地址栏发生变化</td><td>地址栏的地址不变</td></tr><tr><td>是否共享request</td><td>不共享数据(经过重定向后，request内的对象将无法使用)</td><td>共享数据(以前的request中存放的变量不会失效，就像把两个页面拼到了一起)</td></tr><tr><td>第二次请求发起者</td><td>浏览器</td><td>服务器</td></tr><tr><td>第二次的请求路径方式</td><td>绝对路径</td><td>相对路径</td></tr><tr><td>速度</td><td>因为还要浏览器发送第二次请求，重定向相对慢一点</td><td>快</td></tr><tr><td>语句</td><td>response.sendRedirect(“success.jsp”);</td><td>request.getRequestDispatcher(“success.jsp”).forward(request,response);</td></tr></tbody></table></div><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221107194350119.png" alt="image-20221107194350119"></p><h3 id="Response响应字符"><a href="#Response响应字符" class="headerlink" title="Response响应字符"></a>Response响应字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">       <span class="comment">// 1.获取字符串输出流</span></span><br><span class="line">       <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// content-type,设置头</span></span><br><span class="line">       <span class="comment">// response.setHeader(&quot;content-type&quot;, &quot;text/html&quot;);</span></span><br><span class="line"></span><br><span class="line">       writer.write(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">       writer.write(<span class="string">&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Response响应字节"><a href="#Response响应字节" class="headerlink" title="Response响应字节"></a>Response响应字节</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1.读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C://Users//jpc//Desktop//OldDesktop//5.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.获取response字节输出流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.完成流的copy</span></span><br><span class="line"><span class="comment">//        byte[] buff = new byte[1024];</span></span><br><span class="line"><span class="comment">//        int len = 0;</span></span><br><span class="line"><span class="comment">//        while((len = fis.read(buff)) != -1) &#123;</span></span><br><span class="line"><span class="comment">//            os.write(buff, 0, len);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        IOUtils.copy(fis, os);</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br></pre></td></tr></table></figure><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h2><p>流程说明:</p><ol><li>用户填写用户名密码，提交到LoginServlet。</li><li>在LoginServlet中使用MyBatis查询数据库，验证用户名密码是否正确。</li><li>如果正确，响应“登录成功”，如果错误，响应“登录失败”。</li></ol><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221109173856537.png" alt="image-20221109173856537"></p><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="JSP简介"><a href="#JSP简介" class="headerlink" title="JSP简介"></a>JSP简介</h2><ul><li>概念:Java Server Pages，Java服务端页面。</li><li>一种动态的网页技术，其中既可以定义HTML、JS、CSS等静态内容，还可以定义Java代码的动态内容。</li><li>JSP = HTML + Java。</li><li>JSP的作用:简化开发，避免了在Servlet中直接输出HTML标签。</li></ul><h2 id="JSP原理"><a href="#JSP原理" class="headerlink" title="JSP原理"></a>JSP原理</h2><ul><li>概念: Java Server Pages，Java服务端页面</li><li>JSP = HTML + Java，用于简化开发的</li><li>JSP本质上就是一个Servlet</li><li><strong>JSP在被访问时，由JSP容器(Tomcat)将其转换为Java文件(Servlet)，在由JSP容器(Tomcat)将其编译，最终对外提供服务的其实就是这个字节码文件</strong></li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221110150447813.png" alt="image-20221110150447813"></p><h2 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h2><p>JSP脚本用于在JSP页面内定义Java代码</p><p>JSP脚本分类:</p><ol><li>&lt;%…%&gt;:内容会直接放到_jspService()方法之中</li><li>&lt;%=..%&gt;:内容会放到out.print()中，作为out.print()的参数.</li><li>&lt;%!..%&gt;:内容会放到_jspService()方法之外,被类直接包含.</li></ol><h2 id="JSP缺点"><a href="#JSP缺点" class="headerlink" title="JSP缺点"></a>JSP缺点</h2><p>由于JSP页面内，既可以定义HTML标签，又可以定义Java代码，造成了以下问题:</p><ol><li>书写麻烦：特别是复杂的页面。</li><li>阅读麻烦。</li><li>复杂度高：运行需要依赖于各种环境，JRE，JSP容器，JavaEE…</li><li>占内存和磁盘：JSP会自动生成.java和.class文件占磁盘，运行的是.class文件占内存。</li><li>调试困难：出错后，需要找到自动生成的.java文件进行调试。</li><li>不利于团队协作：前端人员不会Java，后端人员不精HTML。</li></ol><p>jsp已经比较老了，可替换成html+ajax</p><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><ul><li><p>Expression Language表达式语言，用于简化JSP页面内的Java代码</p></li><li><p>主要功能:获取数据</p></li><li><p>语法:${expression}</p><p>${brands}：获取域中存储的key为brands的数据</p></li><li><p>JavaWeb中的四大域对象:</p><ol><li>page:当前页面有效</li><li>request:当前请求有效</li><li>session:当前会话有效</li><li>application:当前应用有效</li></ol></li></ul><p>el表达式获取数据，会依次从这4个域中寻找，直到找到为止</p><h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h2><p>MVC是一种分层开发的模式，其中:</p><ul><li><p>M: Model，业务模型，处理业务</p></li><li><p>V: View，视图，界面展示</p></li><li>C: Controller，控制器，处理请求，调用模型和视图</li></ul><p><strong>MVC好处</strong></p><ul><li>职责单一，互不影响</li><li>有利于分工协作</li><li>有利于组件重用</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221110163134521.png" alt="image-20221110163134521"></p><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><ul><li><p>数据访问层:对数据库的CRUD基本操作</p></li><li><p>业务逻辑层:对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能</p></li><li><p>表现层:接收请求，封装数据，调用业务逻辑层，响应数据</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221111194620652.png" alt="image-20221111194620652"></p></li></ul><h1 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h1><ul><li><p><strong>会话</strong>:用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。</p></li><li><p><strong>会话跟踪</strong>:一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间<strong>共享数据</strong>。</p></li><li><p>HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享。</p></li><li><p>实现方式:</p><ol><li>客户端会话跟踪技术:Cookie</li><li>服务端会话跟踪技术: Session</li></ol></li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie的实现是基于HTTP协议的</p><ul><li>响应头: set-cookie</li><li>请求头: cookie</li></ul><p><strong>Cookie存活时间</strong><br>默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁<br>setMaxAge(int seconds)：<strong>设置Cookie存活时间</strong></p><ol><li><p>正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除</p></li><li><p>负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁</p></li><li>零：删除对应Cookie</li></ol><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>服务端会话跟踪技术：将数据保存到服务端</p><p>JavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能使用:</p><ol><li>获取Session对象HttpSession session = request.getSession();</li><li>Session对象功能:<ul><li>void setAttribute(String name, Object o)：存储数据到session域中</li><li>Object getAttribute(String name)：根据key，获取值</li><li>void removeAttribute(String name)：根据key，删除该键值对</li></ul></li></ol><p><strong>Session是基于Cookie的</strong></p><p>Session钝化、活化:</p><p>服务器重启后，Session中的数据是否还在?</p><ul><li>钝化：在服务器正常关闭后， Tomcat会自动将Session数据写入硬盘的文件中</li><li>活化：再次启动服务器后，从文件中加载数据到Session中</li></ul><p>Cookie和Session都是来完成一次会话内多次请求间数据共享的</p><p>区别:</p><ul><li>存储位置:Cookie是将数据存储在客户端，Session将数据存储在服务端</li><li>安全性:Cookie不安全，Session安全</li><li>数据大小: Cookie最大3KB，Session无大小限制</li><li>存储时间:Cookie可以长期存储，Session 默认30分钟</li><li>服务器性能: Cookie不占服务器资源，Session占用服务器资源</li></ul><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>概念:Filter表示过滤器，是JavaWeb三大组件(Servlet、Filter、Listener)之一。</p><p>过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。<br>过滤器一般完成一些通用的操作，比如:权限控制、统一编码处理、敏感字符处理等等。</p><h2 id="Filter执行流程"><a href="#Filter执行流程" class="headerlink" title="Filter执行流程"></a>Filter执行流程</h2><ol><li><p>放行后访问对应资源，资源访问完成后，还会回到Filter中。</p></li><li><p>如果回到Filter中，执行放行后的逻辑呢。<br>执行放行前逻辑——》放行——》访问资源——》执行放行后逻辑</p></li></ol><p><strong>一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。</strong></p><h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><p>概念: Listener表示监听器，是JavaWeb三大组件(Servlet、Filter、Listener)之一。</p><p>监听器可以监听就是在application,session,request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。<br>Listener分类: JavaWeb中提供了8个监听器</p><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>概念:AJAX(Asynchronous JavaScript And XML):异步的JavaScript和XMLAJAX作用:</p><ol><li>与服务器进行数据交换:通过AJAX可以给服务器发送请求，并获取服务器响应的数据<br>使用了AJAX和服务器进行通信，就可以使用HTML+AJAX来替换JSP页面了</li><li>异步交互:可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如:搜索联想、用<br>户名是否可用校验，等等..</li></ol><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221112161444010.png" alt="image-20221112161444010"></p><h2 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h2><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221112162039413.png" alt="image-20221112162039413"></p><h2 id="ajax创建流程"><a href="#ajax创建流程" class="headerlink" title="ajax创建流程"></a>ajax创建流程</h2><ol><li><p>创建核心对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span><br><span class="line">    xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code for IE6, IE5</span></span><br><span class="line">    xhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发送请求</p><p>open(<em>method</em>, <em>url</em>, <em>async</em>)</p><ul><li><em>method</em>：请求的类型：GET 还是 POST</li><li><em>url</em>：服务器（文件）位置</li><li><em>async</em>：true（异步）或 false（同步）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8080/ajax_1_war/ajaxServlet&quot;</span>);</span><br><span class="line">xhttp.<span class="title function_">send</span>(); <span class="comment">//向服务器发送请求（用于 GET）</span></span><br></pre></td></tr></table></figure></li><li><p>获取响应</p><p><code>onreadystatechange</code> 属性定义当 readyState 发生变化时执行的函数。</p><p><code>status</code> 属性和 <code>statusText</code> 属性存有 XMLHttpRequest 对象的状态。</p><p>readyState：保存了 XMLHttpRequest 的状态。</p><ul><li>0: 请求未初始化</li><li>1: 服务器连接已建立</li><li>2: 请求已接收</li><li>3: 正在处理请求</li><li>4: 请求已完成且响应已就绪</li></ul><p>status：200: “OK”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="AXIOS"><a href="#AXIOS" class="headerlink" title="AXIOS"></a>AXIOS</h2><ol><li><p>引入axios 的js 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span><span class="attr">js</span>/<span class="attr">axios-0.18.0.js</span>&quot;&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用axios 发送请求，并获取响应结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080lajax-demo1/aJAXDemo1&quot;</span>,<span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="Axios请求方式别名"><a href="#Axios请求方式别名" class="headerlink" title="Axios请求方式别名"></a>Axios请求方式别名</h3><p>axios.request(config)</p><p>axios.get(url[, config])</p><p>axios.delete(url[, config])</p><p>axios.head(url[, config])</p><p>axios.options(url[, config])</p><p>axios.post(url[, data[, config]])</p><p>axios.put(url[, data[, config]])</p><p>axios.patch(url[, data[, config]])</p><p>axios.getUri([config])</p><p>例如发送get请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;url&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>发送post请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;参数&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">resp</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>定义：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 = <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span>value1<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span>value2<span class="punctuation">,</span></span><br><span class="line">    ...</span><br><span class="line"><span class="punctuation">&#125;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line">var json  = <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;jpc&quot;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">21</span></span><br><span class="line">    <span class="attr">&quot;addr&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;武汉&quot;</span><span class="punctuation">,</span><span class="string">&quot;北京&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line">变量名.key</span><br></pre></td></tr></table></figure><p>value类型：浮点数，整数，对象，数组，字符串, 逻辑值，null</p><p><strong>JSON数据和Java对象转换</strong></p><p>请求数据:JSON字符串转为Java对象（反序列化）<br>响应数据:Java对象转为JSON字符串(序列化)</p><p><strong>fastjson的使用</strong></p><ol><li>导入坐标fastjson</li><li>java对象转JSON <code>String jsonStr = JSON.toJSONString(obj);</code></li><li>JSON字符串转java对象<code>User user = JSON.parseObject(jsonStr, User.class);</code></li></ol><h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><ul><li><p>Vue是一套前端框架，免除原生JavaScript中的DOM操作，简化书写。</p></li><li><p>基于MWVM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上。</p></li><li><p>官网: <a href="https://cn.vuejs.org">https://cn.vuejs.org</a></p></li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221114203603499.png" alt="image-20221114203603499"></p><h2 id="Vue常用指令"><a href="#Vue常用指令" class="headerlink" title="Vue常用指令"></a>Vue常用指令</h2><p>指令:HTML标签上带有v-前缀的特殊属性，不同指令具有不同含义。</p><div class="table-container"><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>v-bind</td><td>为HTML标签绑定属性值，如设置href , css样式</td></tr><tr><td>v-model</td><td>在表单元素上创建双向数据绑定</td></tr><tr><td>v-on</td><td>为HTML标签绑定事件</td></tr><tr><td>v-if</td><td>条件性的渲染某元素，判定为true时渲染,否则不渲染</td></tr><tr><td>v-else</td><td></td></tr><tr><td>v-else-if</td><td></td></tr><tr><td>v-show</td><td>根据条件展示某元素，区别在于切换的是display属性的值</td></tr><tr><td>v-for</td><td>列表渲染，遍历容器的元素或者对象的属性</td></tr></tbody></table></div><h2 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h2><p>生命周期的八个阶段:每触发一个生命周期事件，会自动执行一个生命周期方法(钩子)</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221114213806777.png" alt="image-20221114213806777"></p><h1 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h1><p><strong>总体来说类似于Bootstrap</strong></p><ul><li>Element:是饿了么公司前端开发团队提供的一套基于Vue的网站组件库，用于快速构建网页</li><li>组件:组成网页的部件，例如超链接、按钮、图片、表格等等～</li><li>自己完成的按钮</li></ul><h2 id="Element入门"><a href="#Element入门" class="headerlink" title="Element入门"></a>Element入门</h2><p>1.引入Element 的css、js文件和Vue.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;element-ui/liblindex.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;element-ui/lib/theme-chalk/index.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.创建Vue核心对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">el</span>:<span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.官网复制Element组件代码</p><h2 id="Element布局"><a href="#Element布局" class="headerlink" title="Element布局"></a>Element布局</h2><p>Element中有两种布局方式:</p><ol><li>Layout布局:通过基础的24分栏，迅速简便地创建布局。</li><li>Container布局容器:用于布局的容器组件，方便快速搭建页面的基本结构。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个SpringBoot的项目</title>
      <link href="/archives/f62366b.html"/>
      <url>/archives/f62366b.html</url>
      
        <content type="html"><![CDATA[<h1 id="整体的一个项目介绍"><a href="#整体的一个项目介绍" class="headerlink" title="整体的一个项目介绍"></a>整体的一个项目介绍</h1><h2 id="框架功能介绍"><a href="#框架功能介绍" class="headerlink" title="框架功能介绍"></a>框架功能介绍</h2><p><a href="https://git.acwing.com/jpc/kob">项目仓库地址</a></p><p><a href="https://www.jpcly.top/">项目运行地址</a></p><p>这个项目是基于SpringBoot+Vue3框架来完成的。这是一个蛇与蛇对战的游戏，实现了人人对战，人机对战，机机对战的功能。</p><p>实现流程：</p><ol><li>创建菜单与游戏界面。</li><li>登录注册等逻辑的实现。</li><li>通过<strong>微服务</strong>实现匹配系统（匹配池、以及实时对战）。</li><li>微服务Bot代码的执行。</li><li>排行榜的实现。</li></ol><h2 id="游戏规则介绍"><a href="#游戏规则介绍" class="headerlink" title="游戏规则介绍"></a>游戏规则介绍</h2><p>双方游戏开始时下方会有一个标记，表示你的位置在左下角还是右上角。当两方都有操作的的时候蛇才会动。</p><p>死亡条件：</p><ol><li>5秒内未执行操作。</li><li>撞上墙或撞上自己身体或撞上对方身体。</li></ol><h2 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h2><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220916165704465.png" alt="image-20220916165704465"></p><h2 id="匹配系统流程图"><a href="#匹配系统流程图" class="headerlink" title="匹配系统流程图"></a>匹配系统流程图</h2><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221011164503247.png" alt="image-20221011164503247"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/archives/1bff3c65.html"/>
      <url>/archives/1bff3c65.html</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="MyBatis概念"><a href="#MyBatis概念" class="headerlink" title="MyBatis概念"></a>MyBatis概念</h2><ul><li>MyBatis是一款优秀的持久层框架，用于<strong>简化JDBC开发</strong></li><li>MyBatis本是 Apache的一个开源项目iBatis, 2010年这个项目由apache softwarefoundation迁移到了google code，并且改名为MyBatis。2013年11月迁移到Github</li><li>官网:<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></li></ul><h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><ul><li>负责将数据到保存到数据库的那一层代码</li><li>avaEE三层架构:表现层、业务层、持久层</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li>框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型</li><li>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展</li></ul><h3 id="为什么简化"><a href="#为什么简化" class="headerlink" title="为什么简化"></a>为什么简化</h3><p><strong>简化jDBC</strong>：免除JDBC代码以及设置参数和获取结果集的工作。</p><p>JDBC存在的缺点：</p><ol><li>硬编码<ul><li>注册驱动，获取连接</li><li>SQL语句</li></ul></li><li>操作繁琐<ul><li>手动设置参数</li><li>手动封装结果集</li></ul></li></ol><h2 id="Mapper代理开发"><a href="#Mapper代理开发" class="headerlink" title="Mapper代理开发"></a>Mapper代理开发</h2><ol><li>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下</li><li>设置SQL映射文件的namespace属性为Mapper接口全限定名</li><li>在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值<br>类型一致</li><li>编码<ul><li>通过SqlSession的getMapper方法获取Mapper接口的代理对象</li><li>调用对应方法完成sql的执行</li><li>细节:如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取UserMapper接口的代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br><span class="line">System.out.println(users);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>UserMapper.xml配置文件内</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    namespace: 名称空间</span></span><br><span class="line"><span class="comment">id: 方法</span></span><br><span class="line"><span class="comment">resultType: 返回值类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.jpc.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.jpc.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">数据库表的字段名称和实体类的属性名称不一样，则不能自动封装数据</span></span><br><span class="line"><span class="comment">*起别名:对不一样的列名起别名，让别名和实体类的属性名一样</span></span><br><span class="line"><span class="comment">缺点:每次查询都要定义一次别名</span></span><br><span class="line"><span class="comment">sql片段缺点:不灵活</span></span><br><span class="line"><span class="comment">*resultMap:</span></span><br><span class="line"><span class="comment">定义&lt;resultMap&gt;标签</span></span><br><span class="line"><span class="comment">使用resultMap属性替换resultType属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">id: 完成主键字段的映射</span></span><br><span class="line"><span class="comment">column: 表的列名</span></span><br><span class="line"><span class="comment">property: 实体类的属性名</span></span><br><span class="line"><span class="comment">result: 完成一般字段的映射</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件完成增删改查"><a href="#配置文件完成增删改查" class="headerlink" title="配置文件完成增删改查"></a>配置文件完成增删改查</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">          参数占位符：</span></span><br><span class="line"><span class="comment">              1. #&#123;&#125;：会将其替换为？防止SQL注入</span></span><br><span class="line"><span class="comment">              2. $&#123;&#125;：拼接sql，会存在SQL注入问题</span></span><br><span class="line"><span class="comment">参数类型：parameterType(可以省略)</span></span><br><span class="line"><span class="comment">特殊字符处理：</span></span><br><span class="line"><span class="comment">1. 转移字符 如（&lt; 是&amp;lt;）</span></span><br><span class="line"><span class="comment">2. CDATA区 &lt;![CDATA[ &lt; ]]&gt;</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">          select *</span><br><span class="line">          from tb_brand where id = #&#123;id&#125;;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h4><p><strong>mapper接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(<span class="meta">@Param(&quot;status&quot;)</span> <span class="type">int</span> status, <span class="meta">@Param(&quot;companyName&quot;)</span> String companyName)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Brand brand)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：</span></span><br><span class="line">List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure><p><strong>调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="comment">// 接收的参数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数处理,因为是模糊查询</span></span><br><span class="line">companyName = <span class="string">&quot;%&quot;</span> + companyName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Brand&gt; brands = brandMapper.selectByCondition(status, companyName);</span><br><span class="line"></span><br><span class="line">System.out.println(brands);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="comment">// 接收的参数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数处理,模糊查询</span></span><br><span class="line">companyName = <span class="string">&quot;%&quot;</span> + companyName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装对象</span></span><br><span class="line"><span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">brand.setStatus(status);</span><br><span class="line">brand.setCompanyName(companyName);</span><br><span class="line"></span><br><span class="line">List&lt;Brand&gt; brands = brandMapper.selectByCondition(brand);</span><br><span class="line">System.out.println(brands);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：</span></span><br><span class="line"><span class="comment">// 接收的参数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数处理,模糊查询</span></span><br><span class="line">companyName = <span class="string">&quot;%&quot;</span> + companyName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装对象</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;status&quot;</span>, status);</span><br><span class="line">map.put(<span class="string">&quot;companyName&quot;</span>, companyName);</span><br><span class="line"></span><br><span class="line">List&lt;Brand&gt; brands = brandMapper.selectByCondition(map);</span><br><span class="line">System.out.println(brands);</span><br></pre></td></tr></table></figure><p><strong>mapper映射文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方法一：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    where</span><br><span class="line">    status = #&#123;status&#125;</span><br><span class="line">    and company_name like #&#123;companyName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--方法二三和方法一一样--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><p><strong>mapper接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure><p><strong>调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收的参数</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;小米有限公司&quot;</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">brandNmae</span> <span class="operator">=</span> <span class="string">&quot;红米&quot;</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;为烧焦而生&quot;</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">ordered</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">      brand.setStatus(status);</span><br><span class="line">      brand.setCompanyName(companyName);</span><br><span class="line">      brand.setBrandName(brandNmae);</span><br><span class="line">      brand.setOrdered(ordered);</span><br><span class="line">      brand.setDescription(description);</span><br><span class="line">brandMapper.add(brand);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 提交事务</span></span><br><span class="line"><span class="comment">// sqlSession.commit();</span></span><br></pre></td></tr></table></figure><p><strong>mapper映射文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">主键返回：在数据添加成功之后需要获取插入数据库主键的值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into tb_brand(brand_name, company_name, ordered, description, status)</span><br><span class="line">    values(#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p><strong>mapper接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Brand brand)</span>;</span><br></pre></td></tr></table></figure><p><strong>调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收的参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;小米有限公司&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">brandNmae</span> <span class="operator">=</span> <span class="string">&quot;红米&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;为发烧而生&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ordered</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Brand</span> <span class="variable">brand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Brand</span>();</span><br><span class="line">        brand.setStatus(status);</span><br><span class="line">        brand.setCompanyName(companyName);</span><br><span class="line">        brand.setBrandName(brandNmae);</span><br><span class="line">        brand.setOrdered(ordered);</span><br><span class="line">        brand.setDescription(description);</span><br><span class="line">        brand.setId(id);</span><br><span class="line"></span><br><span class="line"> brandMapper.update(brand);</span><br></pre></td></tr></table></figure><p><strong>mapper映射文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">      update tb_brand</span><br><span class="line">      <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">              brand_name = #&#123;brandName&#125;,</span><br><span class="line">          <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">              company_name = #&#123;companyName&#125;,</span><br><span class="line">          <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ordered != null and ordered != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">              ordered = #&#123;ordered&#125;,</span><br><span class="line">          <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;description != null and description != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">              description = #&#123;description&#125;,</span><br><span class="line">          <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null and status != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">              status = #&#123;status&#125;</span><br><span class="line">          <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">      where id = #&#123;id&#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><strong>mapper接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><p><strong>调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brandMapper.deleteById(id);</span><br></pre></td></tr></table></figure><p><strong>mapper映射文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">    delete from tb_brand where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="MyBatis参数传递"><a href="#MyBatis参数传递" class="headerlink" title="MyBatis参数传递"></a>MyBatis参数传递</h2><p>MyBatis 接口方法中可以接收各种各样的参数，MyBatis底层对于这些参数进行不同的封装处理方式&gt;</p><p>单个参数</p><ol><li>POJO类型</li><li>Map集合</li><li>Collection</li><li>List</li><li>Array</li><li>其他类型</li></ol><p>多个参数: 封装为Map集合，可以使用@Param注解</p><p>​    map.put(“arg0”, 参数1)</p><p>​    map.put(“param1”, 参数1)</p><p>​    map.put(“param2”, 参数2)</p><p>​    map.put(“arg1”, 参数2)</p><p>​    替换：@Param(“username”) —- &gt; map.put(“username”, 参数1)</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> JavaWeb </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven基础</title>
      <link href="/archives/195cf5d1.html"/>
      <url>/archives/195cf5d1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h1><ul><li><p>Maven是专门用于管理和构建Java项目的工具，它的主要功能有:</p><ul><li>提供了一套标准化的项目结构</li><li>提供了一套标准化的构建流程（编译，测试，打包，发布…..)</li><li>提供了一套依赖管理机制</li></ul></li></ul><p><strong>标准化的项目结构</strong></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221025195806435.png" alt="image-目录"></p><p><strong>标准构建流程</strong></p><p>编译=》测试=》打包=》发布</p><p><strong>依赖管理机制</strong></p><p>管理你项目所依赖的第三方资源(jar包、插件…)</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221025201437974.png" alt="image-模型"></p><h2 id="仓库分类"><a href="#仓库分类" class="headerlink" title="仓库分类"></a>仓库分类</h2><ul><li>本地仓库:自己计算机上的一个目录</li><li>中央仓库:由Maven团队维护的全球唯一的仓库<ul><li>地址: <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li></ul></li><li>远程仓库(私服):一般由公司团队搭建的私有仓库</li></ul><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包:<br>如果有，则在项目直接引用;<br>如果没有，则去中央仓库中下载对应的jar包到本地仓库。</p><h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><p>Maven构建项目生命周期描述的是一次构建过程经历经历了多少个事件Maven对项目构建的生命周期划分为3套</p><ul><li>clean:清理工作</li><li>default:核心工作，例如编译，测试，打包，安装等</li><li>site:产生报告，发布站点等</li></ul><p>同一生命周期内，执行后边的命令，前边的所有命令会自动执行。</p><h2 id="Maven-坐标"><a href="#Maven-坐标" class="headerlink" title="Maven 坐标"></a>Maven 坐标</h2><p>什么是坐标?<br>Maven 中的坐标是资源的唯一标识。<br>使用坐标来定义项目或引入项目中需要的依赖。</p><p>Maven坐标主要组成：</p><ul><li>groupld:定义当前Maven项目隶属组织名称（通常是域名反写)</li><li>artifactld:定义当前Maven项目名称(通常是模块名称)</li><li>version:定义当前项目版本号</li></ul><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>通过设置坐标的<strong>依赖范围(scope)</strong>，可以设置对应jar包的作用范围:编译环境、测试环境、运行环境</p><div class="table-container"><table><thead><tr><th>依赖范围</th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr><tr><td>import</td><td></td><td></td><td></td><td>引入DependencyManagement</td></tr></tbody></table></div><ul><li><scope>默认值: compile</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC基础</title>
      <link href="/archives/662e5bc3.html"/>
      <url>/archives/662e5bc3.html</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221022221007930.png" alt="图1"></p><ol><li><p>创建工程，导入驱动jar包:</p><p>mysql-connector-java-5.1.48.jar</p></li><li><p>注册驱动</p><p><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></p></li><li><p>获取连接<br><code>Connection conn = DriverManager.getConnection(url, username, password);</code></p></li><li><p>定义SQL语句<br><code>String sql =&quot;update...&quot;;</code></p></li><li><p>获取执行SQL对象<br><code>Statement stmt = conn.createStatement();</code></p></li><li><p>执行SQL<br><code>stmt.executeUpdate(sql);</code></p></li><li><p>处理返回结果</p></li><li><p>释放资源</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取链接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/web2&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123123&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into user value(2, &#x27;ly&#x27;, 18)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取执行sql的对象的Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span>  <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行sql</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC-API"></a>JDBC-API</h2><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.registerDriver(); <span class="comment">//注册驱动(可以不写)</span></span><br><span class="line">DriverManager.getConnection(url, user, password); <span class="comment">//url 链接路径，user用户名, password用户密码</span></span><br><span class="line"><span class="comment">// url : (jdbc:mysql://ip地址:端口/数据库名称)</span></span><br></pre></td></tr></table></figure><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">conn.createStatement();<span class="comment">//获取执行sql的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//事务管理</span></span><br><span class="line">conn.setAutoCommit(<span class="type">boolean</span> autoCommit); <span class="comment">//ture为自动提交事务， false为手动，开启事务</span></span><br><span class="line">commit(); <span class="comment">//提交事务</span></span><br><span class="line">rollback(); <span class="comment">//回滚事务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//执行sql</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> stmt.executeUpdate(sql);</span><br><span class="line">    <span class="comment">// 处理结果</span></span><br><span class="line">    System.out.println(count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    conn.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception throwables)&#123;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    conn.rollback();</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>执行sql语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">executeUpdate(sql); <span class="comment">//执行DML、DDL语句，返回值：DML返回受影响的行数，DDL返回可能是0（只要不报错就是执行正确）</span></span><br><span class="line">executeQuery(sql); <span class="comment">// 执行DQL语句， 返回值：ResultSet(结果集对象)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DML、DDL</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;create database db2&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span>  <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="type">int</span> <span class="variable">cnt1</span> <span class="operator">=</span> stmt.executeUpdate(sql1); <span class="comment">// 执行DDL</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;insert into user value(2, &#x27;ly&#x27;, 18)&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> stmt.executeUpdate(sql2); <span class="comment">// 执行DML</span></span><br></pre></td></tr></table></figure><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ResultSet stmt.executeQuery(sql); <span class="comment">//执行DQL语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取查询结果</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">next</span><span class="params">()</span>: <span class="comment">//将光标移动到下一行，检查是否为有效行 true(有效)</span></span><br><span class="line">xxx <span class="title function_">getXxx</span><span class="params">(参数)</span>: </span><br><span class="line"><span class="comment">//xxx是数据类型如String getString();</span></span><br><span class="line"><span class="comment">//参数int:列的编号，String 列的名称</span></span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pojo.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCDemo1_ResultSet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 注册驱动</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取链接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/web2?useSSL=false&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123123&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取执行sql的对象的Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span>  <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行sql</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个集合</span></span><br><span class="line">        List&lt;Account&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理结果</span></span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建对象</span></span><br><span class="line">            <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">            <span class="comment">//获取数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> rs.getInt(<span class="number">3</span>);</span><br><span class="line">            account.setId(id);</span><br><span class="line">            account.setName(name);</span><br><span class="line">            account.setAge(age);</span><br><span class="line">            list.add(account);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        rs.close();</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SQL注入与PreparedStatement"><a href="#SQL注入与PreparedStatement" class="headerlink" title="SQL注入与PreparedStatement"></a>SQL注入与PreparedStatement</h3><h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>SQL注入原理，通过SQL语句去完成登录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pojo.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUserLogin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 注册驱动</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取链接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/web2?useSSL=false&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123123&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;jpdasdadsadsac&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27;=&#x27;1&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = &#x27;&quot;</span>+name+<span class="string">&quot;&#x27; and password = &#x27;&quot;</span>+pwd+<span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(sql);</span><br><span class="line">        <span class="comment">// 获取执行sql的对象的Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span>  <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行sql</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;登录失败~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        rs.close();</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码运行结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where username = &#x27;jpdasdadsadsac&#x27; and password = &#x27;&#x27; or &#x27;1&#x27;=&#x27;1&#x27;</span><br><span class="line">登录成功~</span><br></pre></td></tr></table></figure><p>因为登录密码相当于SQL注入，截断了password并且加了一个or ‘1’ = ‘1’ 导致随便输入用户名也会成功登录。</p><h4 id="PrearedStatement预防SQL注入"><a href="#PrearedStatement预防SQL注入" class="headerlink" title="PrearedStatement预防SQL注入"></a>PrearedStatement预防SQL注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;jpdasdadsadsac&quot;</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> <span class="string">&quot;&#x27; or &#x27;1&#x27;=&#x27;1&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 定义sql，参数用?替代</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取执行sql的对象的Statement</span></span><br><span class="line">      <span class="type">PreparedStatement</span> <span class="variable">pstmt</span>  <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置两个参数（设置?的值）</span></span><br><span class="line">      pstmt.setString(<span class="number">1</span>, name);</span><br><span class="line">      pstmt.setString(<span class="number">2</span>, pwd);</span><br><span class="line">      <span class="comment">// 执行sql</span></span><br><span class="line">      <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;登录成功~&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;登录失败~&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>输出结果：登录失败</p><p>原理：将敏感字符串进行转义</p><ol><li>在获取PreparedStatement对象时，将sql语句发送给mysql服务器<br>进行检查，编译(这些步骤很耗时)</li><li>执行时就不用再进行这些步骤了，速度更快</li><li>如果sql模板一样，则只需要进行一次检查、编译</li></ol><p>PreparedStatement好处：</p><ol><li>预编译SQL，性能更高</li><li>防止SQL注入</li></ol><p>开启预编译功能：useServerPrepStmts=true;</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>数据库连接池简介</p><ul><li>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个;</li><li>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</li><li>好处:<ul><li>资源重用</li><li>提升系统响应速度。</li><li>避免数据库连接遗漏。</li></ul></li></ul><p>数据库连接池实现</p><ul><li>标准接口:DataSource</li><li>官方(SUN)提供的数据库连接池标准接口，由第三方组织实现此接口。</li><li>功能:获取连接：Connection getConnection()</li><li>常见的数据库连接池:<ul><li>DBCP</li><li>C3P0</li><li>Druid(德鲁伊)</li></ul></li><li>Druid连接池是阿里巴巴开源的数据库连接池项目</li><li>功能强大，性能优秀，是Java语言最好的数据库连接池之一。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> 数据库 </tag>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的配置和基础语法</title>
      <link href="/archives/b7d099a9.html"/>
      <url>/archives/b7d099a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h2><p><a href="https://www.acwing.com/file_system/file/content/whole/index/content/6237942/">https://www.acwing.com/file_system/file/content/whole/index/content/6237942/</a></p><h4 id="mysql服务的关闭与启动（默认开机自动启动，如果想手动操作，可以参考如下命令）"><a href="#mysql服务的关闭与启动（默认开机自动启动，如果想手动操作，可以参考如下命令）" class="headerlink" title="mysql服务的关闭与启动（默认开机自动启动，如果想手动操作，可以参考如下命令）"></a>mysql服务的关闭与启动（默认开机自动启动，如果想手动操作，可以参考如下命令）</h4><ul><li>关闭：net stop mysql80</li><li>启动：net start mysql80</li></ul><h4 id="mysql的常用操作"><a href="#mysql的常用操作" class="headerlink" title="mysql的常用操作"></a>mysql的常用操作</h4><ul><li>连接用户名为root，密码为520jpc…的数据库服务：mysql -uroot -p520jpc…</li><li>show databases;：列出所有数据库</li><li>create database kob;：创建数据库</li><li>drop database kob;：删除数据库</li><li>use kob;：使用数据库kob</li><li>show tables;：列出当前数据库的所有表</li><li>create table user(id int, username varchar(100))：创建名称为user的表，表中包含id和username两个属性。</li><li>drop table user;：删除表</li><li>insert into user values(1, ‘yxc’);：在表中插入数据</li><li>select * from user;：查询表中所有数据</li><li>delete from user where id = 2;：删除某行数据</li></ul><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database [name]; #创建数据库</span><br><span class="line">create table user(</span><br><span class="line">    id int, </span><br><span class="line">    username varchar(100)</span><br><span class="line">); #创建名称为user的表，表中包含id和username两个属性。</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show databases;#列出所有数据库</span><br><span class="line">show tables; #列出当前数据库的所有表</span><br><span class="line">desc [tablename];#查询表的结构信息</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table [name] rename to [newname];#修改表名</span><br><span class="line">alter table [name] add [列名] [数据类型];#添加一列</span><br><span class="line">alter table [name] modify [列名] [新数据类型];   #修改数据类型</span><br><span class="line">alter table [name] change [列名] [新列名] [新数据类型];        #修改列名和数据类型</span><br><span class="line">alter table [name] drop [列名];     #删除列</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop database kob;#删除数据库</span><br><span class="line">drop table [name];#删除表</span><br><span class="line">drop table if exists [name] #如果存在就删除表</span><br></pre></td></tr></table></figure><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">insert into [表名](列名1,列名2,...) value (val1, val2,...); #给制定列添加数据</span><br><span class="line">insert into [表名] value (val1, val2,...); #给全部列添加数据</span><br><span class="line"></span><br><span class="line">#批量添加数据</span><br><span class="line">insert into [表名](列名1,列名2,...) value (val1, val2,...),(val1, val2,...);</span><br><span class="line">insert into [表名] value (val1, val2,...),(val1, val2,...);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update [表名] set [列名1]=[value1], [列名2]=[value2]... [where 条件]; #修改表数据</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from [表名] [where 条件]; #删除</span><br></pre></td></tr></table></figure><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">select * from [表名]; #查询所有列</span><br><span class="line">select age from stu;   #查询一列</span><br><span class="line">select distinct address from stu;  #查询地址并去重</span><br><span class="line">select math as 数学成绩 from stu; #查询并且起一个别名</span><br><span class="line"></span><br><span class="line">-- 条件查询</span><br><span class="line">select 字段列表 from 表名 where 条件列表</span><br><span class="line">select * from stu where age &gt;= 20;# 查询年龄大于等于20岁的</span><br><span class="line">select * from stu where name like &#x27;_鹏%&#x27;; #模糊查询，查询第二个字是鹏的信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 排序查询</span><br><span class="line"># ASC:升序（默认）</span><br><span class="line"># DESC:降序</span><br><span class="line">select 字段列表 from 表名 order by 排序字段名1 [排序方式1], 排序字段名2 [排序方式2]; </span><br><span class="line"></span><br><span class="line">select * from stu order by math desc, english asc; #数学降序排，若一样按英语升序排</span><br><span class="line"></span><br><span class="line">-- 聚合函数</span><br><span class="line"># count(列名)统计数量</span><br><span class="line"># max(列名)最大值</span><br><span class="line"># min()最小值</span><br><span class="line"># sum()求和</span><br><span class="line"># avg()平均值</span><br><span class="line">select 聚合函数(列名) from 表;</span><br><span class="line">select max(math) from stu; #查询数学最高分</span><br></pre></td></tr></table></figure><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- where 和 having 区别</span><br><span class="line"># 执行时机不一样，where是分组之前限定，不满足where 条件，则不参与分组，而having是分组之后堆结果进行过滤。</span><br><span class="line"># 可判断的条件不一样: where不能对聚合函数进行判断，having可以。</span><br><span class="line"># 执行顺序: where &gt;聚合函数&gt; having</span><br><span class="line"></span><br><span class="line">select 字段列表 from 表名 [where 分组前条件列表] group by 分组字段名 [having 分组后条件过滤];</span><br><span class="line"></span><br><span class="line"># 查询男同学和女同学各自的数学成绩，以及各自的人数, 要求：分数低于70分的不参与分组，分组之后人数大于2</span><br><span class="line">select sex, avg(math), count(*) from stu where math &gt; 70 group by sex having count(*) &gt; 2;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#起始索引 = （当前页码-1）*每页显示的条数</span><br><span class="line">select 字段列表 from 表名 limit 起始索引， 查询条目数</span><br></pre></td></tr></table></figure><h2 id="数据库提高"><a href="#数据库提高" class="headerlink" title="数据库提高"></a>数据库提高</h2><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><div class="table-container"><table><thead><tr><th>约束名称</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>保证列中所有数据不能有null值</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证列中所有数据各不相同</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>检查约束</td><td>保证列中的值满足某—条件</td><td>CHECK</td></tr><tr><td>默认约束</td><td>保存数据时，未指定值则采用默认值</td><td>DEFAULT</td></tr><tr><td>外键约束</td><td>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性</td><td>OREIGN KEY</td></tr></tbody></table></div><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20221020221216442.png" alt="外键约束"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 添加外键</span><br><span class="line">create table emp(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">    name varchar(100),</span><br><span class="line">    age int,</span><br><span class="line">    dep_id int, -- 部门，外键</span><br><span class="line">    -- 添加外键dep_id , 关联dept表的主键</span><br><span class="line">    constraint fk_emp_dept foreign key(dep_id) references dept(id)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 删除外键</span><br><span class="line">alter table emp drop foreign key fk_emp_dept;</span><br><span class="line"># 建完表后添加外键</span><br><span class="line">alter table emp add constraint fk_emp_dept foreign key(dep_id) references dept(id);</span><br></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 多表查询</span><br><span class="line">select * from emp, dept; # 产生笛卡尔积变成AXB</span><br><span class="line"></span><br><span class="line">-- 连接查询</span><br><span class="line"># 内连接A交B（交集）</span><br><span class="line">select * from emp, dept where emp.dep_id = dept.did; #隐式内连接</span><br><span class="line">select * from emp inner join dept on emp.dep_id = dept.did; #显示内连接</span><br><span class="line"># 外连接</span><br><span class="line"># 左外连接查询A集合所有部分和AB交集</span><br><span class="line">select * from emp left join dept on emp.dep_id = dept.did;</span><br><span class="line"># 右外连接查询B集合所有部分和AB交集</span><br><span class="line">select * from emp right join dept on emp.dep_id = dept.did;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 子查询（）内是子查询</span><br><span class="line"># 单行单列</span><br><span class="line">select * from emp where salary &gt; (select salary from emp where name = &#x27;xxx&#x27;)</span><br><span class="line"># 多行单列(查市场部和财务部员工信息)</span><br><span class="line">select * from emp where dep_id in (select did from dept where dname = &#x27;财务部&#x27; or dname = &#x27;市场部&#x27;);</span><br><span class="line"># 多行多列(查询入职是2011-11-11之后的员工信息)</span><br><span class="line">select * from (select * from emp where join_data &gt; &#x27;2011-11-11&#x27;) t1, dept where t1.dep_id = dept.did;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近公共祖先</title>
      <link href="/archives/998a4a99.html"/>
      <url>/archives/998a4a99.html</url>
      
        <content type="html"><![CDATA[<h1 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h1><p>求最近公共祖先的方法</p><ol><li><p>向上标记法O(n)</p></li><li><p>倍增</p><p>fa[i, j]表示从i开始，向上走2^j步所能走到的节点。0 &lt;= j &lt;= logn</p><p>depth[i] 表示深度</p><p>哨兵：如果从i开始向上跳2^j步跳过根节点，fa[i, j] = 0, depth[0] = 0;</p><p>步骤：</p><ul><li>先让两个点跳到同一层</li><li>让两个点同时往上跳，一直跳到他们的最近公共祖先的下一层。</li></ul><p>预处理O(nlogn)</p><p>查询O(logn)</p></li><li><p>Tarjan——离线求LCA O(n + m)</p><p>深度优先遍历的时候将所有点分成三大类：</p><ul><li>已经遍历过，且回溯的点</li><li>正在搜索分支的点</li><li>还未搜索到的点</li></ul></li></ol><h3 id="祖孙询问-基础"><a href="#祖孙询问-基础" class="headerlink" title="祖孙询问(基础)"></a>祖孙询问(基础)</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵包含 n 个节点的有根无向树，节点编号互不相同，但不一定是 1∼n。</p><p>有 m 个询问，每个询问给出了一对节点的编号 x 和 y，询问 x 与 y 的祖孙关系。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入第一行包括一个整数 表示节点个数；</p><p>接下来 n 行每行一对整数 a 和 b，表示 a 和 b 之间有一条无向边。如果 b 是 −1，那么 a 就是树的根；</p><p>第 n+2 行是一个整数 m 表示询问个数；</p><p>接下来 m 行，每行两个不同的正整数 x 和 y，表示一个询问。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每一个询问，若 x 是 y 的祖先则输出 1，若 y 是 x 的祖先则输出2，否则输出 0。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤4×10^4<br>1≤每个节点的编号≤4×10^4</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">234 -1</span><br><span class="line">12 234</span><br><span class="line">13 234</span><br><span class="line">14 234</span><br><span class="line">15 234</span><br><span class="line">16 234</span><br><span class="line">17 234</span><br><span class="line">18 234</span><br><span class="line">19 234</span><br><span class="line">233 19</span><br><span class="line">5</span><br><span class="line">234 233</span><br><span class="line">233 12</span><br><span class="line">233 13</span><br><span class="line">233 15</span><br><span class="line">233 19</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(depth[j] &gt; depth[t] + <span class="number">1</span>)&#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;    <span class="comment">// j跳2^0步</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++) &#123;</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="comment">// 将两个点跳到同一深度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="comment">//两个点同时往上跳, 找到最近祖先的下面的深度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[a][k] != fa[b][k])&#123;</span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">-1</span>) root = a;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    <span class="comment">// m次询问</span></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a, b; </span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span>(p == a) cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p == b) cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="距离（提高）"><a href="#距离（提高）" class="headerlink" title="距离（提高）"></a>距离（提高）</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出 n 个点的一棵树，多次询问两点之间的最短距离。</p><p>注意：</p><ul><li>边是<strong>无向</strong>的。</li><li>所有节点的编号是 1,2,…,n。</li></ul><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行为两个整数 n 和 m。n 表示点数，m 表示询问次数；</p><p>下来 n−1 行，每行三个整数 x,y,k，表示点 x 和点 y 之间存在一条边长度为 k；</p><p>再接下来 m 行，每行两个整数 x,y，表示询问点 x 到点 y 的最短距离。</p><p>树中结点编号从 1 到 n。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 m 行，对于每次询问，输出一行询问结果。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>2≤n≤104，<br>1≤m≤2×104,<br>0&lt;k≤100,<br>1≤x,y≤n</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 2 </span><br><span class="line">1 2 100 </span><br><span class="line">1 2 </span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 10</span><br><span class="line">3 1 15</span><br><span class="line">1 2</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">25</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>深度优先遍历的时候将所有点分成三大类：</p><ul><li>已经遍历过，且回溯的点</li><li>正在搜索分支的点</li><li>还未搜索到的点</li></ul><p>深搜计算每个节点到根节点的路径和。回溯之后标记为st[i] = 2, 那么正在路劲上的点就是已经搜索过的点的祖先。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, h[N], e[M], w[M], ne[M], idx, dist[N], res[M], st[N], p[N];</span><br><span class="line">vector&lt;pii&gt; query[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算从当前节点到根节点的路径和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>; <span class="comment">// 当键节点等于父节点就不用管，保证从上到下执行</span></span><br><span class="line">        dist[j] = dist[u] + w[i]; <span class="comment">// 当前路径和等于父节点加边权</span></span><br><span class="line">        <span class="built_in">dfs</span>(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjin</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j]) &#123;</span><br><span class="line">            <span class="built_in">tarjin</span>(j);</span><br><span class="line">            p[j] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : query[u])&#123;</span><br><span class="line">        <span class="keyword">auto</span> [y, id] = item;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//已经遍历过且回溯的点</span></span><br><span class="line">        <span class="keyword">if</span>(st[y] == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> anc = <span class="built_in">find</span>(y); <span class="comment">// 父节点是anc</span></span><br><span class="line">            res[id] = dist[u] + dist[y] - dist[anc] * <span class="number">2</span>;    <span class="comment">//将当前结果存到res数组里面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    st[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(a != b) &#123;</span><br><span class="line">            query[a].<span class="built_in">push_back</span>(&#123;b, i&#125;);</span><br><span class="line">            query[b].<span class="built_in">push_back</span>(&#123;a, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">tarjin</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) cout &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板</title>
      <link href="/archives/2cc2fa98.html"/>
      <url>/archives/2cc2fa98.html</url>
      
        <content type="html"><![CDATA[<h4 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#### </span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>(1)朴素并查集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><p>(2)维护size的并查集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><p>(3)维护到祖宗节点距离的并查集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure><h4 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h4><p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="朴素dijkstra算法"><a href="#朴素dijkstra算法" class="headerlink" title="朴素dijkstra算法"></a>朴素dijkstra算法</h4><p>时间复杂是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆优化版dijkstra"><a href="#堆优化版dijkstra" class="headerlink" title="堆优化版dijkstra"></a>堆优化版dijkstra</h4><p>时间复杂度 O(mlogn)O(mlogn), nn 表示点数，mm 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h4><p>时间复杂度 O(nm)O(nm), nn 表示点数，mm 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="spfa-算法（队列优化的Bellman-Ford算法）"><a href="#spfa-算法（队列优化的Bellman-Ford算法）" class="headerlink" title="spfa 算法（队列优化的Bellman-Ford算法）"></a>spfa 算法（队列优化的Bellman-Ford算法）</h4><p>时间复杂度 平均情况下 O(m)O(m)，最坏情况下 O(nm)O(nm), nn 表示点数，mm 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="spfa判断图中是否存在负环"><a href="#spfa判断图中是否存在负环" class="headerlink" title="spfa判断图中是否存在负环"></a>spfa判断图中是否存在负环</h4><p>时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];        <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h4><p>时间复杂度是 O(n3)O(n3), nn 表示点数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="朴素版prim算法"><a href="#朴素版prim算法" class="headerlink" title="朴素版prim算法"></a>朴素版prim算法</h4><p>时间复杂度是 O(n2+m)O(n2+m), nn 表示点数，mm 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>时间复杂度是 O(mlogm)O(mlogm), nn 表示点数，mm 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">    </span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="染色法判别二分图"><a href="#染色法判别二分图" class="headerlink" title="染色法判别二分图"></a>染色法判别二分图</h4><p>时间复杂度是 O(n+m)O(n+m), nn 表示点数，mm 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><p>时间复杂度是 O(nm)O(nm), nn 表示点数，mm 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br></pre></td></tr></table></figure><h4 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="朴素筛法求素数"><a href="#朴素筛法求素数" class="headerlink" title="朴素筛法求素数"></a>朴素筛法求素数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛法求素数"><a href="#线性筛法求素数" class="headerlink" title="线性筛法求素数"></a>线性筛法求素数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="约数个数和约数之和"><a href="#约数个数和约数之和" class="headerlink" title="约数个数和约数之和"></a>约数个数和约数之和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果 N = p1^c1 * p2^c2 * ... *pk^ck</span><br><span class="line">约数个数： (c1 + <span class="number">1</span>) * (c2 + <span class="number">1</span>) * ... * (ck + <span class="number">1</span>)</span><br><span class="line">约数之和： (p1^<span class="number">0</span> + p1^<span class="number">1</span> + ... + p1^c1) * ... * (pk^<span class="number">0</span> + pk^<span class="number">1</span> + ... + pk^ck)</span><br><span class="line">欧几里得算法 —— 模板题 AcWing <span class="number">872.</span> 最大公约数</span><br><span class="line"><span class="type">int</span> <span class="built_in">gcd</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求欧拉函数"><a href="#求欧拉函数" class="headerlink" title="求欧拉函数"></a>求欧拉函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">求 m^k mod p，时间复杂度 <span class="built_in">O</span>(logk)。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a/b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )   <span class="comment">// 找到绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);      <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )       <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">    </span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归法求组合数"><a href="#递归法求组合数" class="headerlink" title="递归法求组合数"></a>递归法求组合数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">通过预处理逆元的方式求组合数 —— 模板题 AcWing <span class="number">886.</span> 求组合数 II</span><br><span class="line">首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</span><br><span class="line">如果取模的数是质数，可以用费马小定理求逆元</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span>    <span class="comment">// 快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">若p是质数，则对于任意整数 <span class="number">1</span> &lt;= m &lt;= n，有：</span><br><span class="line">    <span class="built_in">C</span>(n, m) = <span class="built_in">C</span>(n % p, m % p) * <span class="built_in">C</span>(n / p, m / p) (mod p)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">qmi</span>(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)  <span class="comment">// 快速幂模板</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span>  <span class="comment">// 通过定理求组合数C(a, b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LL x = <span class="number">1</span>, y = <span class="number">1</span>;  <span class="comment">// x是分子，y是分母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i --, j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * i % p;</span><br><span class="line">        y = (LL) y * j % p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x * (LL)<span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分解质因数法求组合数"><a href="#分解质因数法求组合数" class="headerlink" title="分解质因数法求组合数"></a>分解质因数法求组合数</h4><p>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</p><pre><code>1. 筛法求出范围内的所有质数    2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...    3. 用高精度乘法将所有质因子相乘</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];     <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span>      <span class="comment">// 线性筛法求素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span>       <span class="comment">// 求n！中的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span>       <span class="comment">// 高精度乘低精度模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_primes</span>(a);  <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++ )</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br></pre></td></tr></table></figure><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> w[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum, add;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum; <span class="comment">//左右儿子之和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add)&#123;</span><br><span class="line">        left.add += root.add, left.sum += (ll)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (ll)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改之前也需要pushdown()一下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;</span><br><span class="line">        tr[u].sum += (ll)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//分裂的情况</span></span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询之前一定要pushdown()一下</span></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扫描线-线段树"><a href="#扫描线-线段树" class="headerlink" title="扫描线+线段树"></a>扫描线+线段树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">double</span>&gt;ys;<span class="comment">//用于离散化</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存线段信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y1, y2;</span><br><span class="line">    <span class="type">int</span> d; <span class="comment">// 区分它是该矩阵前面的线段还是后面的线段</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> segment&amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">     &#125; </span><br><span class="line">&#125;seg[N * <span class="number">2</span>];<span class="comment">//每个矩阵需要存两个线段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树的每个节点 保存的为线段, 0号点为y[0]到y[1]，以此类推</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> cnt;    <span class="comment">// 记录当前区间整个被覆盖的次数</span></span><br><span class="line">    <span class="type">double</span> len; <span class="comment">// 记录这段区间的长度</span></span><br><span class="line">&#125;tr[N * <span class="number">8</span>];     <span class="comment">//由于线段二倍，所以8倍空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回第一个 &gt;= y 的数的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), y) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].cnt)tr[u].len = ys[tr[u].r + <span class="number">1</span>] - ys[tr[u].l];<span class="comment">//表示整个区间都被覆盖，该段长度就为右端点 + 1后在ys中的值 - 左端点在ys中的值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l != tr[u].r)&#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>;<span class="comment">//表示为叶子节点且该线段没被覆盖，为无用线段，长度变为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;</span><br><span class="line">        tr[u].cnt += d;     </span><br><span class="line">        <span class="built_in">pushup</span>(u);          <span class="comment">//更新该节点的len</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].r + tr[u].l &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);      <span class="comment">//左边存在点</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);   <span class="comment">//右边存在点</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);      <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l != r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>,l,mid),<span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">        <span class="comment">//后面都为0，不需更新len</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        ys.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;              <span class="comment">//线段个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++) &#123;</span><br><span class="line">            <span class="type">double</span> x1,y1,x2,y2;</span><br><span class="line">            cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">            seg[j ++] = &#123;x1, y1, y2, <span class="number">1</span>&#125;;        <span class="comment">//前面的线段</span></span><br><span class="line">            seg[j ++] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;       <span class="comment">//后面的线段</span></span><br><span class="line">            ys.<span class="built_in">push_back</span>(y1), ys.<span class="built_in">push_back</span>(y2);  <span class="comment">//y轴出现过那些点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(seg,seg + j);          <span class="comment">//线段按x排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//去重</span></span><br><span class="line">        <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());  </span><br><span class="line">        ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());<span class="comment">//离散化去重</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, ys.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; j ; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i)res += tr[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x); <span class="comment">//根节点的长度即为此时有效线段长度 ，再 * x轴长度即为面积</span></span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>, T ++ );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="线段树维护左右最大值"><a href="#线段树维护左右最大值" class="headerlink" title="线段树维护左右最大值"></a>线段树维护左右最大值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> op;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> lmax, rmax, t;</span><br><span class="line">&#125;tr[<span class="number">4</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].lmax = tr[u &lt;&lt; <span class="number">1</span>].lmax; tr[u].rmax = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].rmax;</span><br><span class="line">    <span class="keyword">if</span>(tr[u &lt;&lt; <span class="number">1</span>].r - tr[u &lt;&lt; <span class="number">1</span>].l + <span class="number">1</span> == tr[u &lt;&lt; <span class="number">1</span>].t) tr[u].lmax += tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lmax; <span class="comment">//左边区间长度等于可达长度</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].r - tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l + <span class="number">1</span> == tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].t) tr[u].rmax += tr[u &lt;&lt; <span class="number">1</span>].rmax;</span><br><span class="line">    tr[u].t = <span class="built_in">max</span>(<span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].t, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].t), tr[u &lt;&lt; <span class="number">1</span>].rmax + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lmax);  <span class="comment">//左区间后缀与右区间前缀和，和两区间的最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tr[u] = &#123;l, r, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == tr[u].r)&#123;</span><br><span class="line">        tr[u] = &#123;x, x, v, v, v&#125;;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == tr[u].r) <span class="keyword">return</span> tr[u].t;</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid - tr[u &lt;&lt; <span class="number">1</span>].rmax + <span class="number">1</span> &lt;= x &amp;&amp; mid + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lmax &gt;= x)</span><br><span class="line">        <span class="keyword">return</span> tr[u &lt;&lt; <span class="number">1</span>].rmax + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lmax;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">while</span>(m -- )&#123;</span><br><span class="line">            cin &gt;&gt; op;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                cin &gt;&gt; x;</span><br><span class="line">                <span class="built_in">modify</span>(<span class="number">1</span>, x, <span class="number">0</span>);</span><br><span class="line">                stk.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                cin &gt;&gt; x;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="built_in">modify</span>(<span class="number">1</span>, stk.<span class="built_in">top</span>(), <span class="number">1</span>);</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可达性统计"><a href="#可达性统计" class="headerlink" title="可达性统计"></a>可达性统计</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> seq[N], d[N];</span><br><span class="line">bitset&lt;N&gt; f[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>; <span class="comment">//记录拓扑排序的序列长度</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        seq[k++] = t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            d[j] --;    <span class="comment">//入度减一</span></span><br><span class="line">            <span class="keyword">if</span>(!d[j])&#123;  <span class="comment">//如果当前节点入度为0，加入到队列中</span></span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i; i--)&#123;<span class="comment">//倒着从后往前遍历，因为每次都需要后面的点来更新前面点能到达的点</span></span><br><span class="line">        <span class="type">int</span> k = seq[i];</span><br><span class="line">        f[k][k] = <span class="number">1</span>;                <span class="comment">//当前节点一定可以到达当前节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = h[k]; ~j; j = ne[j])&#123;   <span class="comment">//当前节点的所有下一个节点能到达的地方</span></span><br><span class="line">            f[k] = f[k] | f[e[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; f[i].<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础语法</title>
      <link href="/archives/ba5f3b22.html"/>
      <url>/archives/ba5f3b22.html</url>
      
        <content type="html"><![CDATA[<h3 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h3><ol><li><p>输入</p><blockquote><p>从HTML与用户的交互中输入信息，例如通过input、textarea等标签获取用户的键盘输入，通过click、hover等事件获取用户的鼠标输入。<br>通过Ajax与WebSocket从服务器端获取输入。</p></blockquote></li><li><p>输出</p><blockquote><p>调试用console.log，会将信息输出到浏览器控制台。<br>改变当前页面的HTML与CSS。<br>通过Ajax与WebSocket将结果返回到服务器。</p></blockquote></li></ol><p>输入a, b，输出a + b</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> buf = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&#x27;readable&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = process.<span class="property">stdin</span>.<span class="title function_">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.<span class="title function_">toString</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> [a, b] = buf.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="built_in">parseInt</span>(x);&#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>变量类型：</p><ul><li>number：数值变量，例如1, 2.5</li><li>string：字符串，例如”abcde”, ‘aaaaa’，单引号与双引号均可。字符串中的每个字符为只读类型。</li><li>boolean：布尔值，例如<code>true, false</code></li><li>object：对象，类似于C++中的指针，例如<code>[1, 2, 3]，&#123;name: &quot;xxxx&quot;, age: 18&#125;，null</code></li><li>undefined：未定义的变量<br>类似于Python，JavaScript中的变量类型可以动态变化。</li></ul><p>运算符：<br>与C++、Python、Java类似，不同点：</p><ul><li><code>**</code>表示乘方</li><li>等于与不等于用 <code>===</code> 和<code>!==</code></li></ul><h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><p>JavaScript中的逻辑运算符也与C++、Java中类似：</p><ul><li><code>&amp;&amp;</code>表示与</li><li><code>||</code>表示或</li><li><code>!</code>表示非</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&quot;readable&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = process.<span class="property">stdin</span>.<span class="title function_">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.<span class="title function_">toString</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseFloat</span>(buf);</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= <span class="number">25</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Intervalo [0,25]`</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">25</span> &amp;&amp; n &lt;= <span class="number">50</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Intervalo (25,50]`</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">50</span> &amp;&amp; n &lt;= <span class="number">75</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Intervalo (50,75]`</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">75</span> &amp;&amp; n &lt;= <span class="number">100</span>)<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Intervalo (75,100]`</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Fora de intervalo`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>JavaScript中的循环语句与C++中类似，也包含for、while、do while循环。</p><p>枚举对象或数组时可以使用：</p><ul><li>for-in循环，可以枚举数组中的下标，以及对象中的key。</li><li>for-of循环，可以枚举数组中的值，以及对象中的value。</li></ul><p>统计正数的个数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&quot;readable&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = process.<span class="property">stdin</span>.<span class="title function_">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.<span class="title function_">toString</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> v = buf.<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="built_in">parseFloat</span>(x);&#125;);</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">0</span>)cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;cnt&#125;</span> positive numbers`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>js中数组是一种特殊的对象。</p><p>类似于C++中的数组，但是数组中的元素类型可以不同。</p><p>数组中的元素可以是变量、数组、对象、函数。<br>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = [</span><br><span class="line">    <span class="number">1</span>,  <span class="comment">// 变量</span></span><br><span class="line">    <span class="string">&quot;abcdefg&quot;</span>,  <span class="comment">// 变量</span></span><br><span class="line">    [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>],  <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">function</span> (<span class="params"></span>) &#123;  <span class="comment">// 函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;xxxxx&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;  <span class="comment">// 对象</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>数组的常用属性和函数:</p><ul><li>属性length：返回数组长度。注意length是属性，不是函数，因此调用的时候不要加()。</li><li>函数push()：向数组末尾添加元素。</li><li>函数pop()：删除数组末尾的元素。</li><li>函数splice(a, b)：删除从a开始的b个元素。</li><li>函数sort()：将整个数组从小到大排序。</li><li>自定义比较函数：array.sort(cmp)，函数cmp输入两个需要比较的元素，返回一个实数，负数表示第一个参数小于第二个参数，0表示相等，正数表示大于。</li></ul><p>蛇形数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&quot;readable&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = process.<span class="property">stdin</span>.<span class="title function_">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.<span class="title function_">toString</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dx = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], dy = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> [n, m] = buf.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="built_in">parseInt</span>(x);&#125;);</span><br><span class="line">    <span class="keyword">let</span> g = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> gv = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            gv.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g.<span class="title function_">push</span>(gv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>, cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n * m; i++)&#123;</span><br><span class="line">        g[x][y] = i;</span><br><span class="line">        <span class="keyword">let</span> nx = dx[d] + x, ny = dy[d] + y;</span><br><span class="line">        <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= n || ny &gt;= m || g[nx][ny] !== <span class="number">0</span>)&#123;</span><br><span class="line">            d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            nx = dx[d] + x;</span><br><span class="line">            ny = dy[d] + y;</span><br><span class="line">        &#125;</span><br><span class="line">        x = nx, y = ny;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            s += g[i][j].<span class="title function_">toString</span>();</span><br><span class="line">            s += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>c++中map相类似，但是其中的value可以变量、数组、对象、函数等，与数组的类似。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;xxxx&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">money</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">add_money</span>: <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">money</span> += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>person.name、person.add_money()</code></p><h3 id="类与c-中的类相似"><a href="#类与c-中的类相似" class="headerlink" title="类与c++中的类相似"></a>类与c++中的类相似</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>求最大值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&quot;readable&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = process.<span class="property">stdin</span>.<span class="title function_">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.<span class="title function_">toString</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">max</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function max (a, b)&#123;</span></span><br><span class="line"><span class="comment">    if(a &gt; b) return a;</span></span><br><span class="line"><span class="comment">    else return b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> [a, b] = buf.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="built_in">parseInt</span>(x)&#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">max</span>(a, b));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&quot;readable&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = process.<span class="property">stdin</span>.<span class="title function_">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.<span class="title function_">toString</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> path = [];</span><br><span class="line"><span class="keyword">let</span> st = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">dfs</span> = (<span class="params">u, n</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(u === n) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            path.<span class="title function_">push</span>(i);</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="title function_">dfs</span>(u + <span class="number">1</span>, n);</span><br><span class="line">            path.<span class="title function_">pop</span>();</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseInt</span>(buf);</span><br><span class="line">    <span class="title function_">dfs</span>(<span class="number">0</span>, n);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>JavaScript的代码一般通过事件触发。</p><p>可以通过addEventListener函数为元素绑定事件的触发函数。</p><p>常见的触发函数有：</p><ol><li>鼠标<ul><li>click：鼠标左键点击</li><li>dblclick：鼠标左键双击</li><li>contextmenu：鼠标右键点击</li><li>mousedown：鼠标按下，包括左键、滚轮、右键</li><li>event.button：0表示左键，1表示中键，2表示右键</li><li>mouseup：鼠标弹起，包括左键、滚轮、右键</li><li>event.button：0表示左键，1表示中键，2表示右键</li></ul></li><li>键盘<ul><li>keydown：某个键是否被按住，事件会连续触发</li><li>event.code：返回按的是哪个键</li><li>event.altKey、event.ctrlKey、event.shiftKey分别表示是否同时按下了</li><li>alt、ctrl、shift键。</li><li>keyup：某个按键是否被释放</li><li>event常用属性同上</li><li>keypress：紧跟在keydown事件后触发，只有按下字符键时触发。适用于判定用户输入的字符。</li><li>event常用属性同上<br>keydown、keyup、keypress的关系类似于鼠标的mousedown、mouseup、click。</li></ul></li><li>表单<ul><li>focus：聚焦某个元素</li><li>blur：取消聚焦某个元素</li><li>change：某个元素的内容发生了改变</li></ul></li><li>窗口<ul><li>需要作用到window元素上。</li><li>resize：当窗口大小放生变化</li><li>scroll：滚动指定的元素</li><li>load：当元素被加载完成</li></ul></li></ol><h3 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h3><p>选择器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> $div = $(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> $div = $(<span class="string">&#x27;#mydiv &gt; p&#x27;</span>); <span class="comment">//复合选择器</span></span><br></pre></td></tr></table></figure><p>事件绑定与解绑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> $div = $(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">$div.<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;click div 1&quot;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">//定义名字</span></span><br><span class="line">$div.<span class="title function_">on</span>(<span class="string">&quot;click.name1&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;click div 1&quot;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">//另一种写法</span></span><br><span class="line">$div.<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;click div&quot;</span>); </span><br><span class="line">    $div.<span class="title function_">off</span>(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程通信</title>
      <link href="/archives/53ad465c.html"/>
      <url>/archives/53ad465c.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>通过共享内存实现两个进程通信</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/进程通信9.png" alt="进程通信1"></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/进程通信2.png" alt="进程通信2"></p><p>发送方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shared_msg</span> </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="type">int</span> update;<span class="comment">//更新数据标志，1：更新，0：未更新  </span></span><br><span class="line">    <span class="type">char</span> text[BUFSIZ];<span class="comment">//记录写入和读取的文本  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序开始\n&quot;</span>);</span><br><span class="line">    <span class="type">key_t</span> key;<span class="comment">//共享内存键值</span></span><br><span class="line">    <span class="type">int</span> shmid;<span class="comment">//共享内存标识</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];<span class="comment">//输入缓冲</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shared_msg</span> *<span class="title">msg</span>;</span><span class="comment">//共享内存地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//得到键值</span></span><br><span class="line">    key = (<span class="type">key_t</span>)<span class="number">1234</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建共享内存</span></span><br><span class="line">    shmid = shmget(key,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> shared_msg),IPC_CREAT|<span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//输出到错误缓冲区</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;创建共享内存失败\n&quot;</span>); </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将共享内存段映射到调用进程的数据段中</span></span><br><span class="line">    msg = (<span class="keyword">struct</span> shared_msg*)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>( msg &lt; (<span class="keyword">struct</span> shared_msg*)<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;共享内存段映射到进程失败n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;共享内存地址 %X\n&quot;, (int*)&amp;msg);  </span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//向共享内存中写入数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//向共享内存中写入数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入消息:&quot;</span>);  </span><br><span class="line">        <span class="comment">//从缓冲区输入</span></span><br><span class="line">        fgets(buf,BUFSIZ,<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(msg-&gt;text,buf,BUFSIZ);</span><br><span class="line">        msg-&gt;update = <span class="number">1</span>;<span class="comment">//1表示数据更新，客户端要同步更新</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;更新数据完成\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buf,<span class="string">&quot;EOF&quot;</span>,<span class="number">3</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将共享内存和当前进程分离 </span></span><br><span class="line">    <span class="keyword">if</span>(shmdt(msg) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;将共享内存和当前进程分离失败\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序结束\n&quot;</span>); </span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shared_msg</span> </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="type">int</span> update;<span class="comment">//更新数据标志，1：更新，0：未更新  </span></span><br><span class="line">    <span class="type">char</span> text[BUFSIZ];<span class="comment">//记录写入和读取的文本  </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序开始\n&quot;</span>);</span><br><span class="line">    <span class="type">key_t</span> key;<span class="comment">//共享内存键值</span></span><br><span class="line">    <span class="type">int</span> shmid;<span class="comment">//共享内存标识</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shared_msg</span> *<span class="title">msg</span>;</span><span class="comment">//共享内存地址</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];<span class="comment">//读取缓冲</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//得到键值</span></span><br><span class="line">    key = (<span class="type">key_t</span>)<span class="number">1234</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建共享内存</span></span><br><span class="line">    shmid = shmget(key,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> shared_msg),IPC_CREAT|<span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//输出到错误缓冲区</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;创建共享内存失败\n&quot;</span>); </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将共享内存段映射到调用进程的数据段中</span></span><br><span class="line">    msg = (<span class="keyword">struct</span> shared_msg*)shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>( msg &lt; (<span class="keyword">struct</span> shared_msg*)<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;共享内存段映射到进程失败n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共享内存地址 %X\n&quot;</span>, (<span class="type">int</span>)msg);  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//向共享内存中写入数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;       </span><br><span class="line">        <span class="comment">//服务端更新数据则读取</span></span><br><span class="line">        <span class="keyword">while</span>(msg-&gt;update == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s&quot;</span>,msg-&gt;text);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;读取数据:%s&quot;</span>,buf);          </span><br><span class="line">            <span class="comment">//读取完成后，将更新标志改变</span></span><br><span class="line">            msg-&gt;update = <span class="number">0</span>;                   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buf,<span class="string">&quot;EOF&quot;</span>,<span class="number">3</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将共享内存和当前进程分离 </span></span><br><span class="line">    <span class="keyword">if</span>(shmdt(msg) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;将共享内存和当前进程分离失败\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除共享内存  </span></span><br><span class="line">    <span class="keyword">if</span>(shmctl(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;删除共享内存失败\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序结束\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下进程的同步互斥</title>
      <link href="/archives/dfb08fa8.html"/>
      <url>/archives/dfb08fa8.html</url>
      
        <content type="html"><![CDATA[<h1 id="互斥锁同步互斥"><a href="#互斥锁同步互斥" class="headerlink" title="互斥锁同步互斥"></a>互斥锁同步互斥</h1><p>为了保护共享资源，使我们线程可以单独使用某个共享资源，使用之前先上锁，当其他进程要使用的时候，就需要等待到这个线程用完之后，再开锁。</p><ol><li>声明互斥锁：<code>pthread_mutex_t  m</code>;</li><li>初始化互斥锁：<code>int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);</code>第一个参数：就是前面声明的锁，因为这个参数需要传递的是一个锁的指针，所以需要有一个取地址符。第二个参数：是这个锁的属性，我们让它是默认的属性，这里设置为NULL，返回值：成功返回0， 失败返回-1。</li><li>上锁：锁住某个资源<code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code>    这个函数是阻塞型。int <code>pthread_mutex_trylock(pthread_mutex_t *mutex);</code>   这个是非阻塞型的。返回值：成功返回0，失败返回-1.</li><li>解锁：<code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code> 返回值：成功返回0，失败返回-1.</li><li>销毁互斥锁：<code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code> 返回值：成功返回0，  失败返回-1。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;<span class="comment">//定义互斥量</span></span><br><span class="line"><span class="type">char</span>* buf[<span class="number">5</span>];<span class="comment">//字符指针数组  全局变量</span></span><br><span class="line"><span class="type">int</span> pos;<span class="comment">//用于指定上面数组的下标</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task</span><span class="params">(<span class="type">void</span>* p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//使用互斥量进行加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">buf[pos] = (<span class="type">char</span>*)p;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">pos++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用互斥量进行解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">task2</span><span class="params">(<span class="type">void</span>* p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//使用互斥量进行加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">buf[pos] = (<span class="type">char</span>*)p;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">pos++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用互斥量进行解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化互斥量, 默认属性</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动一个线程 向数组中存储内容</span></span><br><span class="line"><span class="type">pthread_t</span> tid, tid2;</span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, task, (<span class="type">void</span>*)<span class="string">&quot;贾鹏城\n&quot;</span>);</span><br><span class="line">pthread_create(&amp;tid2, <span class="literal">NULL</span>, task2, (<span class="type">void</span>*)<span class="string">&quot;OperatingSystem\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程进程等待,并且打印最终的结果</span></span><br><span class="line">pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;字符指针数组中的内容是：\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pos; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220414165738384.png" alt="互斥锁同步互斥"></p><h1 id="读写锁同步互斥"><a href="#读写锁同步互斥" class="headerlink" title="读写锁同步互斥"></a>读写锁同步互斥</h1><p>读写锁：</p><p>如果某线程申请了读锁，其它线程可以再申请读锁，但不能申请写锁；如果某线程申请了写锁，其它线程不能申请读锁，也不能申请写锁。</p><p>读写锁适合于对资源的读次数比写次数多得多的情况。 </p><p>实例，两个读线程两个写线程，写互斥地对字符数组操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> cBuf[<span class="number">30</span>];</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock; <span class="comment">//读写锁</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//write线程函数，负责往buf里面加字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">taskWrite</span><span class="params">(<span class="type">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">29</span>)</span><br><span class="line">&#123;</span><br><span class="line">cBuf[pos] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">pos++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Write cBuf is: %s \n&quot;</span>, cBuf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//write线程函数，负责从buf里面删除字符</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">taskWriteDel</span><span class="params">(<span class="type">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line"><span class="keyword">if</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cBuf[pos<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">pos--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WriteDel cBuf is: %s \n&quot;</span>, cBuf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">taskRead</span><span class="params">(<span class="type">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line"><span class="keyword">if</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read cBuf is: %s \n&quot;</span>, cBuf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">taskRead2</span><span class="params">(<span class="type">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line"><span class="keyword">if</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read2 cBuf is: %s \n&quot;</span>, cBuf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> ptd1, ptd2, ptd3, ptd4;</span><br><span class="line">pos = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);<span class="comment">//初始化一个读写锁  </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建线程  </span></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;ptd1, <span class="literal">NULL</span>, taskWrite, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;ptd2, <span class="literal">NULL</span>, taskWriteDel, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;ptd3, <span class="literal">NULL</span>, taskRead, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;ptd4, <span class="literal">NULL</span>, taskRead2, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//等待线程结束，回收其资源  </span></span><br><span class="line"><span class="built_in">pthread_join</span>(ptd1, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">pthread_join</span>(ptd2, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">pthread_join</span>(ptd3, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">pthread_join</span>(ptd4, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock);<span class="comment">//销毁读写锁  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220414172806701.png" alt="读写锁"></p><h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>自旋锁与互斥量功能一样，唯一一点不同的就是互斥量阻塞后休眠让出cpu，而自旋锁阻塞后不会让出cpu，会一直忙等待，直到得到锁。</p><p>接口上就是把互斥锁的mutex改成spin。</p><p>实例 两个线程各自数数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">pthread_spinlock_t</span> spinMutex;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="title function_">task5</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//3.使用互斥量进行加锁</span></span><br><span class="line">pthread_spin_lock(&amp;spinMutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task5 %d\n&quot;</span>, cur);</span><br><span class="line">cur++;</span><br><span class="line">sleep(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//4.使用互斥量进行解锁</span></span><br><span class="line">pthread_spin_unlock(&amp;spinMutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">task6</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//3.使用互斥量进行加锁</span></span><br><span class="line">pthread_spin_lock(&amp;spinMutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;task6  %d\n&quot;</span>, cur);</span><br><span class="line">cur++;</span><br><span class="line">sleep(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//4.使用互斥量进行解锁</span></span><br><span class="line">pthread_spin_unlock(&amp;spinMutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_spin_init(&amp;spinMutex, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="type">pthread_t</span> tid3, tid4;</span><br><span class="line">pthread_create(&amp;tid3, <span class="literal">NULL</span>, task5, (<span class="type">void</span> *)<span class="string">&quot;zhangfei&quot;</span>);</span><br><span class="line">pthread_create(&amp;tid4, <span class="literal">NULL</span>, task6, (<span class="type">void</span> *)<span class="string">&quot;zhangfei&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line">pthread_join(tid4, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    pthread_spin_destroy(&amp;spinMutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程创建问题</title>
      <link href="/archives/512a71ce.html"/>
      <url>/archives/512a71ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="fork函数的应用与理解"><a href="#fork函数的应用与理解" class="headerlink" title="fork函数的应用与理解"></a>fork函数的应用与理解</h1><p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。</p><p>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。<strong>相当于克隆了一个自己</strong>。</p><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> fpid; <span class="comment">//fpid表示fork函数返回的值</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    fpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error in fork!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am the child process, my process id is %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是爹的儿子\n&quot;</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am the parent process, my process id is %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是孩子他爹\n&quot;</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;统计结果是: %d\n&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220414141057062.png" alt="image-20220414141057062"></p><p>在语句fpid=fork()之前，只有一个进程在执行这段代码，但在这条语句之后，就变成两个进程在执行了，这两个进程的几乎完全相同，将要执行的下一条语句都是if(fpid&lt;0）<br>为什么两个进程的fpid不同呢，这与fork函数的特性有关。</p><h2 id="fork函数特性"><a href="#fork函数特性" class="headerlink" title="fork函数特性"></a>fork函数特性</h2><p>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p><ol><li>在父进程中，fork返回新创建子进程的进程ID；</li><li>在子进程中，fork返回0；</li><li>如果出现错误，fork返回一个负值；</li></ol><p>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。<strong>在子进程中，fork函数返回0</strong>，<strong>在父进程中，fork返回新创建子进程的进程ID</strong>。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p><p>fork出错可能有两种原因</p><ol><li>当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。</li><li>系统内存不足，这时errno的值被设置为ENOMEM。</li></ol><p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。</p><p>每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。</p><p>fork只拷贝下一个要执行的代码到新的进程。</p><p>例子二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i son/pa ppid pid  fpid\n&quot;</span>);</span><br><span class="line">    <span class="comment">//ppid指当前进程的父进程pid</span></span><br><span class="line">    <span class="comment">//pid指当前进程的pid,</span></span><br><span class="line">    <span class="comment">//fpid指fork返回给当前进程的值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pid_t</span> fpid = fork();</span><br><span class="line">        <span class="keyword">if</span>(fpid == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d child  %4d %4d %4d\n&quot;</span>, i, <span class="built_in">getppid</span>(), <span class="built_in">getpid</span>(), fpid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d parent %4d %4d %4d\n&quot;</span>, i, <span class="built_in">getppid</span>(), <span class="built_in">getpid</span>(), fpid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>i       son/pa      ppid     pid           fpid<br>0      parent      2043     3224       3225<br>0      child          3224     3225      0<br>1      parent       2043     3224     3226<br>1      parent       3224     3225     3227<br>1      child           1           3227    0<br>1      child           1           3226    0</p></blockquote><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220414142146362.png" alt="image-20220414142146362"></p><h1 id="exec函数组"><a href="#exec函数组" class="headerlink" title="exec函数组"></a>exec函数组</h1><p>exec函数组包含六个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">　　<span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"> </span><br><span class="line">　　<span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"> </span><br><span class="line">　　<span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ..., <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"> </span><br><span class="line">　　<span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"> </span><br><span class="line">　　<span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"> </span><br><span class="line">　　<span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p>命名规则:</p><ul><li><p>e后续,  参数必须带环境变量部分,   环境变零部分参数会成为执行exec函数期间的环境变量, 比较少用。</p></li><li><p>l 后续,   命令参数部分必须以”,” 相隔, 最后1个命令参数必须是NULL。</p></li><li>v 后续,   命令参数部分必须是1个以NULL结尾的字符串指针数组的头部指针. 例如char <em> pstr就是1个字符串的指针, char </em> pstr[] 就是数组了, 分别指向各个字符串。</li><li>p后续,   执行文件部分可以不带路径, exec函数会在$PATH中找。</li></ul><p>==exec函数会取代执行它的进程,  也就是说, 一旦exec函数执行成功, 它就不会返回了, 进程结束.   但是如果exec函数执行失败, 它会返回失败的信息,  而且进程继续执行后面的代码!==</p><p>exec函数里的参数分成3个部分:</p><ol><li>执行文件部分</li><li>命令参数部分</li><li>环境变量部分</li></ol><ul><li>例如我要执行1个命令   ls -l /home/gateman。执行文件部分就是  “/usr/bin/ls”</li><li>命令参赛部分就是 “ls”,”-l”,”/home/gateman”,NULL 。见到是以ls开头 每1个空格都必须分开成2个部分, 而且以NULL结尾的啊。</li><li>环境变量部分, 这是1个数组,最后的元素必须是NULL 。例如  char * env[] = {“PATH=/home/gateman”, “USER=lei”, “STATUS=testing”, NULL};</li></ul><h2 id="execv函数"><a href="#execv函数" class="headerlink" title="execv函数"></a>execv函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//child process</span></span><br><span class="line"><span class="type">char</span> * execv_str[] = &#123;<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;executed by execv&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (execv(<span class="string">&quot;/usr/bin/echo&quot;</span>,execv_str) &lt;<span class="number">0</span> )&#123;</span><br><span class="line">perror(<span class="string">&quot;error on exec&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//parent process</span></span><br><span class="line">wait(&amp;childpid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;execv done\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="execvp-函数"><a href="#execvp-函数" class="headerlink" title="execvp 函数"></a>execvp 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//child process</span></span><br><span class="line">    <span class="type">char</span> * execvp_str[] = &#123;<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;executed by execvp&quot;</span>,<span class="string">&quot;&gt;&gt;&quot;</span>, <span class="string">&quot;~/abc.txt&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (execvp(<span class="string">&quot;echo&quot;</span>,execvp_str) &lt;<span class="number">0</span> )&#123;</span><br><span class="line">        perror(<span class="string">&quot;error on exec&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//parent process</span></span><br><span class="line">    wait(&amp;childpid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;execvp done\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="execve-函数"><a href="#execve-函数" class="headerlink" title="execve 函数"></a>execve 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//child process</span></span><br><span class="line"><span class="type">char</span> * execve_str[] = &#123;<span class="string">&quot;env&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">char</span> * env[] = &#123;<span class="string">&quot;PATH=/tmp&quot;</span>, <span class="string">&quot;USER=lei&quot;</span>, <span class="string">&quot;STATUS=testing&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (execve(<span class="string">&quot;/usr/bin/env&quot;</span>,execve_str,env) &lt;<span class="number">0</span> )&#123;</span><br><span class="line">perror(<span class="string">&quot;error on exec&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//parent process</span></span><br><span class="line">wait(&amp;childpid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;execve done\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="execl-函数"><a href="#execl-函数" class="headerlink" title="execl 函数"></a>execl 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//child process</span></span><br><span class="line">    <span class="keyword">if</span> (execl(<span class="string">&quot;/usr/bin/echo&quot;</span>,<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;executed by execl&quot;</span> ,<span class="literal">NULL</span>) &lt;<span class="number">0</span> )&#123;</span><br><span class="line">        perror(<span class="string">&quot;error on exec&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//parent process</span></span><br><span class="line">    wait(&amp;childpid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;execv done\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="execlp-函数"><a href="#execlp-函数" class="headerlink" title="execlp 函数"></a>execlp 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//child process</span></span><br><span class="line"><span class="keyword">if</span> (execlp(<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;executed by execlp&quot;</span> ,<span class="literal">NULL</span>) &lt;<span class="number">0</span> )&#123;</span><br><span class="line">perror(<span class="string">&quot;error on exec&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//parent process</span></span><br><span class="line">wait(&amp;childpid);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;execlp done\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="execle-函数"><a href="#execle-函数" class="headerlink" title="execle 函数"></a>execle 函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//child process</span></span><br><span class="line">    <span class="type">char</span> * env[] = &#123;<span class="string">&quot;PATH=/home/gateman&quot;</span>, <span class="string">&quot;USER=lei&quot;</span>, <span class="string">&quot;STATUS=testing&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (execle(<span class="string">&quot;/usr/bin/env&quot;</span>,<span class="string">&quot;env&quot;</span>,<span class="literal">NULL</span>,env) &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;error on exec&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//parent process</span></span><br><span class="line">    wait(&amp;childpid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;execle done\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集-高级数据结构</title>
      <link href="/archives/4c2eef42.html"/>
      <url>/archives/4c2eef42.html</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="总概"><a href="#总概" class="headerlink" title="总概"></a>总概</h2><ol><li>合并两个集合</li><li>查询某个节点的祖宗的节点<ul><li>记录每个集合的大小：（绑定到根节点）</li><li>每个节点到根节点的距离：（绑定到每个节点上）</li></ul></li></ol><h2 id="1250-格子游戏"><a href="#1250-格子游戏" class="headerlink" title="1250. 格子游戏"></a>1250. 格子游戏</h2><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/description/1252/">1250. 格子游戏</a></p><h3 id="题解思路："><a href="#题解思路：" class="headerlink" title="题解思路："></a>题解思路：</h3><p>根据题目，将各个元素映射到一维数组中，连接起来，检查连接的过程中是否出现环（若出现环状-》出现连接的时候两个节点在同一个连通块中）就说明有圈了</p><h3 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">41000</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * n + y;</span><br><span class="line">    <span class="comment">//如果是第二种初始化的话可以按照数据来乘倍率</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    return x * 200 + y;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">//只有根节点的p[x] == x，所以继续找</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * n; i++) p[i] = i; <span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从头初始化到结尾,第二种初始化</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt; N; i++)p[i] = i;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">char</span> d;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; d;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="comment">//因为输入原因(初始化原因)以及get函数x,y需要从0开始，如果按第二种初始化就不用，也可以不用从0开始</span></span><br><span class="line">        x--, y--;   </span><br><span class="line">        a = <span class="built_in">get</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span>(d == <span class="string">&#x27;D&#x27;</span>) b = <span class="built_in">get</span>(x + <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">else</span> b = <span class="built_in">get</span>(x, y + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b); </span><br><span class="line">        <span class="keyword">if</span>(pa == pb)&#123;       <span class="comment">//父亲节点相等就说明在同一个连通块中，连线必定有环</span></span><br><span class="line">            res = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p[pa] = pb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!res)cout &lt;&lt; <span class="string">&quot;draw&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1252-搭配购买"><a href="#1252-搭配购买" class="headerlink" title="1252. 搭配购买"></a>1252. 搭配购买</h2><h3 id="题目链接：-1"><a href="#题目链接：-1" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/1254/">1252. 搭配购买 - AcWing题库</a></p><h3 id="题解思路：-1"><a href="#题解思路：-1" class="headerlink" title="题解思路："></a>题解思路：</h3><p>思路：根据题目，将各个搭配连接起来，就相当于各个连通块选择，使得总价为vol，价值最大的01背包问题</p><h3 id="题目代码：-1"><a href="#题目代码：-1" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：根据题目，将各个搭配连接起来，就相当于各个连通块选择，使得总价为vol，价值最大的01背包问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N], p[N], f[N];         <span class="comment">// v[N] —— 价格、w[N] —— 价值、f[N] —— dp</span></span><br><span class="line"><span class="type">int</span> n, m, vol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">// 祖宗节点的p[x] == x,持续向上查找到祖宗节点</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; vol;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)&#123;</span><br><span class="line">            v[pb] += v[pa]; <span class="comment">//总价格全部绑定到祖宗节点上去</span></span><br><span class="line">            w[pb] += w[pa]; <span class="comment">//总价值全部绑定到祖宗节点上去</span></span><br><span class="line">            p[pa] = p[pb];  <span class="comment">//pa的祖宗是pb</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 01背包问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] == i) <span class="comment">//如果是祖宗节点，才进行状态转移（只有祖宗节点是这个连通块的总量）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = vol; j &gt;= v[i]; j--)&#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);  <span class="comment">//状态转移</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[vol] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="237-程序自动分析"><a href="#237-程序自动分析" class="headerlink" title="237. 程序自动分析"></a>237. 程序自动分析</h2><h3 id="题目链接：-2"><a href="#题目链接：-2" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/239/">237. 程序自动分析</a></p><h3 id="题解思路：-2"><a href="#题解思路：-2" class="headerlink" title="题解思路："></a>题解思路：</h3><p>离散化+并查集</p><p>因为i,j的范围是1~1e9,所以需要离散化，然后就是基本的，相等的点连接到一个连通图里面，不相等的点进行判断。</p><p>离散化：</p><ol><li>保序：排序+判重+二分</li><li>不保序： map、hash表</li></ol><p>此题不保序</p><h3 id="题目代码：-2"><a href="#题目代码：-2" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为i,j的范围是1~1e9,所以需要离散化，然后就是基本的，相等的点连接到一个连通图里面，不相等的点进行判断。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n, m, p[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">//散列表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Q</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, e;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x) == <span class="number">0</span>) mp[x] = ++n; </span><br><span class="line">    <span class="keyword">return</span> mp[x]; <span class="comment">//返回离散化后对应的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//离散化各个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++ )&#123;</span><br><span class="line">            <span class="type">int</span> x, y, e;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; e;</span><br><span class="line">            q[i] = &#123;<span class="built_in">get</span>(x), <span class="built_in">get</span>(y), e&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理相等的值，将相等的值连接到一个连通块</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].e == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; q[i].x &lt;&lt; &quot; &quot; &lt;&lt; q[i].y &lt;&lt; endl;</span></span><br><span class="line">                <span class="type">int</span> pa = <span class="built_in">find</span>(q[i].x), pb = <span class="built_in">find</span>(q[i].y);</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//非相等的值判断是否在同一个连通块中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].e == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> pa = <span class="built_in">find</span>(q[i].x), pb = <span class="built_in">find</span>(q[i].y);</span><br><span class="line">                <span class="keyword">if</span>(pa == pb) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="238-银河英雄传说"><a href="#238-银河英雄传说" class="headerlink" title="238. 银河英雄传说"></a>238. 银河英雄传说</h2><h3 id="题目链接：-3"><a href="#题目链接：-3" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/240/">238. 银河英雄传说</a></p><h3 id="题解思路：-3"><a href="#题解思路：-3" class="headerlink" title="题解思路："></a>题解思路：</h3><p>并查集：统一维护每个战舰到排头战舰的距离</p><p>当我们询问两个战舰间隔的时候是，|dx - dy| - 1 or 0(特判)</p><ol><li>让排头当根节点-&gt;同时维护一个size表示当前队列的长度</li><li>假设有一个初始的队列a,新加一个队列b，就把队列b的排头d[b]+size[a]，并且在find函数里面刷新后面所有d[x];</li><li>d[x]表示的是x到p[x]的距离，这样就可以很方便的算出每个节点到最排头的距离</li></ol><h3 id="题目代码：-3"><a href="#题目代码：-3" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="type">int</span> p[N], d[N], Size[N], T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)&#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);  <span class="comment">//持续向上找到根节点</span></span><br><span class="line">        d[x] += d[p[x]];        <span class="comment">//会更新当前节点到根节点的距离</span></span><br><span class="line">        p[x] = root;            <span class="comment">//向上找到根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) p[i] = i, Size[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            d[pa] = Size[pb];       <span class="comment">//距离pb的距离</span></span><br><span class="line">            Size[pb] += Size[pa];   <span class="comment">//将a这一列的大小加到b这一列</span></span><br><span class="line">            p[pa] = pb;             <span class="comment">//pa的父节点是pb</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa != pb)&#123;           <span class="comment">//不在同一列</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                  <span class="comment">//在同一列</span></span><br><span class="line">                <span class="keyword">if</span>(a != b)          <span class="comment">//不是同一个节点</span></span><br><span class="line">                    cout &lt;&lt; <span class="built_in">abs</span>(d[a] - d[b]) - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="239-奇偶游戏"><a href="#239-奇偶游戏" class="headerlink" title="239. 奇偶游戏"></a>239. 奇偶游戏</h2><h3 id="题目链接：-4"><a href="#题目链接：-4" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/241/">239. 奇偶游戏</a></p><h3 id="题解思路：-4"><a href="#题解思路：-4" class="headerlink" title="题解思路："></a>题解思路：</h3><p>总思想：前缀和</p><p>前缀和思想，如果是<code>[l, r]</code>内有奇数个1的话那么必有S[r] - S[l-1]为奇数，也即是<code>S[r]、S[l - 1]</code>奇偶性不同</p><p>同理如果是<code>[l, r]</code>内有偶数个1的话那么必有S[r] - S[l-1]为偶数，也即是<code>S[r]、S[l - 1]</code>奇偶性相同</p><h4 id="方法一（扩展域）"><a href="#方法一（扩展域）" class="headerlink" title="方法一（扩展域）"></a>方法一（扩展域）</h4><p>枚举思想：</p><ol><li>假设这个节点a是偶，并添加一个节点是a+M是奇</li><li>奇偶性相同的放在同一个集合中去</li><li>如果一组数据中，类型是偶数，就判断 a与b+M在不在同一个集合中<ul><li>在同一个集合中说明矛盾</li><li>不在同一个集合中说明不矛盾</li></ul></li><li>如果一组数据中，类型是奇数，就判断a与b是否在同一个集合中<ul><li>在同一个集合中说明，矛盾</li><li>不在同一个集合中说明不矛盾</li></ul></li></ol><h4 id="方法二（带边权）"><a href="#方法二（带边权）" class="headerlink" title="方法二（带边权）"></a>方法二（带边权）</h4><p>维护一个带边权的并查集</p><ol><li>d[x]表示x与p[x]的关系<ul><li>0表示同类</li><li>1表示不同类</li></ul></li><li>x与y是同类<ul><li>p[x] = p[y]<ul><li>d[x] ^ d[y]是0无矛盾，d[x]^d[y]是1有矛盾</li></ul></li><li>p[x] != p[y]<ul><li>d[p[x]] = d[x] ^ d[y]</li></ul></li></ul></li><li>xy异类<ul><li>p[x] = p[y]<ul><li>d[x] ^ d[y]是0有矛盾，d[x]^d[y]是1无矛盾</li></ul></li><li>p[x] != p[y]<ul><li>d[p[x]] = d[x] ^ d[y] ^ 1</li></ul></li></ul></li><li>综上所述，就相当于代边权一个路径d表示x与根节点的关系，在find函数中需要对d进行更新类似于238题</li></ol><h3 id="题目代码：-4"><a href="#题目代码：-4" class="headerlink" title="题目代码："></a>题目代码：</h3><h4 id="方法一-（扩展域）"><a href="#方法一-（扩展域）" class="headerlink" title="方法一 （扩展域）"></a>方法一 （扩展域）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">41000</span>, M = N / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> p[N], n, m;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x) == <span class="number">0</span>) mp[x] = ++n;</span><br><span class="line">    <span class="keyword">return</span> mp[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        string t;   <span class="comment">//类型（奇偶）</span></span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; t; </span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b);     <span class="comment">//相当于奇偶性~（Sl-1, Sr）</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">&quot;even&quot;</span>)&#123;                <span class="comment">//奇偶性相同</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b + M))&#123; <span class="comment">//必然b+M与a的奇偶性就不能相同</span></span><br><span class="line">                res = i - <span class="number">1</span>;            </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a + M)] = <span class="built_in">find</span>(b + M);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                          <span class="comment">//奇偶性不同</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))&#123;     <span class="comment">//那么奇偶性必然不能相同</span></span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b + M);   <span class="comment">//奇偶性相同的点加入到同一个集合中</span></span><br><span class="line">            p[<span class="built_in">find</span>(a + M)] = <span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二（带边权）-1"><a href="#方法二（带边权）-1" class="headerlink" title="方法二（带边权）"></a>方法二（带边权）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">41000</span>, M = N / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> p[N], d[N], n, m;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)&#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]] % <span class="number">2</span>; <span class="comment">//奇偶性原因，不影像最后结果，同时也防止爆int</span></span><br><span class="line">        p[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x) == <span class="number">0</span>) mp[x] = ++n;</span><br><span class="line">    <span class="keyword">return</span> mp[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        string t;   <span class="comment">//类型（奇偶）</span></span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; t; </span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b);     <span class="comment">//相当于奇偶性~（Sl-1, Sr）</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">&quot;even&quot;</span>)&#123;                <span class="comment">//奇偶性相同</span></span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa == pb)&#123;               <span class="comment">//在同一集合中</span></span><br><span class="line">                <span class="keyword">if</span>((d[a] ^ d[b]) % <span class="number">2</span>)&#123;  <span class="comment">//防止爆int</span></span><br><span class="line">                    res = i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">                d[pa] = d[a] ^ d[b];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                              <span class="comment">//奇偶性不同</span></span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa == pb)&#123;                   <span class="comment">//在同一集合中</span></span><br><span class="line">                <span class="keyword">if</span>((d[a] ^ d[b]) % <span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">//防止爆int</span></span><br><span class="line">                    res = i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">                d[pa] = d[a] ^ d[b] ^ <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级数据结构</title>
      <link href="/archives/41da5bdd.html"/>
      <url>/archives/41da5bdd.html</url>
      
        <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="总概"><a href="#总概" class="headerlink" title="总概"></a>总概</h2><ol><li>合并两个集合</li><li>查询某个节点的祖宗的节点<ul><li>记录每个集合的大小：（绑定到根节点）</li><li>每个节点到根节点的距离：（绑定到每个节点上）</li></ul></li></ol><h2 id="1250-格子游戏"><a href="#1250-格子游戏" class="headerlink" title="1250. 格子游戏"></a>1250. 格子游戏</h2><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/description/1252/">1250. 格子游戏</a></p><h3 id="题解思路："><a href="#题解思路：" class="headerlink" title="题解思路："></a>题解思路：</h3><p>根据题目，将各个元素映射到一维数组中，连接起来，检查连接的过程中是否出现环（若出现环状-》出现连接的时候两个节点在同一个连通块中）就说明有圈了</p><h3 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">41000</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * n + y;</span><br><span class="line">    <span class="comment">//如果是第二种初始化的话可以按照数据来乘倍率</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    return x * 200 + y;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">//只有根节点的p[x] == x，所以继续找</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * n; i++) p[i] = i; <span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从头初始化到结尾,第二种初始化</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt; N; i++)p[i] = i;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">char</span> d;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; d;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="comment">//因为输入原因(初始化原因)以及get函数x,y需要从0开始，如果按第二种初始化就不用，也可以不用从0开始</span></span><br><span class="line">        x--, y--;   </span><br><span class="line">        a = <span class="built_in">get</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span>(d == <span class="string">&#x27;D&#x27;</span>) b = <span class="built_in">get</span>(x + <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">else</span> b = <span class="built_in">get</span>(x, y + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b); </span><br><span class="line">        <span class="keyword">if</span>(pa == pb)&#123;       <span class="comment">//父亲节点相等就说明在同一个连通块中，连线必定有环</span></span><br><span class="line">            res = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p[pa] = pb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!res)cout &lt;&lt; <span class="string">&quot;draw&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1252-搭配购买"><a href="#1252-搭配购买" class="headerlink" title="1252. 搭配购买"></a>1252. 搭配购买</h2><h3 id="题目链接：-1"><a href="#题目链接：-1" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/1254/">1252. 搭配购买 - AcWing题库</a></p><h3 id="题解思路：-1"><a href="#题解思路：-1" class="headerlink" title="题解思路："></a>题解思路：</h3><p>思路：根据题目，将各个搭配连接起来，就相当于各个连通块选择，使得总价为vol，价值最大的01背包问题</p><h3 id="题目代码：-1"><a href="#题目代码：-1" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：根据题目，将各个搭配连接起来，就相当于各个连通块选择，使得总价为vol，价值最大的01背包问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N], p[N], f[N];         <span class="comment">// v[N] —— 价格、w[N] —— 价值、f[N] —— dp</span></span><br><span class="line"><span class="type">int</span> n, m, vol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">// 祖宗节点的p[x] == x,持续向上查找到祖宗节点</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; vol;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)&#123;</span><br><span class="line">            v[pb] += v[pa]; <span class="comment">//总价格全部绑定到祖宗节点上去</span></span><br><span class="line">            w[pb] += w[pa]; <span class="comment">//总价值全部绑定到祖宗节点上去</span></span><br><span class="line">            p[pa] = p[pb];  <span class="comment">//pa的祖宗是pb</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 01背包问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] == i) <span class="comment">//如果是祖宗节点，才进行状态转移（只有祖宗节点是这个连通块的总量）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = vol; j &gt;= v[i]; j--)&#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);  <span class="comment">//状态转移</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[vol] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="237-程序自动分析"><a href="#237-程序自动分析" class="headerlink" title="237. 程序自动分析"></a>237. 程序自动分析</h2><h3 id="题目链接：-2"><a href="#题目链接：-2" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/239/">237. 程序自动分析</a></p><h3 id="题解思路：-2"><a href="#题解思路：-2" class="headerlink" title="题解思路："></a>题解思路：</h3><p>离散化+并查集</p><p>因为i,j的范围是1~1e9,所以需要离散化，然后就是基本的，相等的点连接到一个连通图里面，不相等的点进行判断。</p><p>离散化：</p><ol><li>保序：排序+判重+二分</li><li>不保序： map、hash表</li></ol><p>此题不保序</p><h3 id="题目代码：-2"><a href="#题目代码：-2" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为i,j的范围是1~1e9,所以需要离散化，然后就是基本的，相等的点连接到一个连通图里面，不相等的点进行判断。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n, m, p[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">//散列表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Q</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, e;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x) == <span class="number">0</span>) mp[x] = ++n; </span><br><span class="line">    <span class="keyword">return</span> mp[x]; <span class="comment">//返回离散化后对应的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//离散化各个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++ )&#123;</span><br><span class="line">            <span class="type">int</span> x, y, e;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; e;</span><br><span class="line">            q[i] = &#123;<span class="built_in">get</span>(x), <span class="built_in">get</span>(y), e&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理相等的值，将相等的值连接到一个连通块</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].e == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; q[i].x &lt;&lt; &quot; &quot; &lt;&lt; q[i].y &lt;&lt; endl;</span></span><br><span class="line">                <span class="type">int</span> pa = <span class="built_in">find</span>(q[i].x), pb = <span class="built_in">find</span>(q[i].y);</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//非相等的值判断是否在同一个连通块中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].e == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> pa = <span class="built_in">find</span>(q[i].x), pb = <span class="built_in">find</span>(q[i].y);</span><br><span class="line">                <span class="keyword">if</span>(pa == pb) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="238-银河英雄传说"><a href="#238-银河英雄传说" class="headerlink" title="238. 银河英雄传说"></a>238. 银河英雄传说</h2><h3 id="题目链接：-3"><a href="#题目链接：-3" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/240/">238. 银河英雄传说</a></p><h3 id="题解思路：-3"><a href="#题解思路：-3" class="headerlink" title="题解思路："></a>题解思路：</h3><p>并查集：统一维护每个战舰到排头战舰的距离</p><p>当我们询问两个战舰间隔的时候是，|dx - dy| - 1 or 0(特判)</p><ol><li>让排头当根节点-&gt;同时维护一个size表示当前队列的长度</li><li>假设有一个初始的队列a,新加一个队列b，就把队列b的排头d[b]+size[a]，并且在find函数里面刷新后面所有d[x];</li><li>d[x]表示的是x到p[x]的距离，这样就可以很方便的算出每个节点到最排头的距离</li></ol><h3 id="题目代码：-3"><a href="#题目代码：-3" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="type">int</span> p[N], d[N], Size[N], T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)&#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);  <span class="comment">//持续向上找到根节点</span></span><br><span class="line">        d[x] += d[p[x]];        <span class="comment">//会更新当前节点到根节点的距离</span></span><br><span class="line">        p[x] = root;            <span class="comment">//向上找到根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) p[i] = i, Size[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            d[pa] = Size[pb];       <span class="comment">//距离pb的距离</span></span><br><span class="line">            Size[pb] += Size[pa];   <span class="comment">//将a这一列的大小加到b这一列</span></span><br><span class="line">            p[pa] = pb;             <span class="comment">//pa的父节点是pb</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa != pb)&#123;           <span class="comment">//不在同一列</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                  <span class="comment">//在同一列</span></span><br><span class="line">                <span class="keyword">if</span>(a != b)          <span class="comment">//不是同一个节点</span></span><br><span class="line">                    cout &lt;&lt; <span class="built_in">abs</span>(d[a] - d[b]) - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="239-奇偶游戏"><a href="#239-奇偶游戏" class="headerlink" title="239. 奇偶游戏"></a>239. 奇偶游戏</h2><h3 id="题目链接：-4"><a href="#题目链接：-4" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/241/">239. 奇偶游戏</a></p><h3 id="题解思路：-4"><a href="#题解思路：-4" class="headerlink" title="题解思路："></a>题解思路：</h3><p>总思想：前缀和</p><p>前缀和思想，如果是<code>[l, r]</code>内有奇数个1的话那么必有S[r] - S[l-1]为奇数，也即是<code>S[r]、S[l - 1]</code>奇偶性不同</p><p>同理如果是<code>[l, r]</code>内有偶数个1的话那么必有S[r] - S[l-1]为偶数，也即是<code>S[r]、S[l - 1]</code>奇偶性相同</p><h4 id="方法一（扩展域）"><a href="#方法一（扩展域）" class="headerlink" title="方法一（扩展域）"></a>方法一（扩展域）</h4><p>枚举思想：</p><ol><li>假设这个节点a是偶，并添加一个节点是a+M是奇</li><li>奇偶性相同的放在同一个集合中去</li><li>如果一组数据中，类型是偶数，就判断 a与b+M在不在同一个集合中<ul><li>在同一个集合中说明矛盾</li><li>不在同一个集合中说明不矛盾</li></ul></li><li>如果一组数据中，类型是奇数，就判断a与b是否在同一个集合中<ul><li>在同一个集合中说明，矛盾</li><li>不在同一个集合中说明不矛盾</li></ul></li></ol><h4 id="方法二（带边权）"><a href="#方法二（带边权）" class="headerlink" title="方法二（带边权）"></a>方法二（带边权）</h4><p>维护一个带边权的并查集</p><ol><li>d[x]表示x与p[x]的关系<ul><li>0表示同类</li><li>1表示不同类</li></ul></li><li>x与y是同类<ul><li>p[x] = p[y]<ul><li>d[x] ^ d[y]是0无矛盾，d[x]^d[y]是1有矛盾</li></ul></li><li>p[x] != p[y]<ul><li>d[p[x]] = d[x] ^ d[y]</li></ul></li></ul></li><li>xy异类<ul><li>p[x] = p[y]<ul><li>d[x] ^ d[y]是0有矛盾，d[x]^d[y]是1无矛盾</li></ul></li><li>p[x] != p[y]<ul><li>d[p[x]] = d[x] ^ d[y] ^ 1</li></ul></li></ul></li><li>综上所述，就相当于代边权一个路径d表示x与根节点的关系，在find函数中需要对d进行更新类似于238题</li></ol><h3 id="题目代码：-4"><a href="#题目代码：-4" class="headerlink" title="题目代码："></a>题目代码：</h3><h4 id="方法一-（扩展域）"><a href="#方法一-（扩展域）" class="headerlink" title="方法一 （扩展域）"></a>方法一 （扩展域）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">41000</span>, M = N / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> p[N], n, m;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x) == <span class="number">0</span>) mp[x] = ++n;</span><br><span class="line">    <span class="keyword">return</span> mp[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        string t;   <span class="comment">//类型（奇偶）</span></span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; t; </span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b);     <span class="comment">//相当于奇偶性~（Sl-1, Sr）</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">&quot;even&quot;</span>)&#123;                <span class="comment">//奇偶性相同</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b + M))&#123; <span class="comment">//必然b+M与a的奇偶性就不能相同</span></span><br><span class="line">                res = i - <span class="number">1</span>;            </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a + M)] = <span class="built_in">find</span>(b + M);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                          <span class="comment">//奇偶性不同</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))&#123;     <span class="comment">//那么奇偶性必然不能相同</span></span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b + M);   <span class="comment">//奇偶性相同的点加入到同一个集合中</span></span><br><span class="line">            p[<span class="built_in">find</span>(a + M)] = <span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二（带边权）-1"><a href="#方法二（带边权）-1" class="headerlink" title="方法二（带边权）"></a>方法二（带边权）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">41000</span>, M = N / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> p[N], d[N], n, m;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)&#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]] % <span class="number">2</span>; <span class="comment">//奇偶性原因，不影像最后结果，同时也防止爆int</span></span><br><span class="line">        p[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x) == <span class="number">0</span>) mp[x] = ++n;</span><br><span class="line">    <span class="keyword">return</span> mp[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        string t;   <span class="comment">//类型（奇偶）</span></span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; t; </span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b);     <span class="comment">//相当于奇偶性~（Sl-1, Sr）</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">&quot;even&quot;</span>)&#123;                <span class="comment">//奇偶性相同</span></span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa == pb)&#123;               <span class="comment">//在同一集合中</span></span><br><span class="line">                <span class="keyword">if</span>((d[a] ^ d[b]) % <span class="number">2</span>)&#123;  <span class="comment">//防止爆int</span></span><br><span class="line">                    res = i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">                d[pa] = d[a] ^ d[b];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                              <span class="comment">//奇偶性不同</span></span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa == pb)&#123;                   <span class="comment">//在同一集合中</span></span><br><span class="line">                <span class="keyword">if</span>((d[a] ^ d[b]) % <span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">//防止爆int</span></span><br><span class="line">                    res = i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">                d[pa] = d[a] ^ d[b] ^ <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>引入问题<br>给出一个长度为n的数组，完成以下两种操作：</p><ol><li>将第i个数加上k</li><li>输出区间<code>[i,j]</code>内每个数的和</li></ol><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>单点修改：O(1)<br>区间查询：O(n)</p><h3 id="树状数组-1"><a href="#树状数组-1" class="headerlink" title="树状数组"></a>树状数组</h3><p>快速求前缀和</p><p>单点修改：O(logn)<br>区间查询：O(logn)</p><h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit()"></a>lowbit()</h3><p>lowbit()运算：x &amp; (-x) 的用途一般是用来获取某个二进制数的 LowBit ，在树状数组中会用到<br>lowbit(x)是x的二进制表达式中最低位的1所对应的值.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树状数组思想"><a href="#树状数组思想" class="headerlink" title="树状数组思想"></a>树状数组思想</h3><p>树状数组的本质思想是使用树结构维护”前缀和”，从而把时间复杂度降为O(logn)。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220308170615088.png" alt=""></p><p>对于一个序列，对其建立如下树形结构：</p><ul><li>每个结点t[x]保存以x为根的子树中叶结点值的和</li><li>每个结点覆盖的长度为lowbit(x)</li><li>t[x]结点的父结点为t[x + lowbit(x)]</li><li>树的深度为log2n+1log2n+1</li></ul><h3 id="树状数组操作"><a href="#树状数组操作" class="headerlink" title="树状数组操作"></a>树状数组操作</h3><h4 id="add-x-k-表示将序列中第x个数加上k。"><a href="#add-x-k-表示将序列中第x个数加上k。" class="headerlink" title="add(x, k)表示将序列中第x个数加上k。"></a>add(x, k)表示将序列中第x个数加上k。</h4><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220308170815852.png" alt=""></p><p>以add(3, 5)为例：<br>在整棵树上维护这个值，需要一层一层向上找到父结点，并将这些结点上的t[x]值都加上k，这样保证计算区间和时的结果正确。时间复杂度为O(logn)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        t[i] += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ask-x-表示将查询序列前x个数的和"><a href="#ask-x-表示将查询序列前x个数的和" class="headerlink" title="ask(x)表示将查询序列前x个数的和"></a>ask(x)表示将查询序列前x个数的和</h4><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220308170841138.png" alt=""></p><p>以ask(7)为例：<br>查询这个点的前缀和，需要从这个点向左上找到上一个结点，将加上其结点的值。向左上找到上一个结点，只需要将下标 x -= lowbit(x)，</p><p>例如 7 - lowbit(7) = 6。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        sum += t[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树状数组初始化"><a href="#树状数组初始化" class="headerlink" title="树状数组初始化"></a>树状数组初始化</h3><p>若给你一个数组，时间卡的特别紧的话，需要O(n)的时间复杂度去初始化树状数组，那么可以On求出前缀和数组S</p><p>tr[x] = S[x] - S[x - lowbit(x)]</p><p>上述介绍引用：<a href="https://www.acwing.com/solution/content/13818/">qiaoxinwei</a></p><h2 id="241-楼兰图腾"><a href="#241-楼兰图腾" class="headerlink" title="241. 楼兰图腾"></a>241. 楼兰图腾</h2><h3 id="题目链接：-5"><a href="#题目链接：-5" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/243/">241. 楼兰图腾</a></p><h3 id="题解思路：-5"><a href="#题解思路：-5" class="headerlink" title="题解思路："></a>题解思路：</h3><p>树状数组</p><ol><li>tr[x]保存数据在[1, x]的个数，<code>t[r] - t[l-1]</code>代表在<code>[l, r]</code>之间数据的个数</li><li>Greater[i]表示前i个数里面有多少个比a[i]大的数、Lower[i]表示前i个数里面有多少个比a[i]小的数</li><li>以i为中心，左边大于i的*右边大于i的就是以当前i为中心的所有V个数</li></ol><h3 id="题目代码：-5"><a href="#题目代码：-5" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210000</span>;</span><br><span class="line"><span class="type">int</span> a[N], tr[N], Greater[N], Lower[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;  <span class="comment">//从前往后遍历更新将会影响到后面所有的tr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i]; <span class="comment">//从后往前遍历减去末位1所对应的值</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        Greater[i] = <span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y);   <span class="comment">//前i个元素中，在[y + 1, n]范围的个数</span></span><br><span class="line">        Lower[i] = <span class="built_in">sum</span>(y - <span class="number">1</span>);          <span class="comment">//前i个元素中， 在[1, y - 1]范围的个数</span></span><br><span class="line">        <span class="built_in">add</span>(y, <span class="number">1</span>);      <span class="comment">//添加y,个数为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);       <span class="comment">//初始化一下变成0,因为后续操作需要从右边往左遍历</span></span><br><span class="line">    ll res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        res1 += Greater[i] * (ll)(<span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y)); <span class="comment">//[i + 1, n]元素中，在[y + 1, n]范围的个数</span></span><br><span class="line">        res2 += Lower[i] * (ll)(<span class="built_in">sum</span>(y - <span class="number">1</span>));        <span class="comment">//[i + 1, n]元素中， 在[1, y - 1]范围的个数</span></span><br><span class="line">        <span class="built_in">add</span>(y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, res1, res2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="242-一个简单的整数问题"><a href="#242-一个简单的整数问题" class="headerlink" title="242. 一个简单的整数问题"></a>242. 一个简单的整数问题</h2><h3 id="题目链接：-6"><a href="#题目链接：-6" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/description/248/">242. 一个简单的整数问题</a></p><h3 id="题解思路：-6"><a href="#题解思路：-6" class="headerlink" title="题解思路："></a>题解思路：</h3><p>树状数组+差分</p><ol><li>根据题目意思在a数组的<code>[l, r]</code>区间每个元素加d，可以求a数组的差分，然后对a数组的差分来求树状数组</li><li>可以根据a数组的差分来求的树状数组，来还原a数组</li></ol><h3 id="题目代码：-6"><a href="#题目代码：-6" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N], n, m;</span><br><span class="line">ll  tr[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) s += tr[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">add</span>(i, a[i] - a[i - <span class="number">1</span>]);    <span class="comment">//求a数组差分的树状数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> l, r, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">sum</span>(l));   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;d);</span><br><span class="line">            <span class="built_in">add</span>(l, d), <span class="built_in">add</span>(r + <span class="number">1</span>, -d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="243-一个简单的整数问题2"><a href="#243-一个简单的整数问题2" class="headerlink" title="243. 一个简单的整数问题2"></a>243. 一个简单的整数问题2</h2><h3 id="题目链接：-7"><a href="#题目链接：-7" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/description/244/">243. 一个简单的整数问题2</a></p><h3 id="题解思路：-7"><a href="#题解思路：-7" class="headerlink" title="题解思路："></a>题解思路：</h3><p>树状数组+差分</p><ol><li><p>根据差分的思想，求出a的差分数组b</p></li><li><script type="math/tex; mode=display">a数组前n个之和 --- \sum_{i = 0}^{n}a_i \\a的差分数组b可以求a_i \\也等于 \sum_{i = 0}^{n}\sum_{j = 0}^{i}b_j\\a前n个数的之和 = \sum_{i = 0}^{n}a_i = \sum_{i = 0}^{n}\sum_{j = 0}^{i}b_j</script></li></ol><h3 id="题目代码：-7"><a href="#题目代码：-7" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line">ll tr1[N], tr2[N];  <span class="comment">// b的前缀和， b * i 的前缀和</span></span><br><span class="line"><span class="type">int</span> n, m, a[N];     <span class="comment">//b是a的差分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll tr[], <span class="type">int</span> x, ll c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll tr[], <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) s += tr[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pre_sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(tr1, x) * (x + <span class="number">1</span>) - <span class="built_in">sum</span>(tr2, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> b = a[i] - a[i - <span class="number">1</span>];    <span class="comment">//a数组的差分</span></span><br><span class="line">        <span class="built_in">add</span>(tr1, i, b);             <span class="comment">//维护差分数组b</span></span><br><span class="line">        <span class="built_in">add</span>(tr2, i, (ll)b * i);     <span class="comment">//维护b * i的树状数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> l, r, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">pre_sum</span>(r) - <span class="built_in">pre_sum</span>(l - <span class="number">1</span>));  <span class="comment">//更具推出来的公式</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">add</span>(tr1, l, d), <span class="built_in">add</span>(tr1, r + <span class="number">1</span>, -d);            </span><br><span class="line">            <span class="built_in">add</span>(tr2, l, d * l), <span class="built_in">add</span>(tr2, r + <span class="number">1</span>, -d * (r + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="244-谜一样的牛"><a href="#244-谜一样的牛" class="headerlink" title="244. 谜一样的牛"></a>244. 谜一样的牛</h2><h3 id="题目链接：-8"><a href="#题目链接：-8" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/245/">244. 谜一样的牛</a></p><h3 id="题解思路：-8"><a href="#题解思路：-8" class="headerlink" title="题解思路："></a>题解思路：</h3><p>树状数组+二分查找</p><ol><li>根据观察发现最后一头牛可以确定：最后一头牛前面有k个比它矮的牛，那么它必定是第k+1矮的牛</li><li>所以从后往前遍历，每次确定最后一头牛，他当前高度必定是剩下的牛种第k+1矮的（可以通过二分查找来确定每头牛的高度）</li><li>每确定一头牛，就删除这头牛的高度</li></ol><h3 id="题目代码：-8"><a href="#题目代码：-8" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N], res[N], tr[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) s += tr[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) tr[i] = <span class="built_in">lowbit</span>(i);   <span class="comment">//初始化tr，（每种高度的个数都是1）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- ) &#123; <span class="comment">//从后往前遍历,确定每一头牛的身高</span></span><br><span class="line">        <span class="type">int</span> k = h[i] + <span class="number">1</span>;<span class="comment">//这头牛的高度必定是剩下牛当中第k+1矮的</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;         <span class="comment">//二分查找剩下的数中第一个等于k的，就是当前牛的高度</span></span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sum</span>(mid) &gt;= k) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = r;             <span class="comment">//当前牛的高度</span></span><br><span class="line">        <span class="built_in">add</span>(r, <span class="number">-1</span>);             <span class="comment">//删除此高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="操作原理"><a href="#操作原理" class="headerlink" title="操作原理"></a>操作原理</h2><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol><li><p>pushup(u)：子节点的信息更新父节点的信息。</p></li><li><p>build()：将一段区间初始化成线段树。</p></li><li><p>modify()：修改。</p><ul><li><p>单点：easy。</p></li><li><p>区间：pushdown（懒标记）hard。</p><ul><li><p>类似于查询的时候，找到一个完整区间的时候直接标记一下（需要维护一个add）。</p></li><li><p>维护一个add(懒标记)，以当前节点为根的子树中的每一个节点加上一个add（不包含根节点）。</p></li><li><p>在pushdown的时候被标记的节点如果继续往下递归的话，就将当前节点的标记取消并且递归到子节点上，这样所有叶子节点的祖宗节点的标记已经取消掉，并且累加到此叶子节点上了。</p><p><code>left.add += root.add, left.sum += (left.r - left.l + 1) * root.add</code></p><p><code>right.add += root.add, right += (right.r - right.l + 1) * root.add</code></p><p><code>root.add = 0</code></p></li></ul></li></ul></li><li><p>query()：查询</p><p>查询某一个子区间的时候一定要pushdown一下</p></li></ol><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>满二叉树</p><script type="math/tex; mode=display">编号是x \begin{cases} 父节点：x/2下取整-->\ x >> 1 \\左儿子：2x --> \ x << 1 \\右儿子：2x+1 --> \ x << 1|1\end{cases}</script><p>线段树一般开空间：4n</p><h2 id="1-最大数"><a href="#1-最大数" class="headerlink" title="1. 最大数"></a>1. 最大数</h2><h3 id="题目链接：-9"><a href="#题目链接：-9" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/1277/">最大数</a></p><h3 id="题解思路：-9"><a href="#题解思路：-9" class="headerlink" title="题解思路："></a>题解思路：</h3><p>线段树</p><ol><li>用线段树维护区间最大值</li><li>查询时<ul><li><code>[tr.l , tr.r] 属于 [l, r]</code>直接返回<code>[tr.l, tr.r]</code>区间内维护的最大值即可</li><li>l &lt;= mid说明有左边部分，递归往左边查询即可</li><li>r&gt;mid说明有右边部分，递归往右边查询即可</li></ul></li><li>修改时<ul><li>递归调用，直至叶节点，修改叶节点的值</li><li>pushup一下，将子节点的信息更新到父节点上</li></ul></li></ol><h3 id="题目代码：-9"><a href="#题目代码：-9" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> m, p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般开的空间大小为4*N</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> v; <span class="comment">//维护区间最大值</span></span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span>  <span class="comment">// 由子节点的信息，来计算父节点的信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].v = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].v, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线段树，u为当前线段树的节点编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="comment">//l == r说明是叶子节点直接退出</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询以u为根节点，[l,r]中的最大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//区间[tr[u].l, tr[u].r] 属于区间[l, r],直接返回就得到当前区间最大值</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].v; </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左边</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) v = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l , r); <span class="comment">//往左边查询</span></span><br><span class="line">    <span class="comment">//右边</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) v = <span class="built_in">max</span>(v, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l ,r)); <span class="comment">//取右边与左边的最大值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//u为节点为编号，更新该节点的最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == tr[u].r) tr[u].v = v;  <span class="comment">//叶节点，递归出口</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//分治处理左右子树, 寻找x所在的子树</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="comment">//pushup操作, 子结点的信息更新父节点</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, last = <span class="number">0</span>; <span class="comment">// n表示树中节点个数、last表示上一次操作</span></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, m); <span class="comment">//初始化线段树，节点的区间[1, m]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)&#123;       <span class="comment">//添加结点</span></span><br><span class="line">            <span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, n + <span class="number">1</span>, ((LL)t + last) % p); <span class="comment">//在n + 1处插入   </span></span><br><span class="line">            n++;    <span class="comment">//结点个数+1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;        <span class="comment">//询问</span></span><br><span class="line">            <span class="type">int</span> L; cin &gt;&gt; L;</span><br><span class="line">            last = <span class="built_in">query</span>(<span class="number">1</span>, n - L + <span class="number">1</span>, n); <span class="comment">//查询[n - L + 1, n]内的最大值，u = 1，即从根节点开始查询</span></span><br><span class="line">            cout &lt;&lt; last &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-你能回答这些问题吗"><a href="#2-你能回答这些问题吗" class="headerlink" title="2. 你能回答这些问题吗"></a>2. 你能回答这些问题吗</h2><h3 id="题目链接：-10"><a href="#题目链接：-10" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/246/">你能回答这些问题吗</a></p><h3 id="题解思路：-10"><a href="#题解思路：-10" class="headerlink" title="题解思路："></a>题解思路：</h3><p>思路：</p><ol><li><p>维护四个数值：</p><ul><li>tmax：最大连续子段和</li><li>lmax：最大前缀和</li><li>rmax：最大后缀和</li><li>sum：区间和</li></ul></li><li><p>确定tmax:</p><p>$tmax = max(left-son.tmax, right-son.tmax, left-son.rmax + right-son.lmax)$</p></li><li><p>确定lmax,rmax:</p><p>以维护lmax为例：</p><ul><li>完全在左区间内：左边的lmax</li><li>横跨两个区间：左边的sum+右边的lmax</li></ul><p>rmax同理</p></li></ol><h3 id="题目代码：-10"><a href="#题目代码：-10" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> w[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> tmax, lmax, rmax, sum;  <span class="comment">//维护最大连续子段和、最大前缀和、最大后缀和、区间和</span></span><br><span class="line">&#125;tr[<span class="number">4</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;                              <span class="comment">//区间和</span></span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);               <span class="comment">//前缀和等于两种请况取最大值（左区间的前缀和，左区间的sum + 右区间的前缀和）</span></span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);               <span class="comment">//后缀和同理</span></span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax, r.tmax), l.rmax + r.lmax); <span class="comment">//最大连续字段和取三种情况的最大和（左区间tmax,右区间tmax,在中间（左区间后缀+右区间前缀和））</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果是叶节点,叶节点直接赋值</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;; </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l , r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r); <span class="comment">//递归建立左右子树</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);  <span class="comment">//子节点去更新父节点的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果到达叶节点</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x) tr[u] = &#123;x, x, v, v, v, v&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid &gt;= x)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);   <span class="comment">//往左边递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);      <span class="comment">//往右边递归</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);      <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询区间包含当前线段树区间</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid &gt;= r) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);            <span class="comment">//在左</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);    <span class="comment">//在右边</span></span><br><span class="line">        <span class="keyword">else</span>&#123;                                               <span class="comment">//横跨两个区间</span></span><br><span class="line">            Node left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);            </span><br><span class="line">            Node right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">            Node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> k, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, x, y).tmax);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-区间最大公约数"><a href="#3-区间最大公约数" class="headerlink" title="3. 区间最大公约数"></a>3. 区间最大公约数</h2><h3 id="题目链接：-11"><a href="#题目链接：-11" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/247/">区间最大公约数</a></p><h3 id="题解思路：-11"><a href="#题解思路：-11" class="headerlink" title="题解思路："></a>题解思路：</h3><p>操作1：区间<code>[l,r]</code>增加一个数</p><p>操作2：区间<code>[l,r]</code>最大公约数</p><p>思路：</p><ol><li><p>将区间增加一个数，转换为单点增加一个数，可以推出用差分。</p></li><li><p>证明差分数组和原数组某个区间内有共同的最大公因数。</p><ul><li>($a<em>1,a_2,···，a_n$）= （$a_1,a_2-a_1,···，a_n-a</em>{n-1} $）</li><li>gcd(a, b) = gcd(a, b - a)</li><li>gcd(a, b) = gcd(a, -b)</li></ul></li><li><p>查询某个区间<code>[l, r]</code>的最大公约数</p><p>$gcd(a[l], gcd(b[l + 1], b[r]))$</p></li></ol><h3 id="题目代码：-11"><a href="#题目代码：-11" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;        </span><br><span class="line">LL w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL sum, d;</span><br><span class="line">&#125;tr[<span class="number">4</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span>  <span class="comment">//求最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span>  <span class="comment">//由子区间信息更新父区间信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;  <span class="comment">// 区间和</span></span><br><span class="line">    u.d = <span class="built_in">gcd</span>(l.d, r.d);    <span class="comment">//左右区间最大公约数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span>         </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l = l, tr[u].r = r;</span><br><span class="line">    <span class="keyword">if</span> ( l == r ) </span><br><span class="line">        tr[u].d = w[l] - w[l - <span class="number">1</span>], tr[u].sum = w[l] - w[l - <span class="number">1</span>]; <span class="comment">//将差分数组维护到线段树中去</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);      <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, LL v)</span>         </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//叶节点</span></span><br><span class="line">    <span class="keyword">if</span> ( tr[u]. r == x &amp;&amp; tr[u].l == x ) </span><br><span class="line">        tr[u].d = tr[u].sum + v, tr[u].sum += v;        </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;       </span><br><span class="line">        <span class="keyword">if</span> ( mid &gt;= x ) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);   <span class="comment">//修改左区间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);          <span class="comment">//修改右区间</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查询区间包含当前线段树区间</span></span><br><span class="line">    <span class="keyword">if</span> ( tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r ) <span class="keyword">return</span> tr[u];   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( mid &gt;= r ) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( mid &lt; l ) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);        <span class="comment">//如果当前访问区间的子区间横跨询问区间</span></span><br><span class="line">            Node right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);   <span class="comment">//则递归两个子区间</span></span><br><span class="line">            Node res;                               </span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right);               <span class="comment">//更新，相当于求right和left区间合并后的结果</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin  &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n); <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL d;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, l);     <span class="comment">//求前缀和得到a[l]</span></span><br><span class="line">            <span class="function">Node <span class="title">right</span><span class="params">(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (l + <span class="number">1</span> &lt;= r) right = <span class="built_in">query</span>(<span class="number">1</span>, l + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">abs</span>(<span class="built_in">gcd</span>(left.sum, right.d)));  <span class="comment">//gcd(a[l], gcd(b[l + 1], b[r]))</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, d);</span><br><span class="line">            <span class="keyword">if</span> ( r + <span class="number">1</span> &lt;= n ) <span class="built_in">modify</span>(<span class="number">1</span>, r + <span class="number">1</span>, -d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-一个简单的整数问题2"><a href="#4-一个简单的整数问题2" class="headerlink" title="4. 一个简单的整数问题2"></a>4. 一个简单的整数问题2</h2><h3 id="题目链接：-12"><a href="#题目链接：-12" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/description/244/">一个简单的整数问题2</a></p><h3 id="题解思路：-12"><a href="#题解思路：-12" class="headerlink" title="题解思路："></a>题解思路：</h3><p>最基本的线段树做法（添加懒标记）</p><ul><li><p>类似于查询的时候，找到一个完整区间的时候直接标记一下（需要维护一个add）。</p></li><li><p>维护一个add(懒标记)，以当前节点为根的子树中的每一个节点加上一个add（不包含根节点）。</p></li><li><p>在pushdown的时候被标记的节点如果继续往下递归的话，就将当前节点的标记取消并且递归到子节点上，这样所有叶子节点的祖宗节点的标记已经取消掉，并且累加到此叶子节点上了。</p><p><code>left.add += root.add, left.sum += (left.r - left.l + 1) * root.add</code></p><p><code>right.add += root.add, right += (right.r - right.l + 1) * root.add</code></p><p><code>root.add = 0</code></p></li></ul><h3 id="题目代码：-12"><a href="#题目代码：-12" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> w[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum, add;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum; <span class="comment">//左右儿子之和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add)&#123;</span><br><span class="line">        left.add += root.add, left.sum += (ll)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (ll)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改之前也需要pushdown()一下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;</span><br><span class="line">        tr[u].sum += (ll)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//分裂的情况</span></span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询之前一定要pushdown()一下</span></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-亚特兰蒂斯"><a href="#5-亚特兰蒂斯" class="headerlink" title="5. 亚特兰蒂斯"></a>5. 亚特兰蒂斯</h2><h3 id="题目链接：-13"><a href="#题目链接：-13" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/249/">亚特兰蒂斯</a></p><h3 id="题解思路：-13"><a href="#题解思路：-13" class="headerlink" title="题解思路："></a>题解思路：</h3><p>线段树+扫描线+离散化</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220310200933974.png" alt=""></p><p>操作一：将某一个区间[l, r] + k</p><p>操作二：整个区间中权值大于0的总长是多少</p><p>需要用离散化去处理y坐标，但是线段树维护的是y这个区间。</p><p>线段树中的节点信息：</p><ol><li>cnt 当前区间整个被覆盖的次数</li><li>len 不考虑祖先节点cnt的前提下cnt&gt;0的区间总长</li></ol><p>扫描线：</p><ol><li>永远只考虑根节点的信息（说明在query的时候不需要pushdown）</li><li>所有操作都是成对出现，且先加后减</li></ol><h3 id="题目代码：-13"><a href="#题目代码：-13" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">double</span>&gt;ys;<span class="comment">//用于离散化</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存线段信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y1, y2;</span><br><span class="line">    <span class="type">int</span> d; <span class="comment">// 区分它是该矩阵前面的线段还是后面的线段</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> segment&amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">     &#125; </span><br><span class="line">&#125;seg[N * <span class="number">2</span>];<span class="comment">//每个矩阵需要存两个线段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树的每个节点 保存的为线段, 0号点为y[0]到y[1]，以此类推</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> cnt;    <span class="comment">// 记录当前区间整个被覆盖的次数</span></span><br><span class="line">    <span class="type">double</span> len; <span class="comment">// 记录这段区间的长度</span></span><br><span class="line">&#125;tr[N * <span class="number">8</span>];     <span class="comment">//由于线段二倍，所以8倍空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回第一个 &gt;= y 的数的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), y) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].cnt)tr[u].len = ys[tr[u].r + <span class="number">1</span>] - ys[tr[u].l];<span class="comment">//表示整个区间都被覆盖，该段长度就为右端点 + 1后在ys中的值 - 左端点在ys中的值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l != tr[u].r)&#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>;<span class="comment">//表示为叶子节点且该线段没被覆盖，为无用线段，长度变为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;</span><br><span class="line">        tr[u].cnt += d;     </span><br><span class="line">        <span class="built_in">pushup</span>(u);          <span class="comment">//更新该节点的len</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].r + tr[u].l &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);      <span class="comment">//左边存在点</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);   <span class="comment">//右边存在点</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);      <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l != r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>,l,mid),<span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">        <span class="comment">//后面都为0，不需更新len</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        ys.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;              <span class="comment">//线段个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++) &#123;</span><br><span class="line">            <span class="type">double</span> x1,y1,x2,y2;</span><br><span class="line">            cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">            seg[j ++] = &#123;x1, y1, y2, <span class="number">1</span>&#125;;        <span class="comment">//前面的线段</span></span><br><span class="line">            seg[j ++] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;       <span class="comment">//后面的线段</span></span><br><span class="line">            ys.<span class="built_in">push_back</span>(y1), ys.<span class="built_in">push_back</span>(y2);  <span class="comment">//y轴出现过那些点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(seg,seg + j);          <span class="comment">//线段按x排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//去重</span></span><br><span class="line">        <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());  </span><br><span class="line">        ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());<span class="comment">//离散化去重</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, ys.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; j ; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i)res += tr[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x); <span class="comment">//根节点的长度即为此时有效线段长度 ，再 * x轴长度即为面积</span></span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>, T ++ );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="6-维护序列"><a href="#6-维护序列" class="headerlink" title="6. 维护序列"></a>6. 维护序列</h2><h3 id="题目链接：-14"><a href="#题目链接：-14" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/1279/">维护序列</a></p><h3 id="题解思路：-14"><a href="#题解思路：-14" class="headerlink" title="题解思路："></a>题解思路：</h3><p>线段树需要维护的信息：</p><p>sum、add、mul 需要有两个懒标记，先乘再加，方便更新mul和add</p><p>只是基础线段树的一个拓展</p><h3 id="题目代码：-14"><a href="#题目代码：-14" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, p, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, add, mul;  <span class="comment">//维护一个乘一个加,先乘后加使得便于维护</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    tr[u].sum = (tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % p; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(Node &amp;t, <span class="type">int</span> add, <span class="type">int</span> mul)</span> </span>&#123;</span><br><span class="line">    t.sum = ((LL)t.sum * mul + (LL)(t.r - t.l + <span class="number">1</span>) * add) % p; <span class="comment">//计算总和</span></span><br><span class="line">    t.mul = (LL)t.mul * mul % p;            <span class="comment">//先乘后加使得便于维护</span></span><br><span class="line">    t.add = ((LL)t.add * mul + add) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消除祖宗节点的标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span>], tr[u].add, tr[u].mul); </span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);  <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> add, <span class="type">int</span> mul)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="built_in">eval</span>(tr[u], add, mul);    <span class="comment">//计算一下当前节点的值</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, add, mul);   <span class="comment">//修改左右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum = (sum + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r)) % p;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="type">int</span> t, l, r, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, <span class="number">0</span>, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可持久化数据结构"><a href="#可持久化数据结构" class="headerlink" title="可持久化数据结构"></a>可持久化数据结构</h1><ol><li>trie的可持久化</li><li>线段树的可持久化——主席树</li></ol><p>可持久化的前提：本身拓扑结构、不变</p><p>解决的问题：将所有数据结构的历史版本都保存下来（有点像git）</p><p>核心思想：只记录每一个版本与前一个版本不同的节点</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220311172906244.png" alt=""></p><h2 id="1-最大异或和"><a href="#1-最大异或和" class="headerlink" title="1. 最大异或和"></a>1. 最大异或和</h2><h3 id="题目链接：-15"><a href="#题目链接：-15" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/description/258/">最大异或和</a></p><h3 id="题解思路：-15"><a href="#题解思路：-15" class="headerlink" title="题解思路："></a>题解思路：</h3><ol><li>求出前缀异或和，每次所求就是：$S<em>{p-1}\ xor\ S</em>{N}\ xor \ x = c$使得在l,r内c最大。</li><li>但是会有A操作在数组尾添加元素，这样就会影响到查询的结果，所有用可持久化维护各个版本，求[1, R]可用root[R]以及上述公式来求最大c。</li><li>但是同时又得求[L ,R]之内得最大c,所有需要trie维护一个信息，max-id（当前子树下标的最大值），只要当前子树下标最大值符合[L , R]就可以继续往当前子树查询。</li></ol><h3 id="题目代码：-15"><a href="#题目代码：-15" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 30w初始数据和30w新增,  而10的7次方小于2的24次方, 再加上根节点, 就是说每个数最多需要25位;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">600010</span>, M = N * <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和序列</span></span><br><span class="line"><span class="type">int</span> tr[M][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> max_id[M];  <span class="comment">// 用于记录当前根节点版本的最大id范围</span></span><br><span class="line"><span class="type">int</span> root[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i是第i个插入的数的i, p是上一个插入的数的节点号, q是当前节点号, k是现在取到第k位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> k, <span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果记录结束了</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max_id[q] = i;  <span class="comment">// 记录当前节点(可能会被后面公用)所能到达的最大范围i</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出前缀和的二进制表示从右往左数第k位v</span></span><br><span class="line">    <span class="comment">// 需要注意的是, 这个s[i]就是我们要存的东西!!!!!</span></span><br><span class="line">    <span class="type">int</span> v = s[i] &gt;&gt; k &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前一个节点存在当前节点没有的分支, 那就把当前节点的这个空的路径指过去, 这就相当于复制!</span></span><br><span class="line">    <span class="keyword">if</span> (p) tr[q][v ^ <span class="number">1</span>] = tr[p][v ^ <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    tr[q][v] = ++idx; <span class="comment">// 现在才是正常trie树插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归插入下一位二进制, tr[q][v]就是我们本轮插入的新节点</span></span><br><span class="line">    <span class="comment">// 而前面我们只复制了前一轮的不同v方向的路径, v方向的还没动过, 于是放到p里面等下一轮</span></span><br><span class="line">    <span class="comment">// 至于为什么可以放到下一轮, 因为当前q新插入的数字(二进制当前位)是v, 而p的这条路径也是v</span></span><br><span class="line">    <span class="comment">// 所以暂时不需要复制</span></span><br><span class="line">    <span class="built_in">insert</span>(i, k - <span class="number">1</span>, tr[p][v], tr[q][v]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是递归到所有点都插入完成才开始进行的, 所以能把最大max_id递归传递回去</span></span><br><span class="line">    <span class="comment">// 每个点的最大范围用子节点最大的值, 然后还能递归传递回去, 因为当前递归层</span></span><br><span class="line">    <span class="comment">// 的q, 就是上一层的tr[q][v], 观察易知每个节点都会有对应max_id</span></span><br><span class="line">    max_id[q] = <span class="built_in">max</span>(max_id[tr[q][<span class="number">0</span>]], max_id[tr[q][<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> C, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 选用合适的root, 就是第r-1个节点作为root(-1已在传参前完成)</span></span><br><span class="line">    <span class="comment">// 然后根据异或的前缀和性质才能保证在r左边</span></span><br><span class="line">    <span class="type">int</span> p = root[r];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">23</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// C是s[n] ^ x, 从高位到低位逐位检索二进制每一位上能跟C异或结果最大的数</span></span><br><span class="line">        <span class="type">int</span> v = C &gt;&gt; i &amp; <span class="number">1</span>; </span><br><span class="line">        <span class="comment">// 自带判空功能如果没有点, max_id会为0, 那就肯定不能满足&gt;=l</span></span><br><span class="line">        <span class="comment">// 而max_id又同时可以限制当前的点是在l r区间内</span></span><br><span class="line">        <span class="comment">// 另外, 如果tr[p][v^1]为空, 那么tr[p][v]就肯定不为空,并在l r区间, 因为根据</span></span><br><span class="line">        <span class="comment">// 插入的代码, 每个节点至少有一条当前s[i]的完整路径</span></span><br><span class="line">        <span class="comment">// 而如果tr[p][v^1]不为空但maxid小于l, 同理也能选取到tr[p][v]</span></span><br><span class="line">        <span class="keyword">if</span> (max_id[tr[p][v ^ <span class="number">1</span>]] &gt;= l) p = tr[p][v ^ <span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">else</span> p = tr[p][v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C ^ s[max_id[p]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// 前缀和, 初始化root[0]</span></span><br><span class="line">    max_id[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    root[<span class="number">0</span>] = ++idx;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">23</span>, <span class="number">0</span>, root[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] ^ x; <span class="comment">// 前缀和序列</span></span><br><span class="line">        root[i] = ++idx;</span><br><span class="line">        <span class="built_in">insert</span>(i, <span class="number">23</span>, root[i - <span class="number">1</span>], root[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r, x;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            n++;</span><br><span class="line">            s[n] = s[n - <span class="number">1</span>] ^ x;</span><br><span class="line">            root[n] = ++idx;</span><br><span class="line">            <span class="built_in">insert</span>(n, <span class="number">23</span>, root[n - <span class="number">1</span>], root[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">            <span class="comment">// 至少要包住第r个点, 所以用r-1, 否则会因为异或把root[r]抵消掉</span></span><br><span class="line">            <span class="comment">// l也同理</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(r - <span class="number">1</span>, s[n] ^ x, l - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-可持久化线段树（主席树）"><a href="#2-可持久化线段树（主席树）" class="headerlink" title="2. 可持久化线段树（主席树）"></a>2. 可持久化线段树（主席树）</h2><h3 id="题目链接：-16"><a href="#题目链接：-16" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/description/258/">最大异或和</a></p><h3 id="题解思路：-16"><a href="#题解思路：-16" class="headerlink" title="题解思路："></a>题解思路：</h3><p>此题可用方法：</p><ol><li>树套树：（$O(mlog^2n)$）支持修改</li><li>划分树：（$O(nlogn)$）不支持修改</li><li>主席树：（$O(nlogn)$）</li></ol><p>采用主席树：</p><p>核心：把新得点替换掉原来的点,结构一样，信息不一样</p><ol><li>离散化</li><li>在数值上建立线段树，维护每个数值区间个数，求整体第k小的数。</li></ol><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220314091721203.png" alt=""></p><p>缺点：难以进行区间修改操作</p><p>0————-mid————-n-1     mid的左边的个数cnt如果大于k说明第k个数在左边，cnt &lt;= k 说明在右边</p><p>此题可以维护每个版本的各个数值区间的个数，因为每个版本结构都是一样的，但是只是信息不同，所以只要用第R个版本减去L-1个版本就可以得到[L， R]这一段这个区间里面0————-mid————-n-1有多少个数。 </p><h3 id="题目代码：-16"><a href="#题目代码：-16" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], root[N], idx;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;   <span class="comment">//左右孩子，不是区间</span></span><br><span class="line">    <span class="type">int</span> cnt; <span class="comment">//维护数值区间的个数</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span> + N * <span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), x) - nums.<span class="built_in">begin</span>(); <span class="comment">//返回第一个大于等于x的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = ++idx; <span class="comment">//一个新得节点</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> p; <span class="comment">//叶节点</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[p].l = <span class="built_in">build</span>(l, mid), tr[p].r = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> p;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = ++idx; <span class="comment">//一个新得节点</span></span><br><span class="line">    tr[q] = tr[p]; <span class="comment">//新节点指向旧节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;     <span class="comment">//叶节点</span></span><br><span class="line">        tr[q].cnt++;    <span class="comment">//当前这个值的元素个数+1</span></span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) tr[q].l = <span class="built_in">insert</span>(tr[p].l, l, mid, x);  <span class="comment">//元素比中间值小，往左边插入</span></span><br><span class="line">    <span class="keyword">else</span> tr[q].r = <span class="built_in">insert</span>(tr[p].r, mid + <span class="number">1</span>, r, x);      <span class="comment">//元素比中间值大，往右边插入</span></span><br><span class="line">    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;      <span class="comment">//父节点的总个数等于左右儿子节点的总个数</span></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此题可以维护每个版本的各个数值区间的个数</span></span><br><span class="line"><span class="comment">//因为每个版本结构都是一样的，但是只是信息不同</span></span><br><span class="line"><span class="comment">//所以只要用第R个版本减去L-1个版本就可以得到[L， R]这一段这个区间里面0---------mid---------n-1有多少个数。 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> q, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> r; <span class="comment">//找到</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// R版本减去 L-1版本就是【L, R】这个区间中添加的各个数</span></span><br><span class="line">    <span class="type">int</span> cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;  </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// k &lt;= cnt说明要找的元素在q的左子树里面</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= cnt) <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].l, tr[p].l, l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].r, tr[p].r, mid<span class="number">+1</span>, r, k - cnt);     <span class="comment">//减去左半部分总数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        nums.<span class="built_in">push_back</span>(a[i]); <span class="comment">//离散化数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//去重</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">//初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//相当于n次操作维护各个版本</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">//根据前一个版本创建一个新得节点指向前一个版本各个修改的信息</span></span><br><span class="line">        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>], <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="built_in">find</span>(a[i])); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m -- )&#123;</span><br><span class="line">        <span class="type">int</span> l, r, k;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nums[<span class="built_in">query</span>(root[r], root[l - <span class="number">1</span>], <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, k)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平衡树——Treap"><a href="#平衡树——Treap" class="headerlink" title="平衡树——Treap"></a>平衡树——Treap</h1><p>treap、红黑树、splay、sbt、AVL</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>对于一棵树，我们可以做一些特殊的操作，来让它变换树的形态结构，但是最后的答案却是正确的。平衡树的精髓就是这个，就是改变树的形态结构，但是不改变最后的中序遍历,也就是答案数组。</p><ol><li><p>首先需要维护一个BST(二叉搜索树)，一个根节点p，左儿子一定小于他，右儿子大于它。</p></li><li><p>为了维护这个BST我们需要一个<strong>左旋zag和右旋zig</strong>，分别表示将根节点和左右儿子交换位置，使交换后还<strong>满足BST的性质</strong>。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220315114510822.png" alt=""></p></li><li><p>为了使得这个BST是一个尽可能随机的（添加随机数val<strong>维护这个堆</strong>）使得这个BST的期望更加好一些（防止出现一条链的情况使得BST的时间复杂度达到O(n)）</p></li></ol><p>操作：</p><ol><li>插入数值 xx。</li><li>删除数值 xx(若有多个相同的数，应只删除一个)。</li><li>查询数值 xx 的排名(若有多个相同的数，应输出最小的排名)。</li><li>查询排名为 xx 的数值。</li><li>求数值 xx 的前驱(前驱定义为小于 xx 的最大的数)。</li><li>求数值 xx 的后继(后继定义为大于 xx 的最小的数)。</li></ol><h2 id="1-普通平衡树"><a href="#1-普通平衡树" class="headerlink" title="1. 普通平衡树"></a>1. 普通平衡树</h2><h3 id="题目链接：-17"><a href="#题目链接：-17" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/description/258/">普通平衡树</a></p><h3 id="题解思路：-17"><a href="#题解思路：-17" class="headerlink" title="题解思路："></a>题解思路：</h3><p>Treap</p><ol><li>维护键值key——BST，同时维护随机值val——堆</li><li>这样使得这颗树时间复杂度更加趋近于（logn）,防止出现一条链</li></ol><h3 id="题目代码：-17"><a href="#题目代码：-17" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, root, idx;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> key, val;   <span class="comment">//key当前键值，val随机值，使得这个treap更加随机</span></span><br><span class="line">    <span class="type">int</span> cnt, size;  <span class="comment">//cnt当前节点的个数</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    tr[u].size = tr[tr[u].l].size + tr[tr[u].r].size + tr[u].cnt;<span class="comment">//字节点更新父节点信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新得节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123; </span><br><span class="line">    tr[ ++ idx].key = key;  <span class="comment">//新得节点的键值</span></span><br><span class="line">    tr[idx].val = <span class="built_in">rand</span>();   <span class="comment">//随机值，根据这个维护一个堆</span></span><br><span class="line">    tr[idx].cnt = tr[idx].size = <span class="number">1</span>; <span class="comment">//初始节点的个数等于1，以及当前子树的大小也是1</span></span><br><span class="line">    <span class="keyword">return</span> idx;             <span class="comment">//返回这个节点所对应的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zig</span><span class="params">(<span class="type">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].l;</span><br><span class="line">    tr[p].l = tr[q].r, tr[q].r = p, p = q; </span><br><span class="line">    <span class="built_in">pushup</span>(tr[p].r), <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zag</span><span class="params">(<span class="type">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].r;</span><br><span class="line">    tr[p].r = tr[q].l, tr[q].l = p, p = q;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[p].l), <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">get_node</span>(-INF), <span class="built_in">get_node</span>(INF);  <span class="comment">//创建两个哨兵</span></span><br><span class="line">    root = <span class="number">1</span>, tr[<span class="number">1</span>].r = <span class="number">2</span>;          </span><br><span class="line">    <span class="built_in">pushup</span>(root);                   <span class="comment">//更新</span></span><br><span class="line">    <span class="keyword">if</span> (tr[<span class="number">1</span>].val &lt; tr[<span class="number">2</span>].val) <span class="built_in">zag</span>(root);   <span class="comment">//父节点的val &lt; 右子节点的val左旋</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = <span class="built_in">get_node</span>(key);                      <span class="comment">//如果之前没有的话就创建一个新得节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key == key) tr[p].cnt ++ ;       <span class="comment">//如果之前存在就直接再cnt++</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key &gt; key)                       <span class="comment">//key小于当前节点的值往左边递归插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].l, key);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[p].l].val &gt; tr[p].val) <span class="built_in">zig</span>(p);    <span class="comment">//需要维护val    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                        <span class="comment">//key大于当前节点的值往右边递归插入</span></span><br><span class="line">        <span class="built_in">insert</span>(tr[p].r, key);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[p].r].val &gt; tr[p].val) <span class="built_in">zag</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(p);  <span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;         <span class="comment">//不存在这个点，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tr[p].key == key) &#123;     </span><br><span class="line">        <span class="keyword">if</span> (tr[p].cnt &gt; <span class="number">1</span>) tr[p].cnt -- ;   <span class="comment">//这个点的数量大于1，数量--</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].l || tr[p].r) &#123;      <span class="comment">//这个点左右子树都不空</span></span><br><span class="line">            <span class="keyword">if</span> (!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val) &#123;    <span class="comment">//右旋</span></span><br><span class="line">                <span class="built_in">zig</span>(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;                          <span class="comment">//左旋</span></span><br><span class="line">                <span class="built_in">zag</span>(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = <span class="number">0</span>; <span class="comment">//叶子节点，左右子树都空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key &gt; key) <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(p);  <span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过数值找排名</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_rank_by_key</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">if</span> (tr[p].key == key) <span class="keyword">return</span> tr[tr[p].l].size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &gt; key) <span class="keyword">return</span> <span class="built_in">get_rank_by_key</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> tr[tr[p].l].size + tr[p].cnt + <span class="built_in">get_rank_by_key</span>(tr[p].r, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过排名找数值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_key_by_rank</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;     </span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].size &gt;= rank) <span class="keyword">return</span> <span class="built_in">get_key_by_rank</span>(tr[p].l, rank);    </span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].size + tr[p].cnt &gt;= rank) <span class="keyword">return</span> tr[p].key;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_key_by_rank</span>(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到严格小于key的最大数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prev</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &gt;= key) <span class="keyword">return</span> <span class="built_in">get_prev</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key, <span class="built_in">get_prev</span>(tr[p].r, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到严格大于key的最小数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &lt;= key) <span class="keyword">return</span> <span class="built_in">get_next</span>(tr[p].r, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key, <span class="built_in">get_next</span>(tr[p].l, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- ) &#123;</span><br><span class="line">        <span class="type">int</span> op, x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">insert</span>(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) <span class="built_in">remove</span>(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) cout &lt;&lt; <span class="built_in">get_rank_by_key</span>(root, x) - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) cout &lt;&lt; <span class="built_in">get_key_by_rank</span>(root, x + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) cout &lt;&lt; <span class="built_in">get_prev</span>(root, x) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">get_next</span>(root, x) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-营业额统计"><a href="#2-营业额统计" class="headerlink" title="2. 营业额统计"></a>2. 营业额统计</h2><h3 id="题目链接：-18"><a href="#题目链接：-18" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/267/">营业额统计</a></p><h3 id="题解思路：-18"><a href="#题解思路：-18" class="headerlink" title="题解思路："></a>题解思路：</h3><p>可以用set的lower_bound(), upper_bound()</p><p>也可用平衡树</p><h3 id="题目代码：-18"><a href="#题目代码：-18" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">33000</span>, INF = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> key, val;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root, idx, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新得节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    tr[++idx].key = key;</span><br><span class="line">    tr[idx].val = <span class="built_in">rand</span>(); <span class="comment">//使得平衡树更加随机，期望更高</span></span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_node</span>(-INF), <span class="built_in">get_node</span>(INF);</span><br><span class="line">    root = <span class="number">1</span>, tr[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zig</span><span class="params">(<span class="type">int</span> &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].l;</span><br><span class="line">    tr[p].l = tr[q].r, tr[q].r = p, p = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zag</span><span class="params">(<span class="type">int</span> &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].r;</span><br><span class="line">    tr[p].r = tr[q].l, tr[q].l = p, p = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p = <span class="built_in">get_node</span>(key); <span class="comment">//没有这个节点就直接创建这个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key == key) <span class="keyword">return</span>;   <span class="comment">//之前有这个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key &gt; key)&#123;           <span class="comment">//插入到当前节点左边</span></span><br><span class="line">        <span class="built_in">insert</span>(tr[p].l, key); </span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].l].val &gt; tr[p].val) <span class="comment">//检查子节点的val是否大于父节点</span></span><br><span class="line">            <span class="built_in">zig</span>(p);                     <span class="comment">//右旋</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].r, key);</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].r].val &gt; tr[p].val) <span class="comment">//检查子节点的val是否大于父节点</span></span><br><span class="line">            <span class="built_in">zag</span>(p);                     <span class="comment">//左旋</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到小于等于key的最大数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prev</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key &gt; key) <span class="keyword">return</span> <span class="built_in">get_prev</span>(tr[p].l, key); <span class="comment">//往左边查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key, <span class="built_in">get_prev</span>(tr[p].r, key)); <span class="comment">//右边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到大于等于key的最小的数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &lt; key) <span class="keyword">return</span> <span class="built_in">get_next</span>(tr[p].r, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key, <span class="built_in">get_next</span>(tr[p].l, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)res += x;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res += <span class="built_in">min</span>(x - <span class="built_in">get_prev</span>(root, x), <span class="built_in">get_next</span>(root, x) - x); <span class="comment">//x与x的前一个值的差值，x与后一个值的差值</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">insert</span>(root, x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p>ac自动机 = trie + kmp</p><p>next[i]: 在p中以p[i]结尾的后缀，能够匹配从1开始的（非平凡）前缀的最大长度</p><p>ac自动机就是对trie求next</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220315144630861.png" alt=""></p><p>用BFS的思想，一层一层遍历，对应于一维求next数组</p><h2 id="1-搜索关键词"><a href="#1-搜索关键词" class="headerlink" title="1. 搜索关键词"></a>1. 搜索关键词</h2><h3 id="题目链接：-19"><a href="#题目链接：-19" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/description/1284/">搜索关键词</a></p><h3 id="题解思路：-19"><a href="#题解思路：-19" class="headerlink" title="题解思路："></a>题解思路：</h3><p>用BFS的思想，一层一层遍历，对应于一维求next数组</p><h3 id="题目代码：-19"><a href="#题目代码：-19" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, S = <span class="number">55</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tr[N * S][<span class="number">26</span>], cnt[N * S], idx;</span><br><span class="line"><span class="type">char</span> str[M];</span><br><span class="line"><span class="type">int</span> q[N * S], ne[N * S], tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trie树插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!tr[p][t]) tr[p][t] = ++ idx; <span class="comment">//创建一个节点</span></span><br><span class="line">        p = tr[p][t];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ; <span class="comment">//此节点个数++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于处理next数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (tr[<span class="number">0</span>][i])   <span class="comment">//如果第一个字母没有就不用入队</span></span><br><span class="line">            q[ ++ tt] = tr[<span class="number">0</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ ) &#123;    <span class="comment">//遍历当前节点的所有子节点</span></span><br><span class="line">            <span class="type">int</span> c = tr[t][i];   <span class="comment">//对应当前节点</span></span><br><span class="line">            <span class="keyword">if</span>(!c)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> j = ne[t];      <span class="comment">//对应前面的状态，也就是前面的层</span></span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; !tr[j][i]) j =  ne[j];   <span class="comment">//如果这个节点是空的话就查找ne数组</span></span><br><span class="line">            <span class="keyword">if</span>(tr[j][i]) j = tr[j][i];</span><br><span class="line">            ne[c] = j;</span><br><span class="line">            q[++tt] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="built_in">memset</span>(ne, <span class="number">0</span>, <span class="keyword">sizeof</span> ne);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="built_in">insert</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; !tr[j][t]) j = ne[j];    </span><br><span class="line">            <span class="keyword">if</span>(tr[j][t]) j = tr[j][t];</span><br><span class="line">            <span class="type">int</span> p = j;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                res += cnt[p];</span><br><span class="line">                cnt[p] = <span class="number">0</span>;</span><br><span class="line">                p = ne[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以优化成一个trie图</p><p>将空节点的指针指向它父节点的next指向的位置，这样就相当于每个空姐点都会直接指向它对应得next节点上去</p><p>有点路径压缩的感觉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, S = <span class="number">55</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tr[N * S][<span class="number">26</span>], cnt[N * S], idx;</span><br><span class="line"><span class="type">char</span> str[M];</span><br><span class="line"><span class="type">int</span> q[N * S], ne[N * S], tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trie树插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!tr[p][t]) tr[p][t] = ++ idx; <span class="comment">//创建一个节点</span></span><br><span class="line">        p = tr[p][t];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ; <span class="comment">//此节点个数++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于处理next数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (tr[<span class="number">0</span>][i])   <span class="comment">//如果第一个字母没有就不用入队</span></span><br><span class="line">            q[ ++ tt] = tr[<span class="number">0</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ ) &#123;    <span class="comment">//遍历当前节点的所有子节点</span></span><br><span class="line">            <span class="type">int</span> p = tr[t][i];               <span class="comment">//对应当前节点</span></span><br><span class="line">            <span class="keyword">if</span>(!p) tr[t][i] = tr[ne[t]][i]; <span class="comment">//直接跳到对应得位置，有点路径压缩的感觉</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ne[p] = tr[ne[t]][i];       </span><br><span class="line">                q[++ tt] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="built_in">memset</span>(ne, <span class="number">0</span>, <span class="keyword">sizeof</span> ne);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="built_in">insert</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            j = tr[j][t]; <span class="comment">//下一个节点</span></span><br><span class="line">            <span class="type">int</span> p = j;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;       <span class="comment">//下一个节点，不为空</span></span><br><span class="line">                res += cnt[p];</span><br><span class="line">                cnt[p] = <span class="number">0</span>;</span><br><span class="line">                p = ne[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-单词"><a href="#2-单词" class="headerlink" title="2. 单词"></a>2. 单词</h2><h3 id="题目链接：-20"><a href="#题目链接：-20" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a href="https://www.acwing.com/problem/content/description/1287/">单词</a></p><h3 id="题解思路：-20"><a href="#题解思路：-20" class="headerlink" title="题解思路："></a>题解思路：</h3><p>去求所有满足要求的前缀个数：</p><p>所有满足要求的前缀其后缀一定等于原串单词。</p><p>需要反向来求：</p><p>trie是通过next指针，根据地推的思想一直往前推，next可以求出前一个满足要求的前缀（可以和后缀匹配），可以一直跟着next指针一直往前走。</p><p>对于i来说可以用next指针将f[i] 累加到f[next[i]]上去，f的累加相当于是有向无环图，所有的和都会累加到终止节点上去，可以用拓扑排序的方法来求最终节点。</p><h3 id="题目代码：-20"><a href="#题目代码：-20" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">26</span>], f[N], q[N], ne[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> id[<span class="number">210</span>];   <span class="comment">//单词编号 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p][t]) tr[p][t] = ++idx;    <span class="comment">//创建新的节点</span></span><br><span class="line">        p = tr[p][t];</span><br><span class="line">        f[p] ++;    <span class="comment">//每一个结束位置都代表一个字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    id[x] = p;  <span class="comment">//记录每个单词结尾所在地方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])q[++tt] = tr[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>;i ++)&#123;</span><br><span class="line">            <span class="type">int</span> &amp;p = tr[t][i];</span><br><span class="line">            <span class="keyword">if</span>(!p) p = tr[ne[t]][i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ne[p] = tr[ne[t]][i];</span><br><span class="line">                q[++tt] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面是从根节点一层一层求得，所以拓扑排序是倒序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) f[ne[q[i]]] += f[q[i]];    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[id[i]]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/archives/10f14ed7.html"/>
      <url>/archives/10f14ed7.html</url>
      
        <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>Kruskal算法：（稀疏图）</p><p>按照边权排序，用并查集维护</p><p>未连接的：连上</p><p>已经连接的：忽略</p><p>时间复杂度是O(mlogn)</p><p>Prim算法：（稠密图 O(n^2)）</p><p>邻阶矩阵存储， d[i]表示i这个未选节点到已选集合的距离</p><p>每次找到最小距离（未选点到已选集合）</p><h2 id="走廊泼水节"><a href="#走廊泼水节" class="headerlink" title="走廊泼水节"></a>走廊泼水节</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.acwing.com/problem/content/348/">走廊泼水节</a></p><p>描述：给一个树，求一个完全图所加边的权值之和最小值，并且这个图的最小生成树任然是这个树。</p><h3 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h3><p>就是在求最小生成树的时候，用Kruskal算法, 当两个集合需要合并的时候，这两个集合连线是最小的，两个集合其他点连线的权值就是这个两个集合连线最小值+1</p><h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    </span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="type">int</span> fa[N], Size[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> edge&amp; a, <span class="type">const</span> edge&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">get</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z);</span><br><span class="line">        <span class="built_in">sort</span>(a<span class="number">+1</span>, a+n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i, Size[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">get</span>(a[i].x);</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">get</span>(a[i].y);</span><br><span class="line">            <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">                fa[y] = x;</span><br><span class="line">                ans += (a[i].z + <span class="number">1</span>) * (Size[x] * Size[y] - <span class="number">1</span>);  <span class="comment">//其他未连接的边权值之和</span></span><br><span class="line">                Size[x] += Size[y]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="野餐规划"><a href="#野餐规划" class="headerlink" title="野餐规划"></a>野餐规划</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.acwing.com/problem/content/349/">野餐规划</a></p><p>描述：1号节点有限制，求生成树的最小边权之和</p><h3 id="题解思路-1"><a href="#题解思路-1" class="headerlink" title="题解思路"></a>题解思路</h3><p>思路一：删除1号节点的一条边，再加一条边，使得代价最小（贪心思想），枚举所有可以删除的边，在枚举所有可添加的边，使得删除添加的代价最小。</p><p>思路二：加边，然后去边</p><h3 id="题目代码-1"><a href="#题目代码-1" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s, deg, ans;  <span class="comment">//节点个数， </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], d[N], conn[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="type">int</span> tree[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//用一个map做映射</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; h;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    h[<span class="string">&quot;Park&quot;</span>] = <span class="number">1</span>; n = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(a));         <span class="comment">//原图对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="type">char</span> sx[<span class="number">12</span>], sy[<span class="number">12</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s%d&quot;</span>, sx, sy, &amp;z);</span><br><span class="line">        <span class="keyword">if</span> (!h[sx]) h[sx] = ++n; <span class="comment">//节点个数+1</span></span><br><span class="line">        <span class="keyword">if</span> (!h[sy]) h[sy] = ++n;</span><br><span class="line">        x = h[sx], y = h[sy];</span><br><span class="line">        a[x][y] = <span class="built_in">min</span>(a[x][y], z);      <span class="comment">//原图邻接矩阵存储</span></span><br><span class="line">        a[y][x] = <span class="built_in">min</span>(a[y][x], z);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原图的最小生成树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!v[j] &amp;&amp; (x == <span class="number">0</span> || d[j] &lt; d[x])) x = j;</span><br><span class="line">        v[x] = <span class="literal">true</span>;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; y++)</span><br><span class="line">            <span class="keyword">if</span> (!v[y] &amp;&amp; d[y] &gt; a[x][y])</span><br><span class="line">                d[y] = a[x][y], conn[y] = x;        <span class="comment">//连接y的是x，即是(x -&gt; y)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(tree, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(tree));               <span class="comment">//最小生成树对应的邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans += d[i];</span><br><span class="line">        <span class="keyword">if</span> (conn[i] == <span class="number">1</span>) deg++;                    <span class="comment">//从1节点到其他节点个数+1</span></span><br><span class="line">        tree[conn[i]][i] = tree[i][conn[i]] = d[i]; <span class="comment">//最小生成树对应的邻接矩阵</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前连通块的所有节点都标记一下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; </span><br><span class="line">    v[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">1</span>; y &lt;= n; y++)</span><br><span class="line">        <span class="keyword">if</span> (tree[x][y] != <span class="number">0x3f3f3f3f</span> &amp;&amp; !v[y]) <span class="built_in">dfs</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_min</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;              <span class="comment">//考虑原图中加入哪条边把v=true和v=false的两个块连起来</span></span><br><span class="line">    <span class="type">int</span> min_edge = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">if</span> (v[i])               <span class="comment">//是true的点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++) </span><br><span class="line">                <span class="keyword">if</span> (!v[j])      <span class="comment">//是false的点</span></span><br><span class="line">                    <span class="keyword">if</span> (a[i][j] &lt; min_edge) min_edge = a[i][j], x = i, y = j;   <span class="comment">//找到最小方案</span></span><br><span class="line">    <span class="keyword">return</span> min_edge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> min_val = <span class="number">1</span> &lt;&lt; <span class="number">30</span>, mini, minx, miny;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;              <span class="comment">//枚举从1出发的树边(1, i)，看删去哪一条</span></span><br><span class="line">        <span class="keyword">if</span> (tree[<span class="number">1</span>][i] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>; <span class="comment">//如果不存在直接跳过</span></span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));                </span><br><span class="line">        v[<span class="number">1</span>] = <span class="literal">true</span>;                            <span class="comment">//考虑的是1之外的两个连通块，1不能用</span></span><br><span class="line">        <span class="built_in">dfs</span>(i);                                 <span class="comment">//标记当前连通块所有节点</span></span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">int</span> add_edge = <span class="built_in">find_min</span>(x, y);          <span class="comment">//加入(x,y)，找到被标记的连通块，与false连通块连接的最小边</span></span><br><span class="line">        <span class="keyword">if</span> (add_edge &lt; <span class="number">0x3f3f3f3f</span> &amp;&amp; add_edge - tree[<span class="number">1</span>][i] &lt; min_val) &#123;</span><br><span class="line">            min_val = add_edge - tree[<span class="number">1</span>][i];    <span class="comment">//求出最小代价</span></span><br><span class="line">            mini = i, minx = x, miny = y;       <span class="comment">//删的点，加的边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += min_val;                             <span class="comment">//代价加起来</span></span><br><span class="line">    tree[<span class="number">1</span>][mini] = tree[mini][<span class="number">1</span>] = <span class="number">0x3f3f3f3f</span>;             <span class="comment">//删除这条边</span></span><br><span class="line">    tree[minx][miny] = tree[miny][minx] = a[minx][miny];    <span class="comment">//添加一条边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">while</span> (deg &gt; s) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        deg--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Total miles driven: %d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="沙漠之王"><a href="#沙漠之王" class="headerlink" title="沙漠之王"></a>沙漠之王</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.acwing.com/problem/content/350/">沙漠之王</a></p><h3 id="题解思路-2"><a href="#题解思路-2" class="headerlink" title="题解思路"></a>题解思路</h3><p>思路：</p><p>二分答案+最小生成树</p><p>根据题意求得是min(总成本/总长度)<br>转化 minx = 总成本/总长度<br>总成本 - minx <em> (总长度) = 0<br>f(x) = 总成本 - minx </em> (总长度)<br>函数单调递减，求解使f(x)=0的最小的x<br>要做的是满足任意一个生成树的f(x)&gt;=0，得到最小的x<br>因为f(x)是个单调递减函数,随着x的增大而减少<br>对于任意一个生成树如果<br>f(x) &gt; 0，l需要增大<br>f(x) &lt; 0，l需要减小<br>所以最终可以用最小生成树 + 二分答案来求解</p><h3 id="题目代码-2"><a href="#题目代码-2" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">int</span> n, x[N], y[N], h[N];</span><br><span class="line"><span class="type">double</span> d[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_prim</span><span class="params">(<span class="type">double</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)d[i] = <span class="number">1e18</span>, v[i] = <span class="number">0</span>;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (!v[j] &amp;&amp; (t == <span class="number">-1</span> || d[j] &lt; d[t])) t = j;</span><br><span class="line">        v[t] = <span class="literal">true</span>;</span><br><span class="line">        res += d[t];    <span class="comment">//确定这个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!v[j] &amp;&amp; d[j] &gt; <span class="built_in">fabs</span>(h[j] - h[t]) - mid * <span class="built_in">calc</span>(t, j) + eps)</span><br><span class="line">                d[j] = <span class="built_in">fabs</span>(h[j] - h[t]) - mid * <span class="built_in">calc</span>(t, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res &gt;= <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x[i], &amp;y[i], &amp;h[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">10000001</span>, ans;</span><br><span class="line">        <span class="keyword">while</span>((r - l) &gt; eps)&#123;       <span class="comment">//二分答案</span></span><br><span class="line">            <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check_prim</span>(mid)) ans = mid, l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="黑暗城堡"><a href="#黑暗城堡" class="headerlink" title="黑暗城堡"></a>黑暗城堡</h2><h3 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.acwing.com/problem/content/351/">黑暗城堡</a></p><h3 id="题解思路-3"><a href="#题解思路-3" class="headerlink" title="题解思路"></a>题解思路</h3><p>最短路径树+最短路图</p><p>最短路径生成树，首先求出最短路（到达各个点的距离），然后根据prim的顺序求出每个点d[p] == d[x] + w(x , p)的边的数量，将这些数量相乘就是方案总数</p><h3 id="题目代码-3"><a href="#题目代码-3" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, g[N][N], d[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!v[j] &amp;&amp; (t == <span class="number">-1</span> || d[j] &lt; d[t])) t = j;</span><br><span class="line">        v[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            d[j] = <span class="built_in">min</span>(d[j], d[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="type">int</span> mod = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        g[x][y] = g[y][x] = <span class="built_in">min</span>(g[x][y], z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>(); <span class="comment">//求最短路</span></span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">    v[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!v[j] &amp;&amp; (x == <span class="number">0</span> || d[x] &gt; d[j])) x = j;       </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(v[j] &amp;&amp; d[x] == g[j][x] + d[j]) res ++;  <span class="comment">//相当于是与最短路路径相等的边的个数</span></span><br><span class="line">        v[x] = <span class="literal">true</span>;</span><br><span class="line">        ans = (ans * res) % mod;        <span class="comment">//相等的边的个数相乘就是总的方案数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="朱-刘算法（最小树形图）"><a href="#朱-刘算法（最小树形图）" class="headerlink" title="朱-刘算法（最小树形图）"></a>朱-刘算法（最小树形图）</h2><p>有向图，n - 1条有向边从root 出发，可以到达所有点，并且让边权之和最小</p><p>贪心每个点找最小入边，无环的话就是找到答案了；如果有环的话就是把环缩小为点，从环上出发的点    改为从新点出发，从点到环改为进入新点，改一下边权</p><p><img src="C:\Users\贾鹏城\AppData\Roaming\Typora\typora-user-images\image-20220322204552885.png" alt="image-20220322204552885"></p><p>环缩点：</p><ol><li>可以新建一个图，将环转化成一个点</li><li>可以每个环的各个点都用其中一个点作为代表</li></ol><p>最小有向树形图<br>1 无环<br>2 每个点入度为1</p><p>朱刘算法<br>1 贪心的从每个点的所有入边中找一条权值最小的边<br>2 从选出的边中判断是否存在环<br>  2.1 不存在环，结束，把所有边权值加上作为答案<br>  2.2 存在环，进入第3步<br>3 将所有环缩点，构造新图G’，缩点前把所有边权值加上<br>  3.1 环内的边 2-&gt;3 3-&gt;4 4-&gt;2<br>        删去<br>  3.2 终点在环内的边 1-&gt;4 1-&gt;2<br>       权值 w’ = w - 终点入边权值<br>       w[1-&gt;4]’ = w[1-&gt;4] - w[3-&gt;4] = 5 - 1 = 4<br>       w[1-&gt;2]’ = w[1-&gt;2] - w[4-&gt;2] = 4 - 2 = 2<br>  3.3 其他边 4-&gt;5<br>        不变<br>每次缩一次点,点数最少-1,所以总共最多迭代n次算法结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; PDD;<span class="comment">//坐标 距离要开根号--double</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">PDD q[N];</span><br><span class="line"><span class="type">bool</span> g[N][N];<span class="comment">//邻接矩阵 相邻</span></span><br><span class="line"><span class="type">double</span> d[N][N], bd[N][N];<span class="comment">// 距离 备份数组</span></span><br><span class="line"><span class="type">int</span> pre[N], bpre[N];<span class="comment">// 入边 备份数组</span></span><br><span class="line"><span class="type">int</span> dfn[N], low[N], ts, stk[N], top;<span class="comment">// tarjan dfn序 low数组 时间戳 栈 栈顶</span></span><br><span class="line"><span class="type">int</span> id[N], cnt;<span class="comment">//缩点后新图</span></span><br><span class="line"><span class="type">bool</span> st[N], ins[N];<span class="comment">//判断从1号点能不能搜到所有点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (g[u][i] &amp;&amp; !st[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_con</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get_dist</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = q[a].x - q[b].x;</span><br><span class="line">    <span class="type">double</span> dy = q[a].y - q[b].y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ts;</span><br><span class="line">    stk[++top]=u,ins[u]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = pre[u];</span><br><span class="line">    <span class="keyword">if</span>(!dfn[j])<span class="comment">//没搜过 用low[j]更新low[u]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">tarjan</span>(j);</span><br><span class="line">        low[u] = <span class="built_in">min</span>(low[j],low[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ins[j])<span class="comment">//在栈里 用dfn[j]更新low[u]</span></span><br><span class="line">    &#123;</span><br><span class="line">        low[u] = <span class="built_in">min</span>(low[u],dfn[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[u]==dfn[u])<span class="comment">//比u低的j都dfs完了之后回到u发现u是最高的,开始把比u低的j出栈</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y=stk[top--],ins[y]=<span class="literal">false</span>,id[y]=cnt;</span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化距离矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (g[i][j]) d[i][j] = <span class="built_in">get_dist</span>(i, j);</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 求所有入边的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] = i;<span class="comment">// 入边首先初始化为自己到自己的INF</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (d[pre[i]][i] &gt; d[j][i])</span><br><span class="line">                    pre[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tarjan</span></span><br><span class="line">        <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span> dfn);<span class="comment">//dfs序</span></span><br><span class="line">        ts = cnt = <span class="number">0</span>;<span class="comment">//时间戳</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i])<span class="comment">//如果没被搜过就缩点</span></span><br><span class="line">                <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果cnt==n ,没有环,把所有入边的权重求和即为答案</span></span><br><span class="line">        <span class="keyword">if</span> (cnt == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) res += d[pre[i]][i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则 先把环里的所有边权累加起来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (id[pre[i]] == id[i])<span class="comment">//判断规则: 边的起点和终点是否在一个scc内</span></span><br><span class="line">                res += d[pre[i]][i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化bd数组 作为G&#x27;的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j ++ )</span><br><span class="line">                bd[i][j] = INF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建新图G&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &lt; INF &amp;&amp; id[i] != id[j])<span class="comment">//有边 且 是环外的边</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> a = id[i], b = id[j];<span class="comment">//起点a 终点b</span></span><br><span class="line">                    <span class="comment">// 如果终点在环内 则该入边 w&#x27; = w - w[环内入边权] = d[i][j] - d[pre[j][j]]</span></span><br><span class="line">                    <span class="keyword">if</span> (id[pre[j]] == id[j]) bd[a][b] = <span class="built_in">min</span>(bd[a][b], d[i][j] - d[pre[j]][j]);</span><br><span class="line">                    <span class="keyword">else</span> bd[a][b] = <span class="built_in">min</span>(bd[a][b], d[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// n更新为新的点数 , d更新为bd</span></span><br><span class="line">        n = cnt;</span><br><span class="line">        <span class="built_in">memcpy</span>(d, bd, <span class="keyword">sizeof</span> d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;q[i].x, &amp;q[i].y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="keyword">while</span> (m -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span> (a != b &amp;&amp; b != <span class="number">1</span>) g[a][b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check_con</span>()) <span class="built_in">puts</span>(<span class="string">&quot;poor snoopy&quot;</span>);<span class="comment">//不连通 无解</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, <span class="built_in">work</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="树的直径与最近公共祖先"><a href="#树的直径与最近公共祖先" class="headerlink" title="树的直径与最近公共祖先"></a>树的直径与最近公共祖先</h1><p>定义：树中最远两个点之间的距离称为树的直径，连接这两点的路径称为<strong>树的最长链</strong>。</p><h2 id="可以用树形dp来求"><a href="#可以用树形dp来求" class="headerlink" title="可以用树形dp来求"></a>可以用树形dp来求</h2><script type="math/tex; mode=display">d[x] = max(1-n)\{d[y_i] + edge(x,\ y_i)\}\\直径 = max \{ 以x为子树，经过x这个点的最长路径 \}\\经过x这个点的最长的路径=\{(y_i != y_j):d[y_i] + d[y_j] + edge(x, y_i) + edge(x, y_j)\}</script><p>但是如果一个树的子节点比较多，那么就可能达到$n^2$的复杂度</p><p>可以在求最大深度d的时候去维护</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    v[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i != <span class="number">-1</span>; i = next[i])&#123;</span><br><span class="line">        <span class="type">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span>(v[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(y);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, d[x] + d[y] + edge[i]);</span><br><span class="line">        d[x] = <span class="built_in">max</span>(d[x], d[y] + edge[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两次bfs求树的直径-不能有负权边"><a href="#两次bfs求树的直径-不能有负权边" class="headerlink" title="两次bfs求树的直径(不能有负权边)"></a>两次bfs求树的直径(不能有负权边)</h2><ol><li>从任意一个点出发，到达最远点记为p点</li><li>从p点出发到达最远点，记为q点</li><li>pq两点的距离就是树的直径</li></ol><h2 id="巡逻"><a href="#巡逻" class="headerlink" title="巡逻"></a>巡逻</h2><h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.acwing.com/problem/content/352/">巡逻</a></p><h3 id="题解思路-4"><a href="#题解思路-4" class="headerlink" title="题解思路"></a>题解思路</h3><p>k == 1的时候就是求出树的最大直径，2 * (n - 1) - L1 + 1，就是最终答案</p><p>k == 2的时候需要将原来的最大直径公共边权值重新赋值为-1，继续求出直径，ans - L2 + 1, 当你第一次连接直径时, 原本要原路返回, 这条边会走两次, 你连接之后直走一次,第二次连接时, 这条边会由于你的连线非但没少走, 还会多走一边故, 贡献从 1 变为 -1.</p><h3 id="题目代码-4"><a href="#题目代码-4" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[<span class="number">2</span> * N], ne[<span class="number">2</span> * N], w[<span class="number">2</span> * N], h[N], idx;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> d[N], pre[N], L2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[idx] = y, w[idx] = <span class="number">1</span>, ne[idx] = h[x], h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s); </span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> y = e[i];</span><br><span class="line">            <span class="keyword">if</span> (d[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">                pre[y] = i; <span class="comment">// 记录前一个结点</span></span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = s;     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到直径一端</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(d[i] &gt; d[p]) p = i;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> q, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (q != p) &#123;</span><br><span class="line">        w[pre[q]] = <span class="number">-1</span>;</span><br><span class="line">        w[pre[q] ^ <span class="number">1</span>] = <span class="number">-1</span>; <span class="comment">//反向图也修改一下权值</span></span><br><span class="line">        q = e[pre[q] ^ <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> y = e[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp</span>(y, x);</span><br><span class="line">        L2 = <span class="built_in">max</span>(L2, d[y] + w[i] + d[x]);</span><br><span class="line">        d[x] = <span class="built_in">max</span>(d[x], d[y] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> q = <span class="built_in">bfs</span>(p);     <span class="comment">//求树的直径两端</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">2</span> * (n - <span class="number">1</span>) - d[q] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">update</span>(q, p);   <span class="comment">//更新一下p到q的权值</span></span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">        <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">0</span>);       <span class="comment">//树上dp求一下最大直径，（因为有权值为-1的边，不能用BFS或者DFS）</span></span><br><span class="line">        ans = ans - L2 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-系列算法题</title>
      <link href="/archives/e8bdeba4.html"/>
      <url>/archives/e8bdeba4.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-1601-最多可达成的换楼请求数目"><a href="#LeetCode-1601-最多可达成的换楼请求数目" class="headerlink" title="LeetCode 1601. 最多可达成的换楼请求数目"></a>LeetCode 1601. 最多可达成的换楼请求数目</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/">1601. 最多可达成的换楼请求数目</a></p><h2 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h2><p>状态压缩，根据数据范围可以得出，假设请求长度为m，就是有m个请求，那么就有 <code>1 &lt;&lt; m</code>种情况</p><p>直接遍历每种情况，求出最大符合条件的情况</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumRequests</span>(<span class="params">self, n: <span class="built_in">int</span>, requests: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(requests)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">GetCnt</span>(<span class="params">x</span>):</span><br><span class="line">            s = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> x:</span><br><span class="line">                <span class="keyword">if</span> x &amp; <span class="number">1</span>:</span><br><span class="line">                    s += <span class="number">1</span></span><br><span class="line">                x = x &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            cnt = [<span class="number">0</span>] * n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> (x &gt;&gt; i) &amp; <span class="number">1</span>:</span><br><span class="line">                    a = requests[i][<span class="number">0</span>]</span><br><span class="line">                    b = requests[i][<span class="number">1</span>]</span><br><span class="line">                    cnt[a] = cnt[a] - <span class="number">1</span></span><br><span class="line">                    cnt[b] = cnt[b] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> cnt:</span><br><span class="line">                <span class="keyword">if</span> i:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((<span class="number">1</span> &lt;&lt; m)):</span><br><span class="line">            x = GetCnt(i)</span><br><span class="line">            <span class="keyword">if</span> x &lt;= res:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> check(i): </span><br><span class="line">                res = x</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> [][] rs;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumRequests</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] requests)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        rs = requests;</span><br><span class="line">        m = rs.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> GetCnt(i);<span class="comment">//查看二进制有多少位1</span></span><br><span class="line">            <span class="keyword">if</span>(x &lt;= res)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(i))res = x;<span class="comment">//检查是否合法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GetCnt</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &gt; <span class="number">0</span>; i -= (i &amp; -i)) s++;<span class="comment">//i &amp; -i是代表从右往左数第一个为 1 的位的权值。</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((x &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;<span class="comment">//第i位是1</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rs[i][<span class="number">0</span>], b = rs[i][<span class="number">1</span>];</span><br><span class="line">                cnt[a] --;</span><br><span class="line">                cnt[b] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)<span class="keyword">if</span>(cnt[i] != <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; rs;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetCnt</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= (i &amp; -i))&#123;      <span class="comment">//i &amp; -i是代表从右往左数第一个为 1 的位的权值。</span></span><br><span class="line">            s ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; rs.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((x &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;    <span class="comment">//第i位是1</span></span><br><span class="line">                <span class="type">int</span> a = rs[i][<span class="number">0</span>], b = rs[i][<span class="number">1</span>];</span><br><span class="line">                cnt[a]--;</span><br><span class="line">                cnt[b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] != <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumRequests</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; requests)</span> </span>&#123;</span><br><span class="line">        rs = requests;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="type">int</span> m = rs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">GetCnt</span>(i);          <span class="comment">//查看二进制有多少位1</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(x &lt;= res)<span class="keyword">continue</span>;       <span class="comment">//如果位数小于之前的位数就直接跳过</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i))res = x;        <span class="comment">//检查是否合法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客寒假集训4J题（分解质因数+埃氏筛）</title>
      <link href="/archives/18d07328.html"/>
      <url>/archives/18d07328.html</url>
      
        <content type="html"><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p><a href="https://ac.nowcoder.com/acm/contest/23479/J">https://ac.nowcoder.com/acm/contest/23479/J</a></p><p>求[l,r]区间内所有合数的最小公倍数%（1e9+7）</p><ol><li><p>用埃氏筛筛掉所有质数，剩下为合数</p></li><li><p>求最小公倍数有3种方法</p><ul><li>直接求最小公倍数</li><li>用$A*B/gcd(A,B)$就是两数之积 / 最大公因数</li><li>分解质因数：$A = 48=2<em>2</em>2<em>2</em>3$   $B=210=2<em>3</em>5<em>7$，然后两者共有的质因数C:（2，3），两者不共有的A:（2，2，2）,B:（5，7）三者相乘 $2</em>3<em>2</em>2<em>2</em>5*7 = 1680$</li></ul></li></ol><p>3.每一个合数的质因子都用unordered_map来维护，看这个质因子是否多于之前质因子的个数，将所有维护好的质因子相乘就是最小公倍数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> debug(a) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(a,b) cout&lt;&lt;#a&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;#b&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;b&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug3(a,b,c) cout&lt;&lt;#a&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;#b&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;#c&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;c&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug4(a,b,c,d) cout&lt;&lt;#a&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;#b&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;#c&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;#d&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;d&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debugx(a, idx) cout &lt;&lt; #a &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; idx &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; a[idx] &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debugarr(a, x) cout&lt;&lt;#a&lt;&lt;<span class="string">&quot;: &quot;</span>; for(int i = 0; i &lt; x; i++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debugvec(a) cout&lt;&lt;#a&lt;&lt;<span class="string">&quot;: &quot;</span>; for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; cout &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc(x)  scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SC(x)  scanf_s(<span class="string">&quot;%lld&quot;</span>,&amp;x)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; piii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="comment">//ll qpow(ll b, ll n) &#123;</span></span><br><span class="line"><span class="comment">//ll ret = 1;</span></span><br><span class="line"><span class="comment">//b %= mod;</span></span><br><span class="line"><span class="comment">//for (; n; n &gt;&gt;= 1, b = (b * b) % mod)</span></span><br><span class="line"><span class="comment">//if (n &amp; 1) ret = (ret * b) % mod;</span></span><br><span class="line"><span class="comment">//return ret;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; mp;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp2;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (temp = a % b)</span><br><span class="line">&#123;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;</span><br><span class="line">mp<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">n /= i;</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">mp1[i] += s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if (n &gt; 1)cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; 1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//puts(&quot;&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">1</span>)mp1[n] += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> m : mp1) &#123;</span><br><span class="line"><span class="type">int</span> x = m.first, y = m.second;</span><br><span class="line"><span class="comment">//cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span> (mp2[x] &lt; y)<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; y - mp2[x]; i++)res = (res % mod * x) % mod;</span><br><span class="line">mp2[x] = <span class="built_in">max</span>(y, mp2[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i])mp[i] = <span class="literal">true</span>;<span class="comment">//把素数存起来</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j += i) &#123;<span class="comment">//不管是合数还是质数，都用来筛掉后面它的倍数</span></span><br><span class="line">st[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="built_in">get_prime</span>(r);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mp[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n = v.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//res = v[0];</span></span><br><span class="line"><span class="comment">//a * b / gcd(a, b) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//res = ((res * v[i]) % mod / gcd(res, v[i])) % mod;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">divide</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res % mod&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-自顶向下</title>
      <link href="/archives/6fd417dc.html"/>
      <url>/archives/6fd417dc.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><h2 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h2><p>因特网的描述：</p><ol><li>描述因特网具体构成：构成因特网的硬件和软件。</li><li>分布式应用提供服务的网络基础设施。</li></ol><h2 id="构成描述"><a href="#构成描述" class="headerlink" title="构成描述"></a>构成描述</h2><p>因特网是一个世界范围的计算机网络，即它是互联了遍及全世界的数以亿计的计算设备的网络。</p><ol><li><p>连入因特网中的格式各样的设备。（<strong>网络边缘</strong>）</p><ul><li><strong>主机</strong>（host）或<strong>端系统</strong>（end system）</li></ul></li><li><p><strong>通信链路</strong>（communication link）。（<strong>接入网</strong>）</p><ul><li>媒介：同轴电缆、铜线、光纤、无线电频谱</li><li>传输速率：带宽 bps</li></ul></li><li><p><strong>分组交换机</strong>（packet switch）两种类型。（<strong>网络核心</strong>）</p><ul><li><strong>路由器</strong>（router）和 <strong>链路层交换机</strong>（link-layer switch）</li></ul></li><li><p><strong>ISP</strong>: internet sercice provider ISP <strong>因特网服务提供商</strong>。端系统通过ISP接入因特网。</p></li><li><p><strong>协议</strong>（protocol）：协议控制因特网中信息的接收和发送。一个<strong>协议</strong>定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送/或接收的一条报文或其他事件所采用的动作。</p><ul><li><strong>TCP</strong>（Transmission Control protocol 传输控制协议）</li><li><strong>IP</strong> (Internet Protocol 网际协议)</li></ul></li><li><p><strong>因特网标准</strong>（internet standard）由因特网工程任务组（Internet Engineering Task Force, IETF）研发。IETF的标准文档称为请求评论（Request for Commment）。RFC定义了TCP、IP、HTTP（Web）、SMTP（电子邮件）等协议。目前有将近6000个RFC。IEEE 802 LAN/MAN标准化委员会制定了以太网和无线WIFI的标准。</p><ul><li>因特网工程任务组（<strong>IETF</strong>）： 制定网络标准的组织</li></ul><ul><li>请求评论（<strong>RFC</strong>）：IETF的标准文档</li></ul></li></ol><h2 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h2><ol><li><p>为应用程序提供服务的基础设施—即用户使用应用。</p></li><li><p>应用程序编程接口—即编写应用。</p></li></ol><p><strong>分布式应用程序</strong>：比如视频会议这些应用涉及多个相互交换数据的端系统。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/J1qlUrQx9LiTFY2.png" alt="因特网的一些部件"></p><h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p> 与因特网相接的计算机及其他设备位于因特网的边缘，称为<strong>端系统</strong>。</p><p><strong>端系统</strong>是计算机网络从具体构成描述因特网中设备的用语，而<strong>主机</strong>是从服务去描述这些设备。这两个术语是通用的，即主机=端系统。</p><p><strong>主机</strong>有时候分为两类：<strong>客户</strong>（client）和<strong>服务器</strong>（server）。</p><ul><li>客户（client）：桌面PC、移动PC和只能手机</li><li>服务器（server）：用于发布Web页面，流视频的主机，现在常常依托于<strong>大型数据中心</strong>。</li></ul><h3 id="接入网（access-network）"><a href="#接入网（access-network）" class="headerlink" title="接入网（access network）"></a><strong>接入网</strong>（access network）</h3><p>将端系统连接到<strong>边缘路由器</strong>（edge router）的物理链路。</p><h4 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h4><p>家庭接入：DSL、电缆、FTTH、拨号和卫星</p><ol><li><p><strong>数字用户线</strong>（digital subscriber line，<strong>DSL</strong>）</p><p>利用<strong>电话线路</strong>接入网络。其中 <strong>ADSL</strong>是非对称的数字用户线，基本都用ADSL，因为一般下行的数据量都远大于上行的数据量，所以要设计成非平衡的链路。</p><p>采用<strong>独占</strong>的<strong>频分多路复用</strong>来传输。因为利用的是原有的电话线路，所以需要将DSL传输的网络信号（上行、下行）和电话信号通过频分多路复用来区分开来。</p><p>技术：主要用于家庭或小型办公室接入。</p><p>特点：通过编码不同的频率来使家庭电话线同时承担电话和上网的两个功能。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222195930.png" alt=""></p></li><li><p><strong>电缆因特网接入</strong>（cable Internet access）</p><p>利用<strong>有线电视网</strong>接入网络。结构上，通过粗的同轴电缆接入社区，再用细的同轴电缆接入每家每户。</p><p>采用<strong>共享</strong>的<strong>频分多路复用</strong>来传输。</p></li><li><p>混合光纤同轴电缆（HFC）</p><p> <strong>同轴电缆</strong>和<strong>光纤节点</strong>相连再接入边缘路由器。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222195946.png" alt=""></p></li><li><p><strong>光纤到户</strong>(FTTH, fiber to the home)</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222195955.png" alt=""></p></li></ol><h4 id="企业接入"><a href="#企业接入" class="headerlink" title="企业接入"></a>企业接入</h4><ul><li><p><strong>以太网</strong>：使用双绞铜线与一台以太网交换机相连，速率可达到100Mbps、1Gbps、10Gbps。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222195951.png" alt=""></p></li><li><p><strong>WiFi</strong>：IEEE802.11技术无线LAN，范围在几十米内。</p></li><li><p><strong>345G：</strong>一种广域接入技术。</p></li></ul><h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a><strong>物理媒体</strong></h3><p>分为两类：</p><ol><li><p><strong>导引型媒体</strong>（guided media)：电波随着固体媒体前行，如光缆、双绞铜线和同轴电缆。</p></li><li><p><strong>非导引型媒体</strong>（unguided media）：电波在空气或外层空间中传播：例如在无线局域网或数字卫星频道里。</p></li></ol><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心：由端系统的分组交换机和链路构成的网状网络。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222200002.png" alt=""></p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>端系统之间彼此传输报文，分组交换中，将长报文划分为分组，分组再通过通信链路和分组交换机（分为路由器和链路层交换机）传送。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222203659.png" alt=""></p><ol><li><strong>分组</strong> （packet）:其实大家更常见喜闻乐见的说法是“包”。打游戏时候说的丢包应该指的就是分组。源将长报文划分成小的数据块，就称之为分组了。</li><li>在源和目的之间，每个分组通过通信链路和<strong>分组交换机</strong>（packet switch）。交换器有两类：<strong>路由器</strong>和<strong>链路层交换机</strong> 。</li><li>在传输速率为 <em>R bits / s</em> 的链路上，传输一个 <em>L bits</em> 的分组时间是 <em>L / R</em> 秒。</li><li><strong>存储转发传输</strong>（store-and-forward transmission）：交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</li><li>N条速率均为R，长度为L的链路构成的路径（所以再源和目的地之间有N-1台路由器），端到端的时延是：$d_{end\ to\ end} = N\frac LR$</li><li><strong>输出缓存</strong>（output buffer）(也成为输出队列 output queue): 当分组需要经过的那条链路繁忙时（传输其他分组中），那么该分组可以在输出缓存上等待。</li><li><strong>排队时延</strong>（queue delay）: 在输出缓存等待的时延；除此之外，还有之前提到的存储转发时延。</li><li><strong>分组丢失（丢包）</strong>(packet lost)：到达的分组可能发现缓存已经被其他等待的分组完全充满了，这种情况下就会出现丢包。</li><li>在因特网中，每个端系统具有一个称为IP地址的地址。源在分组的首部包含了目的地的IP地址。路由器会检查目的地址的一部分，并向相邻的路由器转发该分组。</li><li><strong>转发表</strong>（Forwarding Table）和<strong>路由选择协议</strong>（Routing Protocol）<ul><li><strong>路由</strong>：分组中包括IP地址。</li><li><strong>转发</strong>：路由器中将目的地址映射为输出链路。</li></ul></li></ol><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ol><li><p>电路交换（circuit switching）网络必须在发送发和接受方之间的交换机需要为该连接维护为连接状态。该连接用电话的术语被称为一条电路。</p></li><li><p>电路交换的复用技术：指的是如何复用链路服务于多个连接，构建电路的技术。主要有频分复用（Frequency-Division Multiplexing, FDM）和时分复用（Time-Division Multiplexing, TDM）。简单来说，在不同频率上连接多个电路的称为FDM，而基于一定时间间隔为所有连接打开通路的被称为时分复用。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222203705.png" alt=""></p></li></ol><h3 id="分组交换与电路交换比较"><a href="#分组交换与电路交换比较" class="headerlink" title="分组交换与电路交换比较"></a>分组交换与电路交换比较</h3><ol><li><p>分组交换的性能优于电路交换，适用于随机数据，可以满足更多用户。</p></li><li><p>电路交换需要预留带宽，相当于固定了链路用户的数量。而分组交换不需要预留带宽，用户使用网络是有一定概率的，在一个时刻较多人使用的概率其实相对较低，所以一条链路可以给更多的用户使用。</p></li><li><p>电路交换适用于特殊情况，比如要保障传输数据能力。</p></li></ol><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>网络结构是网中之网，具有层次结构。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222211214.png" alt=""></p><ul><li><strong>ISP</strong>：ISP分为许多层级，比如<strong>第一层ISP</strong>（tier-1 ISP）、<strong>区域ISP</strong>（regional ISP）、<strong>接入ISP</strong>（access ISP）。端系统通过接入ISP与因特网相连，全球的ISP通过各个层级相连，形成了互联网的互联。</li><li>因特网交换点（Internet Exchange Point，<strong>IXP</strong>）：由第三方公司创建，IXP是一个汇合点，多个ISP在此处对等。</li></ul><p>关键词：</p><ul><li><strong>区域ISP</strong>（regional ISP）:区域中的接入ISP与之互联（例如一个城市）。区域ISP再与<strong>第一层ISP</strong>互联。区域ISP和第一层ISP可能是多对多的客户-提供商关系。</li><li><strong>存在点</strong>（Popint of Presence, PoP）: Pop存在于等级结构的所有层次。提供商网络中的一台或多肽路由器（在相同位置）的群组，其中客户ISP能够与提供商ISP连接。</li><li><strong>多宿</strong>（multi-home）：任何ISP（除了第一层ISP）可以与两个或更多ISP连接。</li><li><strong>对等</strong>（peer）：将相同等级结构的邻近一对网络连接到一起，使他们之间网络不通过上游ISP。通常对等的互相连接是不会结算的。</li><li><strong>因特网交换点</strong>（Internet Exchange Point, IXP）：IXP是一个汇合点，多个ISP都能够在这里共同对等。</li><li><strong>内容提供商网络</strong>（content provider network）: 独立于公共互联网却跨越全球的网络。例如谷歌的服务器主机。</li></ul><h2 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h2><h3 id="常见时延分类"><a href="#常见时延分类" class="headerlink" title="常见时延分类"></a>常见时延分类</h3><ul><li><p><strong>处理时延</strong>（nodal processsing delay）: 检查分组首部和决定将该分组导向何处所需要的时间。</p></li><li><p><strong>排队时延</strong>（queueing delay）：在队列中，当分组在链路上等待运输时，它经受排队时延。</p></li><li><p><strong>传输时延</strong>（transmission delay）：在链路上传播的时延，分组大小L/传输速率R</p></li><li><p><strong>传播时延</strong>（propogation delay）: 距离d / 速度s，在广域网中一般也为毫秒级 </p><p>他们总和累加出来称为：结点总时延（total nodal delay）</p><p>$d<em>{proc},d</em>{queue},d<em>{trans},d</em>{prop}$分别表示处理时延、排队时延、传输时延和传播时延, </p><p>则节点的总时延由下式给定:</p><p>$d<em>{nodal} = d</em>{proc}+d<em>{queue}+d</em>{trans}+d_{prop}$</p></li></ul><h3 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h3><p><strong>丢包:</strong> 队列并不能容纳无限多的分组。若没有地方存储，则会<strong>丢弃</strong>（drop）这个分组，该分组会<strong>丢失</strong>（lost）。</p><p><strong>流量强度</strong>（traffic intensity）：<em>a</em> 表示分组到达队列的平均速率（分组/秒，pkt/s）；<em>R</em> 是传输速率（从队列中输出比特的速率）；假设分组长度都为L：则比特到达队列的平均速率是 <em>La</em> bps；流量强度为比例 <em>La/R。</em></p><p>若流量强度&gt;1, 则比特 到达队列的平均速度超过从该队列传输出去的速率。所以，流量工程中一条金科玉律是：设计系统时流量强度不能大于1。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222211221.png" alt=""></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><ul><li><p>瞬间吞吐量（instantaneous throughput）：在任何时间瞬间接收到文件的速率（参考物理学中速度的定义）。</p></li><li><p>平均吞吐量（average throughput）：一段时间，接受 F bits 花费了 T 秒，则平均吞吐量为 F/T bps。</p></li><li><p>瓶颈链路（bottleneck link）：一条路径上，限制吞吐量的链路（参考图论中关键路径的定义）。</p></li></ul><h2 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h2><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222211225.png" alt=""></p><h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><p> 因特网协议栈由5个层次组成：物理层、链路层、网络层、传输层和应用层。因特网协议栈是一个理想模型。</p><p> 下层为上层提供服务。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p><ol><li>应用层（Application Layer）：支持网络应用，应用协议仅仅是网络应用的一个组成部分，运行在不同主机上的进程则使用应用层协议进行通信。</li><li>传输层（Transport Layer）： 负责为信源和信宿提供应用程序进程间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。</li><li>网络层（Network Layer）：负责将<strong>数据报</strong>独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。</li><li>链路层（Link Layer）：负责将IP数据报封装成合适在物理网络上传输的<strong>帧</strong>格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。</li><li>物理层（Physical Layer）：负责将<strong>比特流</strong>在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。</li></ol><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>OSI模型由国际标准化组织（ISO）制定，实际并没有应用，只有理论。</p><p>OSI模型由7层组成：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p><h3 id="应用层常见协议"><a href="#应用层常见协议" class="headerlink" title="应用层常见协议"></a>应用层常见协议</h3><p>应用层常见协议：HTTP（web），SMTP（电子邮件），FTP（两个端系统间的文件传输），域名系统（DNS）。</p><h3 id="封装（encapsulation）"><a href="#封装（encapsulation）" class="headerlink" title="封装（encapsulation）"></a>封装（encapsulation）</h3><p>应用层报文（application-layer meesage）-&gt; 运输层报文段（transport-layer segment）-&gt; 网络层数据报（network-layer datagram）-&gt; 链路层帧（link-layer frame）。</p><h2 id="面对攻击的网络"><a href="#面对攻击的网络" class="headerlink" title="面对攻击的网络"></a>面对攻击的网络</h2><ol><li><p>病毒（virus）：是一种需要某种形式的用户交互来感染用户设备的恶意软件。</p></li><li><p>蠕虫（worm）：是一种无需任何明显用户交互就能进入设备的恶意软件。</p></li><li><p>拒绝服务攻击（Denial-of-Service (Dos) attack）：攻击使得网络不能被合法用户所使用。分为：弱点攻击、带宽洪泛、连接洪泛。</p></li><li><p>分布式DoS（Distributed Dos, DDoS）：攻击者控制多个源并让每个源向目标猛烈发送流量。</p></li><li><p>分组嗅探器（packet sniffer）、IP哄骗（IP spoofing）都是计算机网络安全存在的问题。</p></li><li><p>描述一个僵尸网络形成的过程</p><ul><li>僵尸网络来源于某些应用或者系统的弱点</li><li>在找到弱点之后，攻击者需要判断主机是否属于脆弱的状态</li><li>其次，充分利用弱点对僵尸网络进行传播。</li><li>攻击者可能可以使用一条命令控制所有的受感染结点。</li><li>攻击者可以依据控制权限进行攻击。</li></ul></li></ol><h1 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><ul><li><strong>应用层协议</strong>：每个应用层协议都是为了解决一类应用问题，而解决问题需要通过位<strong>于不同主机</strong>的多个应用进程之间的通信和协同来完成，应用层的具体内容就是定义这些通信规则。</li><li>研发网络应用程序的<strong>核心</strong>是写出能够运行在<strong>不同的端系统</strong>和通过网络彼此<strong>通信的程序</strong>。 </li></ul><h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><p>两种主流体系结构：</p><ul><li>客户-服务器体系结构</li><li>对等（P2P）体系结构</li></ul><h4 id="客户-服务器体系结构"><a href="#客户-服务器体系结构" class="headerlink" title="客户-服务器体系结构"></a>客户-服务器体系结构</h4><ul><li>区分处理请求的服务器和发送请求的客户机</li><li>服务器往往在数据中心，通过多台服务器进行扩展。</li><li>服务器具有固定的、周知的<strong>IP</strong>地址</li><li>客户能够通过向该服务器的IP地址发送分组来与其联系。</li><li>客户之间不直接通信</li></ul><h4 id="对等（P2P）体系结构"><a href="#对等（P2P）体系结构" class="headerlink" title="对等（P2P）体系结构"></a>对等（P2P）体系结构</h4><ul><li>每台端系统既是服务器也是客户。</li><li>任意间断连接的主机对——称为对等方，直接通信。</li><li>P2P协议最突出的特性之一是它的自扩展性。</li></ul><p>某些应用具有混合的体系结构，由客户机/服务器和P2P元素结合而成，往往服务器场用于跟踪用户的IP地址，但用户到用户的报文在用户主机之间直接发送。</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ul><li><p>同一个端系统上的进程通过操作系统上的进程间通信机制相互通信。</p></li><li><p>不同端系统上的进程通过跨越计算机网络交换报文(message)而相互通信。</p></li></ul><h4 id="客户和服务器进程"><a href="#客户和服务器进程" class="headerlink" title="客户和服务器进程"></a>客户和服务器进程</h4><p><strong>进程</strong>：一台主机上运行的程序。</p><p><strong>客户机进程</strong>：发起通信的进程。</p><p><strong>服务器进程</strong>：等待连接的进程。</p><p>(P2P结构下一个进程既可以使服务器也可以是客户机)。</p><h4 id="套接字（Sockets）"><a href="#套接字（Sockets）" class="headerlink" title="套接字（Sockets）"></a>套接字（Sockets）</h4><p>套接字：进程与计算机网络之间的接口（应用程序编程接口）</p><p>进程通过一个称为<strong>套接字</strong>（socket）的软件接口向网络<strong>发送报文和从网络接收报文</strong>。</p><p>应用程序开发者可以控制套接字在应用层端的所以东西，但是对套接字的运输层端几乎没有控制。</p><p>应用程序开发者对于应用层端的控制仅限于：</p><ol><li>选择运输协议。</li><li>设定部分运输层参数，如最大缓存、最大报文长度等。</li></ol><h4 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h4><p>如果两个主机之间的进程进行通信，发送端不仅要知道接<strong>收端的IP地址</strong>还需要知道进程相应的<strong>端口号</strong>。</p><ul><li><strong>IP地址</strong>：IPv4中32位IP，负责找到接收端主机。</li><li><strong>端口号</strong>（port number）：每台主机都可能运行着多个进程，每个进程对应一个端口号。比如，HTTP服务端口号80、邮件服务端口号25。</li></ul><h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><h4 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h4><p>如果一个协议能够确保由应用程序的一端发送的数据正确地、完全地交付给该应用程序的另一端，那么该协议提供了可靠数据传输服务(reliable data transfer)。</p><h4 id="吞吐量-1"><a href="#吞吐量-1" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>两个进程在一条网络路径上进行通信会话时，<strong>可用吞吐量就是发送进程能够向接收进程交付比特的速率</strong>。因为其它会话将共享沿着该网络路径上的带宽，并且这些其它会话将会到达和离开，所以可用<strong>吞吐量将随时间波动</strong>。因此有了另一种服务，即运输层协议能够以某种特定的速率提供确保的可用吞吐量。</p><h4 id="定时"><a href="#定时" class="headerlink" title="定时"></a>定时</h4><p>运输层协议也能提供定时保证，如同吞吐量保证一样，定时保证可以以多种形式实现。</p><p>例如，可以设置发送方注入进套接字的每个比特到达接收方的套接字不迟于100ms。这种服务对交互式实时应用程序非常适用。</p><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>在发送主机中，运输层协议能够加密由发送进程传输的所有数据；在接收主机中，<strong>运输层协议能够在数据交付给接收进程之前解密这些数据。</strong></p><h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul><li><p><strong>面向连接服务</strong>： 使用TCP协议时，在应用层数据报文开始流动之前，其客户机程序和服务器程序之间相互交换运输层控制信息(握手过程)。握手阶段后，两个进程的套接字之间建立一个TCP连接，连接双方可以在此连接上同时进行报文收发。报文收发结束之后，该连接将被拆除。</p></li><li><p><strong>可靠数据传输服务</strong>：进行通信的进程依靠TCP协议，无差错、按适当顺序交付发送的数据。</p></li><li><p><strong>拥塞控制机制</strong>：发送方和接收方之间的网络出现拥塞时，TCP协议的拥塞机制会抑制发送进程。TCP协议的拥塞控制试图限制每个TCP连接，使它们达到公平共享网络带宽的目的。</p></li></ul><h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><ul><li><p>UDP是一种不提供不必要服务的轻量级运输层协议。</p></li><li><p>它是无连接的，两个进程通信前没有握手过程。</p></li><li>UDP协议提供的是不可靠数据传输服务，也就是说，当进程通过UDP套接字发送报文时，UDP协议不保证该报文能够被接收进程收到。</li><li>接收进程收到报文的顺序也可能是乱序的。</li><li>UDP协议没有拥塞控制机制。</li></ul><h4 id="TCP和UDP的安全"><a href="#TCP和UDP的安全" class="headerlink" title="TCP和UDP的安全"></a>TCP和UDP的安全</h4><ul><li><p><strong>安全原因</strong>：TCP和UDP都没有提供任何加密机制，发送进程传送至套接字的数据与经过网络传送到目的进程的数据相同。如果某个进程以明文方式将一个口令传送至它的套接字，该明文口令将经过发送方和接收方之间的所有链路传送，这就可能在任何中间链路被嗅探和发现。</p></li><li><p><strong>解决方案</strong>：人们研制了TCP的加强版本，称为安全套接字层(Secure Socket Layer, SSL)。SSL不是独立于TCP和UDP的第三种协议，而只是对TCP的增强。这种增强是在应用层上实现的。如果一个应用程序要使用SSL的服务，它需要在其客户机和服务器中都包括SSL的代码。</p></li></ul><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文。其主要定义了如下内容：</p><ol><li>交换的报文类型，如请求报文和响应报文。</li><li>各种类型的语法，如报文中的各个字段及其详细描述。</li><li>字段的语义，即包含在字段中的信息含义。</li><li>进程何时、如何发送报文以及对报文响应的规则。</li></ol><p>网络应用和应用层协议的区别：应用层协议只是网络应用的一部分，只是定义了应用程序之间沟通的协议。</p><h4 id="选则的网络应用的要求"><a href="#选则的网络应用的要求" class="headerlink" title="选则的网络应用的要求"></a>选则的网络应用的要求</h4><div class="table-container"><table><thead><tr><th style="text-align:left">应用</th><th style="text-align:left">应用层协议</th><th style="text-align:left">运输层协议</th></tr></thead><tbody><tr><td style="text-align:left">电子邮件</td><td style="text-align:left">SMTP</td><td style="text-align:left">TCP</td></tr><tr><td style="text-align:left">远程终端访问</td><td style="text-align:left">Telnet</td><td style="text-align:left">TCP</td></tr><tr><td style="text-align:left">Web</td><td style="text-align:left">HTTP</td><td style="text-align:left">TCP</td></tr><tr><td style="text-align:left">文件传输</td><td style="text-align:left">FTP</td><td style="text-align:left">TCP</td></tr><tr><td style="text-align:left">流媒体</td><td style="text-align:left">HTTP、RTP</td><td style="text-align:left">TCP或UDP</td></tr><tr><td style="text-align:left">因特网电话</td><td style="text-align:left">SIP、RTP或专用（如Skype）</td><td style="text-align:left">通常用UDP</td></tr></tbody></table></div><h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><ul><li>web的应用层协议是产文本传输协议(HyperText Transfer Protocol, HTTP)。</li><li>HTTP协议由两部分程序实现：一个客户机程序和一个服务器程序，它们运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的格式以及客户机和服务器是如何进行报文交换的。</li><li>HTTP使用TCP作为它的支撑运输层协议。客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问TCP。</li><li>HTTP是一个无状态协议(stateless protocol)，一个HTTP服务器并不保存关于客户机的任何信息。</li></ul><h3 id="非持续链接和持续链接"><a href="#非持续链接和持续链接" class="headerlink" title="非持续链接和持续链接"></a>非持续链接和持续链接</h3><h4 id="非持续链接步骤"><a href="#非持续链接步骤" class="headerlink" title="非持续链接步骤"></a>非持续链接步骤</h4><ol><li><p>TCP连接开启</p></li><li><p>通过这个TCP连接最多传输一个对象</p></li><li><p>TCP连接关闭</p><p>如果要加载多个对象时，需要多次非持久性HTTP连接。</p></li></ol><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/ucvbvs.png" alt=""></p><p><strong>RTT</strong>：往返时间, 一个很小的数据包（处理文件的时间可忽略）从客户机传到服务器再传回来的时间。</p><p><strong>HTTP响应时间</strong>（一个对象）：</p><ul><li><p>1个RTT：建立TCP连接的时间</p></li><li><p>1个RTT：HTTP请求以及收到HTTP响应的前几个字符的时间</p></li><li><p>对象/文件传输的时间</p><p>对一个对象来说，非持久性HTTP响应时间为: $2*RTT + html文件传输时间$</p><blockquote><p>例题：如果一个网页包含1个HTML和10个对象，则非持久性HTTP响应需要多少时间？</p><p>$2RTT×(1+10) + 总文件传输时间$</p></blockquote></li></ul><p><strong>非持续链接优缺点：</strong></p><ul><li>每传输一个对象都需要耗费 2RTT</li><li>每建立一个TCP连接都会对操作系统（OS）产生负荷</li><li>并行抓取：浏览器常常开多个并行的TCP连接去抓取对象</li></ul><h4 id="持续链接步骤"><a href="#持续链接步骤" class="headerlink" title="持续链接步骤"></a>持续链接步骤</h4><ol><li>开启TCP连接</li><li>通过这一个TCP连接可以传多个对象</li><li>TCP连接关闭</li></ol><p><strong>持续链接优缺点</strong>（HTTP1.1）</p><ul><li>服务器在发送响应后保持连接开启状态</li><li>后续这个客户机\服务器的HTTP消息都通过该开启的连接发送</li><li>两种发送对象方式：HTTP1.1采用流水的方式发送：一次性把对象全发了；另一种是客户机接收到一个对象后接着发下一个对象的请求</li><li>至少需要1个RTT发完所有对象</li></ul><h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p>HTTP有两种报文：请求报文和响应报文</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>下面是一个典型的请求报文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somedir/page.html HTTP/1.1</span><br><span class="line">Host: www.someschool.edu</span><br><span class="line">Connection: close</span><br><span class="line">User-agent: Mozilla/4.0</span><br><span class="line">Accept-language: fr</span><br></pre></td></tr></table></figure><p>HTTP请求第一行叫做请求行，其后继的行叫做首部行。请求行有三个字段：方法字段、URL字段和HTTP协议版本字段。方法字段可以取值GET、POST、HEAD、PUT和DELETE。</p><p>首部行<code>Host:www.someschool.edu</code>定义了目标所在主机。</p><p><code>Connection:close</code>首部行，告诉服务器不希望麻烦的使用持久连接，要求服务器发送完请求的对象后就关闭连接。</p><p><code>User-agent:</code>首部行用来定义用户代理，即向服务器发送请求的浏览器类型。</p><p><code>Accept-language</code>表示用户想要得到该对象的语法版本。</p><p><code>Accept-language:</code>是可选内容协商首部之一。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/jdfhnx.png" alt=""></p><ul><li>GET：浏览器请求一个对象，在URL字段带有请求对象的标识，实体体（entity body）为空。</li><li>POST：用户可以向server请求一个web页面，内容依赖于用户在实体体表单字段中的输入值。</li><li>HEAD：server会用HTTP报文进行响应，但是不返回请求对象，常用来调试跟踪。</li><li>PUT：允许用户上传对象到指定的web server上指定的路径。</li><li>DELETE：允许用户或应用程序删除web server上的对象。</li></ul><h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><p>典型响应报文格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Date: THu,03 Jul 2003 12:00:15 GMT</span><br><span class="line">Server: Apache/1.3.0(Unix)</span><br><span class="line">Last-Modified: Sun,6 May 2007 09:23:24 GMT</span><br><span class="line">Connect-Length: 6821</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">(data data ...)</span><br></pre></td></tr></table></figure><p><strong>响应分三部分</strong>：一个初始<strong>状态行</strong>，<strong>首部行和实体主体</strong>。实体主体是报文的主体，它包含一个所请求对象本身。状态行有三个字段：<strong>协议版本、状态码和相应状态信息。</strong></p><ul><li><code>Connection:close</code>首部行告诉客户机发送完毕后关闭连接。</li><li><code>Date</code>首部行指示服务器产生并发送该响应报文的日期和时间。时间是指服务器从它的文件系统中检索到该对象，插入到响应报文的时间。</li><li><code>Server</code>报文指示服务器类型，类似与请求报文中<code>User-agent</code>首部行。</li><li><code>Last_Modified</code>首部行指示了对象穿件或最后修改的日期和时间。</li><li><code>Content_Length</code>表明被发送对象的字节数。</li><li><code>Content_Type</code>指示了实体主体原本的类型（HTML还是图片等）。</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/cxjna.png" alt=""></p><p>一些常见的状态码：</p><div class="table-container"><table><thead><tr><th style="text-align:left">200</th><th style="text-align:left">OK</th><th style="text-align:left">请求成功</th></tr></thead><tbody><tr><td style="text-align:left">301</td><td style="text-align:left">Moved Permanently</td><td style="text-align:left">请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户机软件自动用新的URL获取该对象。</td></tr><tr><td style="text-align:left">400</td><td style="text-align:left">Bad REquest</td><td style="text-align:left">一个通过错误代码，指示请求不能被服务器理解。</td></tr><tr><td style="text-align:left">404</td><td style="text-align:left">NOT Found</td><td style="text-align:left">请求的文档不在服务器上。</td></tr><tr><td style="text-align:left">505</td><td style="text-align:left">HTTP version not supported</td><td style="text-align:left">服务器不支持请求报文使用的HTTP协议版本。</td></tr></tbody></table></div><h3 id="用于与服务器的交互：cookie"><a href="#用于与服务器的交互：cookie" class="headerlink" title="用于与服务器的交互：cookie"></a>用于与服务器的交互：cookie</h3><p>HTTP是无状态的，然而一个Web站点通常希望能够识别用户，即可能是为了服务器限制用户访问，也可能是它想把内容与用户身份联系起来。为此，HTTP使用了cookie，它允许站点跟踪用户。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/sjkda.png" alt=""></p><p>如上图所示，cookie由四部分组成：</p><ol><li>在HTTP响应报文中有一个cookie首部行；</li><li>在HTTP请求报文中有一个cookie首部行；</li><li>在用户端系统保留一个cookie文件，由用户的浏览器管理；</li><li>在Web站点有一个后端数据库。</li></ol><p>cookie可以在无状态的HTTP上建立一个用户层会话。例如，基于Web的电子邮件系统，浏览器向服务器发送一个cookie信息，运行该服务器通过用户与应用程序之间的会话对用户进行验证。</p><h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p>Web缓存器（Web cache）也叫代理服务器（proxy server），它是能够初始Web服务器来满足HTTP请求的网络实体。Web缓冲器有自己的磁盘存储空间，并在该存储空间中保存最近请求的对象的拷贝。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/jsaui.png" alt=""></p><p>一旦配置了浏览器，每个浏览器对对象的请求首先被定向到Web缓存器。其请求所经历流程大致如下：</p><ol><li>浏览器建立一个到Web缓存器的TCP连接，并发送请求。</li><li>Web缓存器检测本地是否存储了该对象的拷贝。如果有，Web缓存器就用HTTP响应报文回复。</li><li>如果Web缓存器没有该对象，它就与该对象的初始服务器打开一个TCP连接，并发送请求。</li><li>当Web缓存器接收到该对象时，在本地存储一份拷贝，并用HTTP响应报文向客户端发送报文。</li></ol><p>Web缓存器的好处：</p><ol><li>大大减少客户机请求响应时间，尤其在客户机与初始服务器之间的瓶颈带宽远低于客户机与Web服务器瓶颈带宽时。</li><li>可以大大减少一个机构内部网与因特网接入链路上的通信量，降低费用。</li><li>整体上大大降低因特网上的Web流量，从而改善所有应用的性能。</li></ol><h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p>条件GET方法是一种机制，允许缓存器证实它的对象是最新的。如果（1）请求报文使用GET方法；（2）请求报文包含一个<code>if-modified-since</code>首部行，那么这个HTTP请求报文就是一个条件GET请求报文。</p><p>缓存器发送一个条件GET，执行最新检查，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /fruit/kiwi.gif HTTP/1.1</span><br><span class="line">Host: www.somesite.com</span><br><span class="line">If-modified-since: Wed,4 Jul 2007 09:23:24</span><br></pre></td></tr></table></figure><p>该条件GET报文告诉服务器，仅当自指定日期之后修改过该对象才发送该对象。如果未改动过该对象，初始服务器响应报文可能是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 304 Not Modified</span><br><span class="line">Date: Sat,14 Jul 2007 15:39:29</span><br><span class="line">Server: Apache/1.3.0(Unix)</span><br><span class="line">(实体主体为空)</span><br></pre></td></tr></table></figure><p>状态行中为304 Not Modified,它告诉缓存器可以使用该对象，能向请求的浏览器转发它（该代理缓存器）缓存的该对象副本。 </p><h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><p>因特网电子邮件主要由三部分组成：用户代理（user agent）、邮件服务器（mail server）和简单邮件传输协议（Smiple Mail Transfer Protocol，SMTP）。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/smtp1.png" alt=""></p><ul><li>用户代理允许用户阅读、回复、转发、保存和撰写报文（用户代理也叫邮件阅读器）。</li><li>邮件代理向其邮件服务器发送邮件，并且该邮件被放在邮件服务器发送报文列中。</li><li>当用户想要获取邮件时，其邮件代理从他的位于邮件服务器的邮箱中获取该报文。</li></ul><p>邮件发送过程为：</p><p>从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中。在传递到接收方的邮件服务器时，发送方邮件服务器还要处理接收方服务器故障的问题：当发送方发送失败时，发送方邮件服务器在一个报文列表中保持该报文并在以后尝试再次发送，一般半个小时尝试一次，如果几天依然不能成功，会删除该报文并通知发送方。在接收方查看邮件时，接收方服务器会首先鉴别其身份。</p><p>SMTP是因特网电子邮件中主要的应用层协议。它使用TCP可靠传输服务。</p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>SMTP用于从<strong>发送方的邮件服务器</strong>发送报文到<strong>接收方的邮件服务器</strong>。SMTP邮件的主体部分（不止其首部）只能采用简单的<strong>7位ASCII</strong>码表示。</p><p>当A给B发送一封简单的ASCII报文时，其流程如下：</p><ol><li>A调用他的邮件代理程序并提供B的邮件地址，撰写邮件，然后通过用户代理发送该邮件。</li><li>A的用户代理把报文发送给A的邮件服务器，在那里该报文被放在报文发送队列中。</li><li>运行在A邮件服务器上的SMTP客户机端发现报文队列中这个报文，就创建一个到运行在B的邮件服务器上的STMP服务器的TCP连接。</li><li>在经过一些初始SMTP握手后，SMTP客户机通过该TCP连接发送A的报文。</li><li>在B的邮件服务器上，SMTP的服务器端接收该报文，B的邮件服务器然后将该报文放入B的邮箱中。</li><li>在B方便的时候，调用用户代理阅读报文。</li></ol><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/smtp2.png" alt=""></p><p>SMTP一般不使用中间邮件服务器发送邮件。</p><p>SMTP客户机（运行在发送方邮件服务器上）在25号端口建立一个到SMTP服务器的TCP连接。一但建立连接，服务器和客户机就执行一些应用层的握手，在握手阶段，SMTP客户机指定发送方的邮件地址和接收方的邮件地址。之后发送报文。</p><p>下面是SMTP服务器（S,主机名是server）和SMTP客户机（C，主机名是client）之间交换报文脚本的例子，一旦创建了TCP连接，就开始下列过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">S: 220 server</span><br><span class="line">C: HELO client</span><br><span class="line">S: 250 Hello client pleased to meet you</span><br><span class="line">C: MALL FROM: &lt;alice@crepes.fr&gt;</span><br><span class="line">S: 250 alice@crepes.fr ... Sender ok</span><br><span class="line">C: RCPR TO: &lt;bob@hamburger.edu&gt;</span><br><span class="line">S: 250 bob@hamburger.edu ... Recipient ok</span><br><span class="line">C: DATA</span><br><span class="line">S: 345 Enter mail, end with &quot;.&quot; on a line by itself</span><br><span class="line">C: Do you like ketchup?</span><br><span class="line">C: How about pickles?</span><br><span class="line">C: .</span><br><span class="line">S: 250 Messgae accepted for delivery</span><br><span class="line">C: QUIT</span><br><span class="line">S: 221 server closing conncetion</span><br></pre></td></tr></table></figure><p>上例中，客户机程序从邮箱服务器client向邮箱服务器server发送了一个报文（Do you like ketchup？How about pickles？）。客户机发送了五条命令：HELO（hello的缩写）、MALL FROM、RCPT TO、DATA以及QUIT。这些命令是自解释的。客户机通过发送一个只包含句点的行，告诉服务器该报文结束了。（按照ASCII码，每个报文以<code>CRLF.CRLF</code>结束，其中<code>CR</code>和<code>LF</code>分别表示回车和换行）。应达250表示正常。SMTP使用持久连接：如果发送邮件服务器有几个报文发往同一个接收服务器，可以通过一个TCP连接发送所有这些报文。对每个报文，客户机都用一个新的MALL FROM开始，仅当所以邮件全部发送完全才发送QUIT。</p><h3 id="SMTP与HTTP的对比"><a href="#SMTP与HTTP的对比" class="headerlink" title="SMTP与HTTP的对比"></a>SMTP与HTTP的对比</h3><p>相同点：都是使用了持久连接。</p><p>不同点：</p><ol><li>HTTP是一个拉协议，即人们可以在方便的时候装载Web信息，即用户使用HTTP从该服务器拉取信息。TCP连接是由想获取文件的机器发起的。</li><li>SMTP是一个推协议，即发送邮件服务器把文件推到接收邮件服务器，TCP连接是由要发送的机器发起的。</li><li>SMTP要求每个报文使用7位ASCII格式。如果某报文包含了非7位ASCII字符或二进制数据，则该报文必须按照7位ASCII进行编码。</li></ol><h3 id="邮件报文格式和MIME"><a href="#邮件报文格式和MIME" class="headerlink" title="邮件报文格式和MIME"></a>邮件报文格式和MIME</h3><p>邮件报文要包含环境信息，这些环境信息包含在首部行中。每个首部行包含一个From首部行和一个To首部行，可以包含一个Subject首部行或其他可选的首部行。这些首部行不同于在之前所学的SMTP命令，之前的命令是SMTP握手协议的一部分，而首部行是邮件报文的一部分。但是邮件发给谁和从哪里来不是由首部行决定的，而是由SMTP命令决定的。下面展示了一个典型的报文首部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">From: a</span><br><span class="line">To: b</span><br><span class="line">Subject: Searching for the meaning oof file</span><br></pre></td></tr></table></figure><p>在报文首部之后，紧接着是空白行，然后是以ACSII格式表示的报文主体。</p><h4 id="非ASCII码数据的MIME扩展"><a href="#非ASCII码数据的MIME扩展" class="headerlink" title="非ASCII码数据的MIME扩展"></a>非ASCII码数据的MIME扩展</h4><p>为发送非ASCII文本的内容，发送方必须在报文中使用附加的首部行。多用途因特网邮件扩展（Multipurpose Internet Mail Extension，MIME）。支持多媒体的量关键字MIME首部为Content-Type:和Content-Transfer-Encoding：。前者允许接收用户代理采取适当的动作，后者提示接收用户代理该报文已经使用了ASCII编码，并指出了使用的编码类型。当用户代理接收到包含这两个首部行的报文时，会根据Content-Transfer-Encoding的值将报文编码为非ASCII格式，然后根据Content-Type首部行决定它应该采取何种动作来处理报文。</p><h4 id="接收的报文"><a href="#接收的报文" class="headerlink" title="接收的报文"></a>接收的报文</h4><p>接收器一旦接收到具有RFC 822和MIME的首部行，就在该报文的顶端添加一个Received:首部行。该首部行定义了发送该报文的SMTP服务器的名称，接收该报文的SMTP服务器名称和接收时间。例如：<code>Received: from server by client; 12 Oct 98</code>。</p><h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>之前我们只考虑了邮件服务器之间使用SMTP进行传输报文，现在考虑用户代理与邮箱服务器之间如何传递报文。在发件方来看，从用户代理到邮箱服务器是一个推过程，需要推协议，SMTP刚好可以按照，因此，在发送方这两者使用SMTP协议。在来看接收方，接收方是在有时间的时候去读邮件，因此是一个拉过程，需要拉协议来支持，因此不能使用SMTP。与之对应的，可以使用的协议有三种：第三版邮局协议（Post Office Protocol-Version 3，POP3）、因特网邮件访问协议（Internet Mail Access Protocol，IMAP）以及HTTP。</p><h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>当用户代理（客户机）打开一个到邮件服务器（服务器）端口110上的TCP连接后，POP3就开始工作了。POP3按照三个阶段进行工作：特许（authorization）、事物处理以及更新。</p><p>第一阶段（特许）：用户代理发送（以明文形式）用户名和口令以鉴别用户。</p><p>第二阶段（事务处理）：用户代理取回报文。同时还可以进行：对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。</p><p>第三阶段（更新）：出现在客户机发出了quit命令后，目的是结束该POP3会话，这时，邮件服务器删除那些被标记为删除的报文。</p><p>在POP3事物处理阶段，用户代理发送一些命令，服务器对每个命令做出回答。回答有两种：+OK（有时后面会有说明文字），服务器用它来指示前面的命令是正常的；-ERR，服务器用它来指示前面的命令出现错误。</p><p>例子：</p><p>特许阶段有两个主要的命令：user &lt; user name &gt;和pass &lt; password &gt; o为了举例说明这两个命令，我们建议你直接用Telnet登录到POP3服务器的110端口，然后发岀这两个命令。假设邮件服务器的名字为mailServer,那么你将看到类似的过程：</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/smtp3.png" alt=""></p><p>事物处理过程中。POP3用户代理发出的命令通常由用户配置为“下载并删除”或者“下载并保留”。主要有四个命令list、retr、delete和quit。命令的语法在RFC 1939中定义。大概使用如下图：</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/smtp4.png" alt=""></p><h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>IMAP服务器把每个报文与一个文件夹联系起来，当报文第一次到达服务器时，它被放到收件箱文件夹中。收件人可以把邮件移到一个新的、用户创建的文件夹中，或阅读邮件、删除邮件等。IMAP为用户提供了创建文件夹以及在文件夹中移动邮件的命令。IMAP还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的邮件。IMAP服务器维护了IMAP会话的用户状态信息。</p><p>IMAP运行用户代理获取报文组件的命令。</p><p>优点：</p><ul><li>提供远程文件夹</li><li>用户可以通过手机、办公室PC、家庭PC来访问邮件。</li><li>IMAP服务器维护了IMAP会话的用户状态信息。</li></ul><h2 id="DNS：因特网的目录服务"><a href="#DNS：因特网的目录服务" class="headerlink" title="DNS：因特网的目录服务"></a>DNS：因特网的目录服务</h2><p>主机使用IP地址进行标识。一个IP地址由4个字节组成，并有着严格的层次结构。如想127.7.106.83这样，每个字节都被句点分隔开，表示了0~255的二进制数。IP地址具有层次结构是因为我们从左向右扫描时，会得到越来越细的关于主机位于因特网何处的信息。</p><p>主机也可以使用主机名进行标识。不过主机名只有在DNS中注册才有用，别人才能通过DNS获得主机名，因此在DNS中，主机名一定是互异的。</p><h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>域名系统（Domain Name System，DNS）提供进行<strong>主机名到IP地址</strong>转换的目录服务。</p><p>DNS是：</p><ol><li>一个由分层的DNS服务器实现的分布式数据库。</li><li>一个运行主机查询分布式数据库的应用层协议。DNS协议运行在UDP之上。</li></ol><p>DNS通常由其他应用层协议（如HTTP、SMTP和FTP）所使用，用于将用户提供的主机名解析为IP地址。例如，当请求URL <code>www.someschool.edu/index.html</code>页面时，为了使用户的主机能够将一个HTTP请求发送到Web服务器<code>www.someschool.ed</code>，该用户主机必须获得<code>www.someschool.edu</code>的IP地址。其做法为：</p><ol><li>同一台用户主机上运行着DNS应用的客户机端。</li><li>该浏览器从上述URL中抽取出主机名<code>www.someschool.edu</code>，并将这个主机名传给DNS应用的客户机端。</li><li>该DNS客户机向DNS服务器发送一个包含主机名的请求。</li><li>该DNS客户机最终会收到一份回答报文，包含对于主机名的IP地址。</li><li>一旦浏览器接收到来自DNS的IP地址，它就可以向该IP地址定位的HTTP服务器发起一个TCP连接。</li></ol><p>除了进行主机名到IP地址的转换外，DNS还提供了一些重要服务：</p><ol><li>主机别名（host aliasing）：有着复杂主机名的主机可以用于一个或者多个别名。原始主机名叫做<strong>规范主机名</strong>（canonical hostname）。应用程序可以调用DNS来获得主机别名对于的规范主机名已经主机的IP地址。</li><li>邮件服务器别名（mail server aliasing）：电子邮件应用程序调用DNS，对提供的邮件服务器别名进行解析，以获得该主机的规范主机名以及IP地址。事实上，MX记录允许一个公司的邮件服务器和Web服务器使用相同的（别名化的）主机名。</li><li>负载分配（load distribution）：DNS也用于在冗余的服务器之间进行负载分配。繁忙的站点被冗余分别在多台服务器上，每台服务器均运行在不同的端系统上，有着不同的IP地址。对于这些冗余的服务器，一个IP地址集合对应于同一个规范主机名。DNS数据库存储着这些IP地址集合。当客户机为映射到这个IP地址集合的名字发出一个DNS请求时，该服务器用包含全部这些地址的报文进行回答，但每个回答中旋转这些地址的顺序。客户机通常总是向IP地址排在最前面的服务器发送请求，所以DNS就在所有冗余的服务器之间旋转分配负载。</li></ol><ul><li>IP地址和域名的转换</li><li>主机的别名</li><li>邮件服务的别名</li><li>负荷分配：有些Web可能有多个服务器，即会有多个IP地址对应一个域名，可调整IP地址的顺序以分配负荷。</li></ul><blockquote><p>DNS作为一个<strong>网络核心功能</strong>，为什么要放在应用层？<br>  与网络结构设计理念有关，网络中主机很多映射很复杂，希望将复杂度留在端系统中，而不是在网络核心。</p></blockquote><h3 id="DNS工作机理"><a href="#DNS工作机理" class="headerlink" title="DNS工作机理"></a>DNS工作机理</h3><p>应用程序调用DNS的客户机端，并指明要转换的主机名，用户主机上的DNS接收到后，向网络中发送一个DNS查询报文。所有DNS请求和回答报文使用UDP数据报经端口53发送。经过若干毫秒时延后，用户主机上的DNS接收到一个DNS回答报文，这个结果被递送到调用DNS查询的应用程序中。</p><blockquote><p>DNS的一种简单设计方式是在因特网上只使用一个DNS服务器，该服务器包含所有映射。但是这样会有很多问题：</p><ol><li>单点故障：如果该服务器崩溃，整个因特网随之瘫痪。</li><li>通信容量：单个DNS服务器不得不处理所有DNS查询。</li><li>远距离的集中式分布：单个服务器不可能接近所有查询的客户机，因此会造成严重的时延。</li><li>维护：单个服务器将不得不为所以的因特网主机保留记录。使得整个中央数据库非常庞大，而且不得不解决为每个新添加的主机而频繁更新。</li></ol></blockquote><p>为此，DNS采用了分布式设计方案，DNS是因特网上实现分布式数据库的典范。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/2281.png" alt=""></p><h4 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h4><p>一个客户机得到<code>www.amazon.com</code>的IP地址的步骤：</p><ol><li>客户机先查询根域名服务器，得到顶级域名服务器<code>.com DNS server</code>的地址；</li><li>客户机查询顶级域名服务器<code>.com DNS server</code>，得到权威域名服务器<code>amazon.com DNS server</code>的地址；</li><li>客户机查询权威域名服务器<code>amazon.com DNS server</code>，得到<code>www.amazon.com</code>的IP地址</li></ol><p><strong>根服务器</strong>：因特网上存在13个根服务器（标号A到M）。尽管我们将这13个每个视为单独的服务器，但每台“服务器”实际上是冗余服务器集群，以提供安全性和可靠性。</p><p><strong>顶级域服务器</strong>：这些服务器负责顶级域名如（com、org、net、edu和gov）和所有国家的顶级域名。</p><p><strong>权威域名服务器:</strong></p><ul><li>组织自己的DNS服务器，用来提供组织内部的域名到IP地址的映射</li><li>由组织自己或者服务提供商来维护</li></ul><p><strong>本地域名服务器:</strong></p><ul><li>严格来说不属于层级结构</li><li>每个ISP都会有一个本地域名服务器，也叫做<strong>默认域名服务器</strong>（default name server）</li><li>当主机要进行DNS查询时，查询会被直接送到本地的DNS服务器。</li><li>作用：<ul><li>缓存：可以缓存最近收到的域名到IP地址的映射（缓存有时效，会过期）</li><li>代理：可以作为代理，代替主机在层级结构中进行查询</li></ul></li></ul><h4 id="DNS查询方法"><a href="#DNS查询方法" class="headerlink" title="DNS查询方法"></a>DNS查询方法</h4><p><strong>1. 迭代查询：</strong></p><p>  被联系到的服务器会将后一个服务器的名字反馈回来，即“我不认识这个域名，但是你可以去问另一台服务器。</p><p>  下面的迭代查询过程，利用本地域名服务器作为代理迭代查询域名对于的IP地址。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/2282.png" alt=""></p><p><strong>2. 递归查询：</strong></p><p>​        把域名解析的负担交给了联系到的域名服务器，这种方法对于高级的负担增加，所以一般采用迭代查询而不采用递归查询。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/2283.png" alt=""></p><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><ul><li>一旦域名服务器学习到了一个映射，它就会<strong>缓存</strong>这个映射。缓存往往在本地域名服务器里，这样可以减轻根域名服务器的压力。</li><li><strong>缓存有效时间TTL</strong>，过了有效时间该缓存就会被删除。</li><li><strong>更新/通知机制</strong>：由IETF制定的 RFC2136 标准。<br>  如果中途域名主机改变IP地址，整个网络可能都不知道真正的IP地址，直到TTL到时，所以需要更新/通知机制。</li></ul><h3 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h3><p>实现DNS分布式数据库的所有DNS服务器共同存储着<strong>资源记录</strong>（Resource Record，RR），RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记录。</p><p>资源记录是一个包含了下列字段的4元组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Name, Value, Type, TTL)</span><br></pre></td></tr></table></figure><p>TTL是该记录生存时间，它决定了资源记录应当从缓存中删除的时间。Name和Value的值取决于Type：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Type</th><th style="text-align:left">Name含义</th><th style="text-align:left">Value含义</th></tr></thead><tbody><tr><td style="text-align:left">A</td><td style="text-align:left">主机名</td><td style="text-align:left">IP地址。</td></tr><tr><td style="text-align:left">NS</td><td style="text-align:left">域（如<code>foo.com</code>）</td><td style="text-align:left">知道如何获得该域中主机IP地址的权威DNS服务器主机名。</td></tr><tr><td style="text-align:left">CNAME</td><td style="text-align:left">别名</td><td style="text-align:left">规范主机名</td></tr><tr><td style="text-align:left">MX</td><td style="text-align:left">别名</td><td style="text-align:left">邮件服务器的规范主机名</td></tr></tbody></table></div><p>为了获得邮件服务器的规范主机名，应该请求一条MX记录，为了获得其他服务器主机名应该请求一条CNAME记录。</p><p>如果一台DNS服务器是指定某特定主机的权威DNS服务器，那么该DNS服务会有一条包含该主机名的A记录。如果DNS服务器不是某个主机名的权威DNS服务器，那么该服务器包含一条NS记录（我觉得NS记录应该不是在服务器中存储的，应该是更具请求生成的），该记录对应于包含主机名的域；还有一条A记录，该记录提供了在NS记录中的Value字段中DNS服务器的IP地址。</p><p>type可以是以下这些类型：</p><div class="table-container"><table><thead><tr><th style="text-align:left">type</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:left">A</td><td style="text-align:left">地址记录</td></tr><tr><td style="text-align:left">AAAA</td><td style="text-align:left">地址记录</td></tr><tr><td style="text-align:left">AFSDB</td><td style="text-align:left">Andrew文件系统数据库服务器记录</td></tr><tr><td style="text-align:left">ATMA</td><td style="text-align:left">ATM地址记录</td></tr><tr><td style="text-align:left">CNAME</td><td style="text-align:left">别名记录</td></tr><tr><td style="text-align:left">HINFO</td><td style="text-align:left">硬件配置记录，包括CPU、操作系统信息</td></tr><tr><td style="text-align:left">ISDN</td><td style="text-align:left">域名对应的ISDN号码</td></tr><tr><td style="text-align:left">MB</td><td style="text-align:left">存放指定邮箱的服务器</td></tr><tr><td style="text-align:left">MG</td><td style="text-align:left">邮件组记录</td></tr><tr><td style="text-align:left">MINFO</td><td style="text-align:left">邮件组和邮箱的信息记录</td></tr><tr><td style="text-align:left">MR</td><td style="text-align:left">改名的邮箱记录</td></tr><tr><td style="text-align:left">MX</td><td style="text-align:left">邮件服务器记录</td></tr><tr><td style="text-align:left">NS</td><td style="text-align:left">名字服务器记录</td></tr><tr><td style="text-align:left">PTR</td><td style="text-align:left">反向记录</td></tr><tr><td style="text-align:left">RP</td><td style="text-align:left">负责人记录</td></tr><tr><td style="text-align:left">RT</td><td style="text-align:left">路由穿透记录</td></tr><tr><td style="text-align:left">SRV</td><td style="text-align:left">TCP服务器信息记录</td></tr><tr><td style="text-align:left">TXT</td><td style="text-align:left">域名对应的文本信息</td></tr><tr><td style="text-align:left">X25</td><td style="text-align:left">域名对应的X.25地址记录</td></tr></tbody></table></div><h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p>DNS只有两种报文，并且查询和回复有着相同的格式，如下图：</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/2284.png" alt=""></p><p>DNS报文中各字段语义如下</p><ol><li>前12个字节是首部区域，其中有几个字段。第一个字段是16比特的数，用于标识该查询。这个标识符会被复制到对查询的回答的报文中，以便让客户机用它来匹配发送的请求和接收到的回答。标识字段中有多个标志。1比特的“查询/回答”标识位指出是查询报文（0）还是回答报文（1）。当某DNS服务器正好是被请求主机的权威DNS服务器时，1比特的“权威的”标识位被置位在回答报文中。如果客户机（主机或者DNS服务器）希望DNS服务支持递归查询，将设置1比特的“希望递归”标志位。如果该DNS服务器支持递归查询，则回答报文中会对1比特的“递归可以”标志位置位。在该首部还有4个“数量”字段，指出在首部后四类数据区出现的数量。</li><li>问题区域包含着正在进行的查询信息。该区域包括：1.名字字段，用于指出正在被查询的主机名字。2.问题字段，用于指出正被查询的问题类型（A、MX等）。</li><li>来自DNS服务器的回答报文中，回答区域包含了对最初请求的名字的资源记录（RR）。一个回答报文的回答区域可能有多条RR，因为一个主机名可能对应多个IP地址。</li><li>权威区域包含了其他权威DNS服务器的记录。</li><li>附加区域包含了一些有帮助的信息。</li></ol><p>可以使用<code>nsloopup</code>程序来进行DNS查询。该程序的使用命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nslookup -qt=type domain [DNS-server];</span><br><span class="line">//例如</span><br><span class="line">nslookup -qt=mx baidu.com 8.8.8.8</span><br></pre></td></tr></table></figure><h4 id="在DNS数据库中插入记录"><a href="#在DNS数据库中插入记录" class="headerlink" title="在DNS数据库中插入记录"></a>在DNS数据库中插入记录</h4><p>当向某些注册登记机构注册域名<code>networkutopia.com</code>时，需要向该机构提供基本权威DNS服务器和辅助权威DNS服务器的名字和IP地址（不是域名本身的IP地址）。假定该名字和IP地址是<code>dns1.networkuptopai.com</code>和<code>dns2.networkuptopai.com</code>已经<code>212.212.212.1</code>和<code>212.212.212.2</code>。对这两个权威DNS服务器的每一个，该注册机构确保将一个类型NS和一个类型A的记录输入到TLD com服务器。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(networkuptopia.com,dns1.networkuptopai.com,NS)</span><br><span class="line">(dns1.networkuptopai.com, 212.212.212.1, A)</span><br></pre></td></tr></table></figure><p>此时查询时，首先TLD com回复本地DNS一个NS信息，而后本地DNS再次查询TLD com获取含义<code>networkuptopia.com</code>的权威服务器地址，这里是<code>212.212.212.1</code>。而后查询权威DNS服务器来获取IP地址。</p><h2 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h2><p>在P2P文件分发中，每个对等方都能够重新分发其所有的该文件的任何部分，从而协助服务器进行分发。</p><h3 id="P2P体系结构的扩展性"><a href="#P2P体系结构的扩展性" class="headerlink" title="P2P体系结构的扩展性"></a>P2P体系结构的扩展性</h3><p>下图展示了文件分发的示意图，其中所有字母的含义如图所示：</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/2285.png" alt=""></p><p>如果选用<strong>客户机-服务器</strong>结构</p><ul><li><p>服务器上传：需要上传这份文件 N次，上传速度为 us，则需要的上传时间为 NF/us</p></li><li><p>客户机下载：每个客户机都需要下载文件，dmin 是客户机最小下载速度，则客户机下载的最大时间为 F/dmin</p><p>  客户机-服务器结构的分发时间</p><script type="math/tex; mode=display">D_{cs}\ge max\{\frac {NF}{u_S},\frac F{d_{min}}\}</script><p>  此处的N导致耗费的时间随要下载的节点的数量线性增长，当要下载的节点数目大时，要耗费相当多的时间。</p><p>  不需要先上传完再下载，以分组为单位发送，可以忽略上传到下载的时间。</p></li></ul><p>如果选用<strong>P2P</strong>结构</p><ul><li><p>服务器上传：服务器至少要上传1次文件，上传时间为 F/us</p></li><li><p>客户机下载：每个客户机都要下载文件，客户机最大下载时间为F/dmin</p></li><li><p>客户机上传：每个下载了文件的客户机都可以上传文件，此时总上传速率可以达到</p><p>  P2P结构的分发时间</p><p>​    </p><script type="math/tex; mode=display">D_{P2P}\ge max\{\frac F{u_s},\frac F{d_{min}},\frac {NF}{u_s+\sum_{i=1}^Nu_i}\}</script></li></ul><p>客户机-服务器结构和P2P分发时间对比</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/2286.png" alt=""></p><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><ul><li>文件分为大小为 256Kb的块（chunk）</li><li>每个节点负责上传和下载的文件块</li><li>追踪器（tracker）：追踪参加洪流的节点</li><li>洪流（torrent）：有一组节点相互交换文件块</li><li>新的节点想下载文件，先询问追踪器参加的节点，再从相近的节点处下载文件块</li></ul><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/2287.png" alt=""></p><ul><li>节点加入洪流：<ul><li>本身没有文件块，但是随着时间的推移会从其他节点获取文件块</li><li>需要在追踪器进行登记，并且一般连接临近的节点</li></ul></li><li>下载时，节点会上传文件块到其他节点</li><li>节点可以更改交换文件块的节点</li><li>节点随时会上线和下线</li><li>一旦节点有了完整的文件，它可以离开或者留在洪流中</li></ul><h4 id="请求文件块"><a href="#请求文件块" class="headerlink" title="请求文件块"></a>请求文件块</h4><ul><li>在给定的时间，不同的节点拥有不同的文件块</li><li>一定周期，新的节点会问每个节点有哪些块</li><li>新节点会从其他节点处下载缺失的文件块<br><strong>最稀缺优先</strong>（rarest first）：如果有10个节点都有第1、2块，只有一个节点有第3块，则先下载第3块。</li></ul><h4 id="发送文件块"><a href="#发送文件块" class="headerlink" title="发送文件块"></a>发送文件块</h4><p>  发送文件块遵守<strong>一报还一报原则（tit-for-tat）</strong></p><ul><li><p>节点会给目前给它发送文件块速率最高的四个节点发送文件块，其他节点就不发送了，每隔 10s 会选出新的top4</p></li><li><p>每隔 30s 会随机选择其他节点发送文件块，这样这个随机节点可能就会成为新的top4</p><blockquote><p>tit-for-tat原则：上传速率快的节点相应地得到高下载速率的回报。</p></blockquote></li></ul><h2 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h2><h3 id="因特网视频"><a href="#因特网视频" class="headerlink" title="因特网视频"></a>因特网视频</h3><p>视频是一系列的图像，通常以一种恒定的速率来展示。视频能够被压缩。可用比特率来衡量视频质量。比特率越高，质量越好。</p><h3 id="HTTP和DASH"><a href="#HTTP和DASH" class="headerlink" title="HTTP和DASH"></a>HTTP和DASH</h3><p>在HTTP流中，视频只是存储在HTTP服务器中作为一个普通文件，每个文件有一个特定的URL。当用户看视频时，客户与服务器创建一个TCP连接并发送对该URL的HTTP GET请求。服务器以底层网络协议和流量条件允许的尽可能快的速率，在一个HTTP响应报文中发送该视频文件。客户端，字节被收集在应用缓存中，一旦该缓存中的字节数量超过预先设定的门限，客户端应用程序就开始播放。特别的，流式视屏应用程序周期性的从客户应用程序缓存中抓取帧，解压缩并在屏幕上展示。</p><p>在不同客户与不同时间，客户的可用带宽不同，这导致了一个新型基于HTTP的流的研发，被称为经HTTP的动态适应流（Dynamic Adaptive Streaming over HTTP，DASH）。在DASH中，视频编码为几个不同版本，其中每个版本具有不同的比特率，对应于不同质量水平。客户动态请求来自不同版本且长度为几秒的视频段数据块。当可用带宽较高时，客户自然地选择来自高速率版本的块，当可用带宽较低时，客户自然的选择来自较低速率版本的块。</p><p>使用DASH后，每个视频版本存储在HTTP服务器中，每个版本都有一个不同的URL。HTTP服务器也有一个告示文件（manifest file），为每个版本提供了一个URL及其比特率。客户请求告示文件，获得不同版本。然后客户通过在HTTP GET请求报文中对每块指定一个URL和一个字节范围，一次选择一块。在下载块的同时，客户端也测量接受带宽并运行一个速率决定算法来选择下次请求的块。</p><h3 id="内容分发网"><a href="#内容分发网" class="headerlink" title="内容分发网"></a>内容分发网</h3><p>建立单点服务器是最简单的方法，但存在二个弊端：</p><ol><li>若客户远离数据中心，服务器到客户从分组将跨越许多通信链路，会造成严重时延。</li><li>视频可能经过相同的通信链路发送多次，这造成了网络带宽的浪费，视频公司也要向因特网发送相同字节而向其ISP运营商支付费用。</li></ol><p>因此，主要视频流公司都利用内容分发网（Content Distribution Network，CDN）。CDN管理分布在多个地理位置上的服务器，在它的服务器中存储视频（和其他类型的Web内容，包括文档、图片和音频）的副本，并且所有试图将每个用户请求定向到一个提供最好用户体验的CDN位置。CDN可以是专业CDN，也可以是第三方CDN。</p><p>CDN通常采用两种不同的服务器安置原则：</p><ol><li>深入：通过在遍及全球的接入ISP中部署服务器集群来深入到ISP接入网中。</li><li>邀请做客：通过在少量关键位置建造大集群来邀请到ISP做客。不是将集群放在接入ISP中，这些CDN通常将他们的集群放置在因特网交换点（IXP）。</li></ol><p>一旦CDN的集群准备就绪，就可以跨集群复制。而一般采取的是拉策略：如果一个客户向未存储该视频的集群请求某视频时，该集群检索该视频（从某中心仓库或者另一个集群），向客户端流式传输视频的同时在本地存储一个副本。</p><h4 id="CDN操作"><a href="#CDN操作" class="headerlink" title="CDN操作"></a>CDN操作</h4><p>当用户主机中的一个浏览器指令检索一个特定视频（URL）时，CDN必须截获请求，以便能够：</p><ol><li>确定此时适用于该客户的CDN服务器集群；</li><li>将客户请求重定向到该集群的某台服务器。</li></ol><p>大多数CDN利用DNS来截获和重定向请求。考虑一个简单的例子来说明通常是如何涉及DNS的。假定一个内容提供商netcinema雇佣了第三方CDN公司kingcdn来向客户分发视频。在netcinema的web网页上，它的每个视频被指派了一个URL，该URL包含一个字符串“video”以及该视频本身的独特标识符，如转化器7可以指派为<a href="http://video.netcinema.com/6Y7B23V。接下来出现下图的步骤：">http://video.netcinema.com/6Y7B23V。接下来出现下图的步骤：</a></p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/3011.png" alt=""></p><ol><li>用户访问位于netcinema的Web网页。</li><li>当用户访问<a href="http://video.netcinema.com/6Y7B23V时，该用户主机发送一个对于video.netcinema.com的DNS请求。">http://video.netcinema.com/6Y7B23V时，该用户主机发送一个对于video.netcinema.com的DNS请求。</a></li><li>用户的本地DNS服务器（LDNS）将该DNS请求中继到一台用于netcinema的权威DNS服务器，该服务器观察到主机名video.netcinema.com中的字符串“vedio”。为了将DNS请求移交给kingcdn，netcinema权威DNS服务器并不返回一个IP地址，而是向LDNS返回一个kingcdn域的主机名，如a1105.kingcdn.com。</li><li>从这时起，DNS请求进入了kingcdn专用DNS基础设施。用户的LDNS发送第二个请求，此时是对a1105.kingcdn.com的DNS请求，kingcdn的DNS系统最终向LDNS返回kingcdn内容服务器的IP地址。正是在这里，在kingcdn的DNS系统中，指定了CDN服务器，客户将能够从这台服务器接收到它的内容。</li><li>LDNS向客户主机转发内容服务CDN节点的IP地址。</li><li>一旦客户收到kingcdn内容服务器的IP地址，它与具有该IP地址的服务器建立一条直接的TCP连接，并且发出对该视频的HTTP GET请求。如果使用DASH，服务器将首先向客户机发送具有URL列表的告示文件，每个URL对应视频的每个版本，并且客户机动态的请求不同版本的块。</li></ol><h4 id="集群选择策略"><a href="#集群选择策略" class="headerlink" title="集群选择策略"></a>集群选择策略</h4><p>任何CDN部署，其核心是集群选择策略，即动态地将客户定向到CDN中某个服务器集群或数据中心的机制。CDN一般采用专用的集群选择策略。</p><p>一种简单的策略是指派客户到地理位置的最为邻近的集群。使用商用地理位置数据库，每个LDNS IP地址都映射到一个地址位置。当从一个特殊的LDNS接收到一个DNS请求时，CDN选择地理位置上最为接近的集群。但这存在问题，即地理位置最近的集群不一定是就网络路径长度与跳数而言的最近。同时，该策略忽略了时延和可用带宽随因特网路径时间而变化，总是为特定的客户指派相同的集群。</p><p>CDN能够对其集群和客户之间的时延和丢包性能执行周期性的实时测量。</p><h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>目标：建立客户机/服务器的应用中的通信运用socket</p><p>socket：相当于应用进程和点对点传输协议之间的一扇门</p><p>socket类型：对应TCP和UDP有两种socket</p><h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><p>UDP：客户机与服务器之间没有连接</p><ul><li><p>发送数据前不需要握手</p></li><li><p>发送数据包附加IP地址+端口号</p></li><li><p>接收方从数据包中提取处IP地址+端口号</p><p>  UDP提供的是一种不可靠的数据流传输，传输过程中可能会丢包，接收的时候顺序也可能被打乱。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/3012.png" alt=""></p></li></ul><h4 id="UDP中的socket编程示例"><a href="#UDP中的socket编程示例" class="headerlink" title="UDP中的socket编程示例"></a>UDP中的socket编程示例</h4><p>UDP服务器代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UDPServer.ipynb</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM) <span class="comment">#创建服务器套接字</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, serverPort)) <span class="comment">#给套接字绑定端口号</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The server is ready to receive.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#服务器要一直在线等待，所以给一个死循环</span></span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>) <span class="comment">#从服务器套接字中读取信息（发送的消息和客户机IP地址+端口号）</span></span><br><span class="line">    modifiedMessage = message.decode().upper() <span class="comment">#对消息进行处理（此处是改大写）</span></span><br><span class="line">    </span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(), clientAddress) <span class="comment">#将处理后的消息发回给客户机</span></span><br></pre></td></tr></table></figure><p>UDP客户机代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UDPClient.ipynb</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverName = gethostname() <span class="comment">#由于没得服务器，服务器主机用本机来当</span></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM) <span class="comment">#创建客户机套接字</span></span><br><span class="line"></span><br><span class="line">message = <span class="built_in">input</span>(<span class="string">&#x27;Input lowercase sentence:&#x27;</span>) <span class="comment">#得到输入字符串</span></span><br><span class="line">clientSocket.sendto(message.encode(),(serverName, serverPort)) <span class="comment">#发送数据到相应主机名+端口号的服务器进程</span></span><br><span class="line"></span><br><span class="line">modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>) <span class="comment">#接收服务器发回的消息</span></span><br><span class="line"><span class="built_in">print</span>(modifiedMessage.decode()) <span class="comment">#显示接收的字符串</span></span><br><span class="line"></span><br><span class="line">clientSocket.close() <span class="comment">#关闭客户机socket</span></span><br></pre></td></tr></table></figure><p>  1. 先运行UDPServer.ipynb，启动服务器运行。<br>  1. 先运行UDPClient.ipynb，进行客户机访问。</p><h3 id="TCP中的socket编程"><a href="#TCP中的socket编程" class="headerlink" title="TCP中的socket编程"></a>TCP中的socket编程</h3><ul><li><p>服务器的先行准备</p><ul><li>服务器必须先运行</li><li>服务器需要创建socket来连接客户机</li></ul></li><li><p>客户机连接服务器</p><ul><li>客户机需要创建自己的socket，明确服务器进程的IP地址和端口号</li><li>客户机创建socket时，客户机和服务器之间需建立TCP连接</li></ul></li><li><p>服务器接收客户机消息</p><ul><li>服务器需创建一个新的socket，为了服务器进程能够和客户机进行通信<ul><li>要运行服务器与多个客户机进行通信</li><li>用源的端口号来区分不同的客户机</li></ul></li></ul><p>  TCP提供的是一种可靠的字节流（byte-stream）传输（pipe）。</p><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/3013.png" alt=""></p></li></ul><h4 id="TCP中的socket编程示例"><a href="#TCP中的socket编程示例" class="headerlink" title="TCP中的socket编程示例"></a>TCP中的socket编程示例</h4><p>TCP服务器代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TCPServer.ipynb</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM) <span class="comment">#创建服务器套接字（前台）</span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, serverPort)) <span class="comment">#给套接字绑定端口号</span></span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The server is ready to receive.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#服务器要一直在线等待，所以给一个死循环</span></span><br><span class="line">    connectionSocket, addr = serverSocket.accept() <span class="comment">#前台套接字接收到请求后，创建一个新的套接字（窗口）</span></span><br><span class="line">    </span><br><span class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>).decode() <span class="comment">#窗口套接字读取信息</span></span><br><span class="line">    capitalizedSentence = sentence.upper() <span class="comment">#对消息进行处理（此处是改大写）</span></span><br><span class="line">    </span><br><span class="line">    connectionSocket.send(capitalizedSentence.encode()) <span class="comment">#将处理后的信息发回给客户机</span></span><br><span class="line">    </span><br><span class="line">    connectionSocket.close() <span class="comment">#关闭窗口套接字，前台套接字保持开放</span></span><br></pre></td></tr></table></figure><p>TCP客户机代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TCPClient.ipynb</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverName = gethostname() <span class="comment">#由于没得服务器，服务器主机用本机来当</span></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM) <span class="comment">#创建客户机套接字(类型为字节流SOCK_STREAM)</span></span><br><span class="line">clientSocket.connect((serverName, serverPort)) <span class="comment">#TCP连接</span></span><br><span class="line"></span><br><span class="line">sentence = <span class="built_in">input</span>(<span class="string">&#x27;Input lowercase sentence:&#x27;</span>) <span class="comment">#得到输入字符串</span></span><br><span class="line">clientSocket.send(sentence.encode()) <span class="comment">#发送数据到服务器</span></span><br><span class="line"></span><br><span class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>) <span class="comment">#接收服务器发回的消息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;From server:&#x27;</span>, modifiedSentence.decode()) <span class="comment">#显示接收的字符串</span></span><br><span class="line"></span><br><span class="line">clientSocket.close() <span class="comment">#关闭客户机socket</span></span><br></pre></td></tr></table></figure><p>  1. 先运行TCPServer.ipynb，启动服务器运行。</p><p>  2. 先运行TCPClient.ipynb，进行客户机访问。</p><p>100 -》 113</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kuangbin 系列算法题</title>
      <link href="/archives/cdf368ab.html"/>
      <url>/archives/cdf368ab.html</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-4224-起火迷宫"><a href="#AcWing-4224-起火迷宫" class="headerlink" title="AcWing 4224. 起火迷宫"></a>AcWing 4224. 起火迷宫</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/4227/">4224. 起火迷宫 - AcWing题库</a></p><h2 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h2><p>BFS:</p><ol><li>每次火先向四周蔓延</li><li>J检查周围是否可以行走,火走过的地方就不可以继续行走了</li><li>相当于是将两个队列并行遍历检查</li></ol><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> st[N][N];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    queue&lt;pii&gt; J, F;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;F&#x27;</span>)F.<span class="built_in">push</span>(&#123;i, j&#125;),st[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;J&#x27;</span>)J.<span class="built_in">push</span>(&#123;i, j&#125;),st[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(J.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> l = F.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;F&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span>(l--)&#123;<span class="comment">//火向四周蔓延</span></span><br><span class="line">            <span class="keyword">auto</span> [x, y] = F.<span class="built_in">front</span>();</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">            F.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                <span class="type">int</span> nx = dx[i] + x, ny = dy[i] + y;</span><br><span class="line">                <span class="keyword">if</span>(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m &amp;&amp; g[nx][ny] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; st[nx][ny] == <span class="number">-1</span>)&#123;</span><br><span class="line">                    st[nx][ny] = st[x][y] + <span class="number">1</span>;</span><br><span class="line">                    F.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l = J.<span class="built_in">size</span>();</span><br><span class="line">       <span class="comment">// cout &lt;&lt; endl &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;J&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span>(l--)&#123;<span class="comment">//J检查周围是否可以走</span></span><br><span class="line">            <span class="keyword">auto</span> [x, y] = J.<span class="built_in">front</span>();</span><br><span class="line">            <span class="comment">//cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">            J.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                <span class="type">int</span> nx = dx[i] + x, ny = dy[i] + y;</span><br><span class="line">                <span class="keyword">if</span>(!(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m))&#123;cout &lt;&lt; st[x][y] + <span class="number">1</span> &lt;&lt; endl; <span class="keyword">return</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(g[nx][ny] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; st[nx][ny] == <span class="number">-1</span>)&#123;</span><br><span class="line">                    st[nx][ny] = st[x][y] + <span class="number">1</span>;</span><br><span class="line">                    J.<span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;IMPOSSIBLE&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-4225-石油储备"><a href="#AcWing-4225-石油储备" class="headerlink" title="AcWing 4225.  石油储备"></a>AcWing 4225.  石油储备</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/4228/">4225. 石油储备 - AcWing题库</a></p><h2 id="题解思路-1"><a href="#题解思路-1" class="headerlink" title="题解思路"></a>题解思路</h2><p>用一个数组存储所有@,并且遍历这数组，BFS往八个方向行走</p><h2 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n, m, z, cnt;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> st[N][N];</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">vector&lt;pii&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; z; i++)&#123;</span><br><span class="line">        queue&lt;pii&gt; q;</span><br><span class="line">        <span class="keyword">auto</span> [a, b] = v[i];</span><br><span class="line">        <span class="keyword">if</span>(st[a][b] != <span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> st[a][b] = c++;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span>[x, y] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">                <span class="type">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(nx &lt; n &amp;&amp; nx &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; g[nx][ny] == <span class="string">&#x27;@&#x27;</span> &amp;&amp; st[nx][ny] == <span class="number">-1</span>)&#123;</span><br><span class="line">                    st[nx][ny] = st[x][y];</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;nx, ny&#125;);   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m, n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                cin &gt;&gt; g[i][j];</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;@&#x27;</span>)v.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        z = v.<span class="built_in">size</span>();</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">       <span class="comment">// cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-4226-非常可乐"><a href="#AcWing-4226-非常可乐" class="headerlink" title="AcWing 4226. 非常可乐"></a>AcWing 4226. 非常可乐</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/4229/">4226. 非常可乐 - AcWing题库</a></p><h2 id="题解思路-2"><a href="#题解思路-2" class="headerlink" title="题解思路"></a>题解思路</h2><p>相当于相互倒水，找打最小次数使得两个杯子水一样。BFS为正解</p><h2 id="BFS-2"><a href="#BFS-2" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> s, n, m;</span><br><span class="line"><span class="type">int</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//a-&gt;b</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">f1</span><span class="params">(Node t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = n - t.b;</span><br><span class="line">    <span class="keyword">if</span>(t.a &lt;= y)&#123;t.b += t.a; t.a = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;t.a -= y; t.b = n;&#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a-&gt;c</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">f2</span><span class="params">(Node t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = m - t.c;</span><br><span class="line">    <span class="keyword">if</span>(t.a &lt;= y)&#123;t.c += t.a; t.a = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;t.a -= y; t.c = m;&#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//b-&gt;a</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">f3</span><span class="params">(Node t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = s - t.a;</span><br><span class="line">    <span class="keyword">if</span>(t.b &lt;= y)&#123;t.a += t.b; t.b = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;t.b -= y; t.a = s;&#125;;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//b-&gt;c</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">f4</span><span class="params">(Node t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = m - t.c;</span><br><span class="line">    <span class="keyword">if</span>(t.b &lt;= y)&#123;t.c += t.b; t.b = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;t.b -= y; t.c = m;&#125;;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c-&gt;a</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">f5</span><span class="params">(Node t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = s - t.a;</span><br><span class="line">    <span class="keyword">if</span>(t.c &lt;= y)&#123;t.a += t.c; t.c = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;t.c -= y; t.a = s;&#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c-&gt;b</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">f6</span><span class="params">(Node t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = n - t.b;</span><br><span class="line">    <span class="keyword">if</span>(t.c &lt;= y)&#123;t.b += t.c; t.c = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;t.c -= y; t.b = n;&#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">-1</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;s, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    st[s][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> g = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(g.a == s / <span class="number">2</span> &amp;&amp; g.b == s / <span class="number">2</span>)&#123;cout &lt;&lt; st[s/<span class="number">2</span>][s/<span class="number">2</span>] &lt;&lt; endl; <span class="keyword">return</span>;&#125;</span><br><span class="line">        Node t = <span class="built_in">f1</span>(g);</span><br><span class="line">        <span class="keyword">if</span>(st[t.a][t.b] == <span class="number">-1</span>)&#123;st[t.a][t.b] = st[g.a][g.b] + <span class="number">1</span>; q.<span class="built_in">push</span>(t);&#125;</span><br><span class="line">        t = <span class="built_in">f2</span>(g);</span><br><span class="line">        <span class="keyword">if</span>(st[t.a][t.b] == <span class="number">-1</span>)&#123;st[t.a][t.b] = st[g.a][g.b] + <span class="number">1</span>; q.<span class="built_in">push</span>(t);&#125;</span><br><span class="line">        t = <span class="built_in">f3</span>(g);</span><br><span class="line">        <span class="keyword">if</span>(st[t.a][t.b] == <span class="number">-1</span>)&#123;st[t.a][t.b] = st[g.a][g.b] + <span class="number">1</span>; q.<span class="built_in">push</span>(t);&#125;</span><br><span class="line">        t = <span class="built_in">f4</span>(g);</span><br><span class="line">        <span class="keyword">if</span>(st[t.a][t.b] == <span class="number">-1</span>)&#123;st[t.a][t.b] = st[g.a][g.b] + <span class="number">1</span>; q.<span class="built_in">push</span>(t);&#125;</span><br><span class="line">        t = <span class="built_in">f5</span>(g);</span><br><span class="line">        <span class="keyword">if</span>(st[t.a][t.b] == <span class="number">-1</span>)&#123;st[t.a][t.b] = st[g.a][g.b] + <span class="number">1</span>; q.<span class="built_in">push</span>(t);&#125;</span><br><span class="line">        t = <span class="built_in">f6</span>(g);</span><br><span class="line">        <span class="keyword">if</span>(st[t.a][t.b] == <span class="number">-1</span>)&#123;st[t.a][t.b] = st[g.a][g.b] + <span class="number">1</span>; q.<span class="built_in">push</span>(t);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s &gt;&gt; n &gt;&gt; m, s != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m)<span class="built_in">swap</span>(n,  m);</span><br><span class="line">        <span class="keyword">if</span>(s % <span class="number">2</span>)&#123;cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> tiii = tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> viii = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> pull = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j, viii t3) -&gt; viii&#123; <span class="comment">//将 i 倒入 j 中</span></span><br><span class="line">        <span class="type">int</span> w = <span class="built_in">min</span>(t3[i], s[j] - t3[j]);</span><br><span class="line">        t3[i] -= w, t3[j] += w;</span><br><span class="line">        <span class="keyword">return</span> t3;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s[<span class="number">0</span>] &gt;&gt; s[<span class="number">1</span>] &gt;&gt; s[<span class="number">2</span>] <span class="keyword">and</span> s[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">1</span>] &lt; s[<span class="number">2</span>]) <span class="built_in">swap</span>(s[<span class="number">1</span>], s[<span class="number">2</span>]);<span class="comment">//一定是s[1] &gt;= s[2], 这样当s[0] = s[1] &amp;&amp; s[2] == 0时就是合法解</span></span><br><span class="line">        bitset&lt;101&gt; v[<span class="number">101</span>][<span class="number">101</span>];<span class="comment">//记录是否来过，无需记录值（分步bfs第几步，就是几）</span></span><br><span class="line"></span><br><span class="line">        queue&lt;viii&gt; sk, wbw;</span><br><span class="line">        queue&lt;viii&gt; &amp;q = sk, &amp;q2 = wbw;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;s[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ans = <span class="number">1</span>; q.<span class="built_in">size</span>();ans++)&#123;<span class="comment">//分步bfs</span></span><br><span class="line">            <span class="keyword">for</span>(; q.<span class="built_in">size</span>(); q.<span class="built_in">pop</span>())&#123;</span><br><span class="line">                <span class="keyword">auto</span> pos = q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">                    <span class="keyword">if</span>(i / <span class="number">3</span> != i % <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="keyword">auto</span> np = <span class="built_in">pull</span>(i / <span class="number">3</span>, i % <span class="number">3</span>, pos);</span><br><span class="line">                        <span class="keyword">if</span>(!v[np[<span class="number">0</span>]][np[<span class="number">1</span>]][np[<span class="number">2</span>]]) q<span class="number">2.</span><span class="built_in">push</span>(np), v[np[<span class="number">0</span>]][np[<span class="number">1</span>]][np[<span class="number">2</span>]] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(q, q2);<span class="comment">//交换指针</span></span><br><span class="line">            <span class="keyword">if</span>(v[s[<span class="number">0</span>] / <span class="number">2</span>][s[<span class="number">0</span>] / <span class="number">2</span>][<span class="number">0</span>]) &#123;cout &lt;&lt; ans &lt;&lt; endl; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!v[s[<span class="number">0</span>] / <span class="number">2</span>][s[<span class="number">0</span>] / <span class="number">2</span>][<span class="number">0</span>]) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-4227-找路"><a href="#AcWing-4227-找路" class="headerlink" title="AcWing 4227. 找路"></a>AcWing 4227. 找路</h1><h2 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/4230/">4227. 找路 - AcWing题库</a></p><h2 id="题解思路-3"><a href="#题解思路-3" class="headerlink" title="题解思路"></a>题解思路</h2><p>BFS模板题</p><h2 id="BFS-3"><a href="#BFS-3" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> v1[N][N], v2[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v1, <span class="number">-1</span>, <span class="keyword">sizeof</span> v1);</span><br><span class="line">    <span class="built_in">memset</span>(v2, <span class="number">-1</span>, <span class="keyword">sizeof</span> v2);</span><br><span class="line">    queue&lt;pii&gt; q1, q2;</span><br><span class="line">    vector&lt;pii&gt; u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;Y&#x27;</span>)q<span class="number">1.</span><span class="built_in">push</span>(&#123;i, j&#125;), v1[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;M&#x27;</span>)q<span class="number">2.</span><span class="built_in">push</span>(&#123;i, j&#125;), v2[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;@&#x27;</span>)u.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q<span class="number">1.</span><span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = q<span class="number">1.f</span>ront();</span><br><span class="line">        q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> nx = dx[i] + x, ny = dy[i] + y;</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; n &amp;&amp; nx &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; g[nx][ny] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; v1[nx][ny] == <span class="number">-1</span>)&#123;</span><br><span class="line">                q<span class="number">1.</span><span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">                v1[nx][ny] = v1[x][y] + <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q<span class="number">2.</span><span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = q<span class="number">2.f</span>ront();</span><br><span class="line">        q<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> nx = dx[i] + x, ny = dy[i] + y;</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; n &amp;&amp; nx &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; g[nx][ny] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; v2[nx][ny] == <span class="number">-1</span>)&#123;</span><br><span class="line">                q<span class="number">2.</span><span class="built_in">push</span>(&#123;nx, ny&#125;);</span><br><span class="line">                v2[nx][ny] = v2[x][y] + <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  i = <span class="number">0</span>; i &lt; u.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = u[i];</span><br><span class="line">        <span class="keyword">if</span>(v1[x][y] != <span class="number">-1</span> &amp;&amp; v2[x][y] != <span class="number">-1</span>)&#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, v1[x][y] + v2[x][y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res * <span class="number">11</span>  &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-4241-货物运输"><a href="#AcWing-4241-货物运输" class="headerlink" title="AcWing 4241. 货物运输"></a>AcWing 4241. 货物运输</h1><h2 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/description/4244/">AcWing 4241. 货物运输</a></p><h2 id="题解思路-4"><a href="#题解思路-4" class="headerlink" title="题解思路"></a>题解思路</h2><ul><li>相当于dijkstra算法，但是求解的是结点的每条路径中最大最小权重中的最大值。</li><li>转移方程<code>dist[j]=max(dist[j],min(dist[ver],k))</code></li><li>这里的j表示下一个点，ver表示当前的点，k表示这条边的长度，只要当前的dist[j]是小于这个值的那么我们就更新dist[j]的值,这样就能让dist[j]最小路径最大值。</li></ul><h2 id="dijkstra优化"><a href="#dijkstra优化" class="headerlink" title="dijkstra优化"></a>dijkstra优化</h2><p>优先队列来松弛，每次都是如果有更新才会入队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line">vector&lt;vector&lt;pii&gt;&gt; g;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist); </span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    priority_queue&lt;pii&gt; pq; </span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pq.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, w = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;  </span><br><span class="line">        st[ver] = <span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[ver].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = g[ver][i].first;</span><br><span class="line">            <span class="type">int</span> k = g[ver][i].second; <span class="comment">//到下一个节点的承重</span></span><br><span class="line">            <span class="keyword">if</span> (dist[j] &lt; <span class="built_in">min</span>(dist[ver], k)) &#123; <span class="comment">//当前j这个点需要求所有路径中最小值中的最大值就可以</span></span><br><span class="line">                dist[j] = <span class="built_in">min</span>(dist[ver], k);</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[j], j&#125;);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T, a, b, c;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> _ = <span class="number">1</span>; _ &lt;= T; _++)&#123;</span><br><span class="line">        cin  &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        </span><br><span class="line">        g = vector&lt;vector&lt;pii&gt;&gt; (n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) g[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            g[a].<span class="built_in">push_back</span>(&#123;b, c&#125;);</span><br><span class="line">            g[b].<span class="built_in">push_back</span>(&#123;a, c&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Scenario #&quot;</span> &lt;&lt; _ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个更简单的写法是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> edge[<span class="number">1010</span>][<span class="number">1010</span>], d[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tt; cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> _ = <span class="number">1</span>; _ &lt;= tt; _++)&#123;</span><br><span class="line">        <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span> edge);</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a, b, c; m--;) </span><br><span class="line">            <span class="keyword">if</span>(cin &gt;&gt; a &gt;&gt; b &gt;&gt; c) edge[a][b] = edge[b][a] = c;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pii&gt; pq;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;<span class="number">2e9</span>, <span class="number">1</span>&#125;); d[<span class="number">0</span>] = <span class="number">2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> [cd, cx] = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(cd &lt; d[cx]) <span class="keyword">continue</span>;<span class="comment">//没有就TLE</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">min</span>(cd, edge[cx][i]) &gt; d[i])&#123;</span><br><span class="line">                    d[i] = <span class="built_in">min</span>(cd, edge[cx][i]);</span><br><span class="line">                    pq.<span class="built_in">push</span>(&#123;d[i], i&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Scenario #%d:\n%d\n\n&quot;</span>, _ , d[n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Acwing-4242-货币兑换"><a href="#Acwing-4242-货币兑换" class="headerlink" title="Acwing 4242. 货币兑换"></a>Acwing 4242. 货币兑换</h1><h2 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/description/4245/">4242. 货币兑换 - AcWing题库</a></p><h2 id="题解思路-5"><a href="#题解思路-5" class="headerlink" title="题解思路"></a>题解思路</h2><ul><li>直接用spfa算法</li><li>spfa算法适用于无负权回路的图</li><li>状态转移<code>dist[j] = (dist[t] - c[i]) * r[i]</code>：当前这个节点    t ——&gt; j 用t去更新j</li></ul><h2 id="spfa算法"><a href="#spfa算法" class="headerlink" title="spfa算法"></a>spfa算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> h[N], ne[M], e[N], idx, n, m, s;</span><br><span class="line"><span class="type">double</span> R[M], C[M], dist[N], v;</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//标记的是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">double</span> r, <span class="type">double</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, R[idx] = r, C[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dist[s] = v;</span><br><span class="line">    st[s] = <span class="literal">true</span>; <span class="comment">//在队列中</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];   <span class="comment">//下一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; (dist[t] - C[i]) * R[i])&#123;  <span class="comment">//查看是否大于之前节点的值</span></span><br><span class="line">                <span class="keyword">if</span>(j == s)<span class="keyword">return</span> <span class="literal">true</span>;              <span class="comment">//如果回到最初的节点就直接返回，说明钱一定增多</span></span><br><span class="line">                dist[j] = (dist[t] - C[i]) * R[i];  <span class="comment">//更新这个节点</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])q.<span class="built_in">push</span>(j), st[j] = <span class="number">1</span>;     <span class="comment">//如果队列中没有就直接入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; v;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="type">double</span> r1, c1, r2, c2;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; r1 &gt;&gt; c1 &gt;&gt; r2 &gt;&gt; c2;</span><br><span class="line">        <span class="built_in">add</span>(a, b, r1, c1);</span><br><span class="line">        <span class="built_in">add</span>(b, a, r2, c2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>())cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-4243-传递信息"><a href="#AcWing-4243-传递信息" class="headerlink" title="AcWing 4243. 传递信息"></a>AcWing 4243. 传递信息</h1><h2 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/4246/">4243. 传递信息 - AcWing题库</a></p><h2 id="题解思路-6"><a href="#题解思路-6" class="headerlink" title="题解思路"></a>题解思路</h2><p>求单元最短路问题，可用dijkstra算法，也可以用优化版dijkstra算法,朴素版时间复杂度是$O(n^2)$,堆优化版时间复杂度是$O(m*logn)$</p><h2 id="dijkstra算法（朴素版）"><a href="#dijkstra算法（朴素版）" class="headerlink" title="dijkstra算法（朴素版）"></a>dijkstra算法（朴素版）</h2><p>时间复杂度$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N][N], dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;        <span class="comment">//初始距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>;        <span class="comment">//标记</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))   <span class="comment">//找到下一个距离最小的节点</span></span><br><span class="line">t = j;                                      <span class="comment">//记录</span></span><br><span class="line">&#125;</span><br><span class="line">st[t] = <span class="literal">true</span>;        <span class="comment">//确定最小的距离，标记</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;                <span class="comment">//遍历每一个节点，用最小距离更新其它节点</span></span><br><span class="line">dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            string s;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>] != <span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                    t = t * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>); </span><br><span class="line">                &#125;</span><br><span class="line">                g[i + <span class="number">1</span>][j] = g[j][i + <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)res = <span class="built_in">max</span>(res, dist[i]); </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-4244-牛的比赛"><a href="#AcWing-4244-牛的比赛" class="headerlink" title="AcWing 4244. 牛的比赛"></a>AcWing 4244. 牛的比赛</h1><h2 id="题目链接-7"><a href="#题目链接-7" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/4247/">4244. 牛的比赛 - AcWing题库</a></p><h2 id="题解思路-7"><a href="#题解思路-7" class="headerlink" title="题解思路"></a>题解思路</h2><p>Floyd模板题</p><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N][N], d2[N][N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        d[x][y] = d2[y][x] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//d[x][y] = 1，代表x &gt; y</span></span><br><span class="line">        <span class="comment">//d[y][x] = 1，代表y &lt; x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//floyd求任意两点之间的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                d[i][j] |= (d[i][k] &amp;&amp; d[k][j]);<span class="comment">//d与d2互不干扰，分开dp</span></span><br><span class="line">                d2[i][j] |= (d2[i][k] &amp;&amp; d2[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(d[i][j] | d2[i][j]) t++;<span class="comment">//可以比较i，j之间的关系</span></span><br><span class="line">        <span class="keyword">if</span>(t == n - <span class="number">1</span>) ans++;<span class="comment">//可以比较其他n-1个点的关系，说明可以被定位</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-4246-最短路径和"><a href="#AcWing-4246-最短路径和" class="headerlink" title="AcWing 4246. 最短路径和"></a>AcWing 4246. 最短路径和</h1><h2 id="题目链接-8"><a href="#题目链接-8" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/4249/">4246. 最短路径和 - AcWing题库</a></p><h2 id="题解思路-8"><a href="#题解思路-8" class="headerlink" title="题解思路"></a>题解思路</h2><h2 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>, M = <span class="number">2000010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h1[N], h2[N], ne[M], e[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> d1[N], d2[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> *h)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> *h, <span class="type">int</span> *d)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pii,vector&lt;pii&gt; ,greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pq.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[y] == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        st[y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[y]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];  </span><br><span class="line">            <span class="keyword">if</span> (d[j] &gt; d[y] + w[i]) <span class="comment">//如果下一个元素原来距离比较大就更新距离</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[y] + w[i];</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;d[j], j&#125;);    <span class="comment">//插入到小根堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">memset</span>(h1, <span class="number">-1</span>, <span class="keyword">sizeof</span> h1);</span><br><span class="line">        <span class="built_in">memset</span>(d1, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d1);</span><br><span class="line">        <span class="built_in">memset</span>(h2, <span class="number">-1</span>, <span class="keyword">sizeof</span> h2);</span><br><span class="line">        <span class="built_in">memset</span>(d2, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a, b, c, h1);</span><br><span class="line">            <span class="built_in">add</span>(b, a, c, h2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>(h1, d1);</span><br><span class="line">        <span class="built_in">dijkstra</span>(h2, d2);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++ ) res += d1[i] + d2[i];</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-4247-糖果"><a href="#AcWing-4247-糖果" class="headerlink" title="AcWing 4247. 糖果"></a>AcWing 4247. 糖果</h1><h2 id="题目链接-9"><a href="#题目链接-9" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/description/4250/">4247. 糖果 - AcWing题库</a></p><h2 id="题解思路-9"><a href="#题解思路-9" class="headerlink" title="题解思路"></a>题解思路</h2><h2 id="dijkstra算法（堆优化版）"><a href="#dijkstra算法（堆优化版）" class="headerlink" title="dijkstra算法（堆优化版）"></a>dijkstra算法（堆优化版）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>, M = <span class="number">150010</span>;</span><br><span class="line"><span class="type">int</span> h[N], ne[M], e[M], w[M], idx, d[N], n, m;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt; ,greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pq.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[y])<span class="keyword">continue</span>;</span><br><span class="line">        st[y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[y]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; d[y] + w[i])&#123;<span class="comment">//到达j节点的距离大于（到达y节点的距离+y-&gt;j），更新j节点距离</span></span><br><span class="line">                d[j] = d[y] + w[i];</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;d[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    cout &lt;&lt; d[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-4248-地铁"><a href="#AcWing-4248-地铁" class="headerlink" title="AcWing 4248. 地铁"></a>AcWing 4248. 地铁</h1><h2 id="题目链接-10"><a href="#题目链接-10" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/description/4251/">4248. 地铁 - AcWing题库</a></p><h2 id="题解思路-10"><a href="#题解思路-10" class="headerlink" title="题解思路"></a>题解思路</h2><p>两种方法:</p><ol><li>是Floyd算法（此题数据比较小可以用）.</li><li>dijkstra算法</li></ol><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = <span class="number">40010</span>;</span><br><span class="line"><span class="type">double</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">vector&lt;pii&gt; p, p1;<span class="comment">//p是总数组，p1是暂存数组</span></span><br><span class="line">map&lt;pii, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> n, a, b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求两个地铁站步行的时间</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">d</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = a.first - b.first;</span><br><span class="line">    <span class="type">double</span> dy = a.second - b.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy) * <span class="number">0.006</span>; <span class="comment">// 相当于距离除速度，10km/h = 10000m/60min</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) </span><br><span class="line">           <span class="keyword">if</span>(i != j) g[i][j] = <span class="number">2e18</span>;</span><br><span class="line">           <span class="keyword">else</span> g[i][j] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ll x, y, x1, y1, k = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; x1 &gt;&gt; y1;</span><br><span class="line">    p.<span class="built_in">push_back</span>(&#123;x, y&#125;); p.<span class="built_in">push_back</span>(&#123;x1, y1&#125;);<span class="comment">//两个点加入到数组中去</span></span><br><span class="line">    mp[&#123;x, y&#125;] = k++; mp[&#123;x1, y1&#125;] = k++;<span class="comment">//用map保存下来，以后如果遇到之后就不用再加入到数组中去</span></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; x &gt;&gt; y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span> &amp;&amp; y == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; p<span class="number">1.</span><span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="type">int</span> t1 = mp[p1[i]];</span><br><span class="line">                <span class="comment">//cout &lt;&lt; p1[i].first&lt;&lt; &quot; &quot; &lt;&lt; p1[i].second &lt;&lt; &quot; &quot; &lt;&lt; t1 &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; p<span class="number">1.</span><span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                    <span class="type">int</span> t2 = mp[p1[j]];</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; t2 &lt;&lt; endl;</span></span><br><span class="line">                    <span class="type">int</span> t3 = mp[p1[j - <span class="number">1</span>]];</span><br><span class="line">                    g[t1][t2] = g[t2][t1] = g[t1][t3] + <span class="built_in">d</span>(p1[j], p1[j - <span class="number">1</span>]) / <span class="number">4</span>;<span class="comment">//由于直接算距离过大，会导致溢出，所以利用前一个站点来计算</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; g[t1][t2] &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">//cout &lt;&lt;endl;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p<span class="number">1.</span><span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(&#123;x, y&#125;))&#123;<span class="comment">//如果之前的节点没有出现过就直接加入到总数组中去</span></span><br><span class="line">                mp[&#123;x,y&#125;] = k++;</span><br><span class="line">                p.<span class="built_in">push_back</span>(&#123;x, y&#125;);                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = p.<span class="built_in">size</span>();<span class="comment">//总的节点个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为到有些走过去站点可能会更快</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; p[i].first&lt;&lt; &quot; &quot; &lt;&lt; p[i].second &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            g[i][j] = <span class="built_in">min</span>(g[i][j], <span class="built_in">d</span>(p[i], p[j]));  <span class="comment">//行走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Floyd算法（可以求出任何两点之间的最短时间）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span>)(g[<span class="number">0</span>][<span class="number">1</span>] + <span class="number">0.5</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = <span class="number">40010</span>;</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">double</span> g[N][N];</span><br><span class="line">vector&lt;pii&gt; p, p1;</span><br><span class="line">map&lt;pii, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> n, a, b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求两个地铁站步行的时间</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">d</span><span class="params">(pii a, pii b)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = a.first - b.first;</span><br><span class="line">    <span class="type">double</span> dy = a.second - b.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy) * <span class="number">0.006</span>; <span class="comment">// 相当于距离除速度，10km/h = 10000m/60min</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)dist[i] = <span class="number">2e18</span>;</span><br><span class="line">dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>;        <span class="comment">//标记是否被用过</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">//记录下没有被确定路径的最短距离的那个</span></span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">t = j;</span><br><span class="line">&#125;</span><br><span class="line">st[t] = <span class="literal">true</span>;<span class="comment">//将当前路径确定</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">//更新最短路径</span></span><br><span class="line">dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) </span><br><span class="line">           <span class="keyword">if</span>(i != j) g[i][j] = <span class="number">2e18</span>;</span><br><span class="line">           <span class="keyword">else</span> g[i][j] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ll x, y, x1, y1, k = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; x1 &gt;&gt; y1;</span><br><span class="line">    p.<span class="built_in">push_back</span>(&#123;x, y&#125;); p.<span class="built_in">push_back</span>(&#123;x1, y1&#125;);<span class="comment">//两个点加入到数组中去</span></span><br><span class="line">    mp[&#123;x, y&#125;] = k++; mp[&#123;x1, y1&#125;] = k++;<span class="comment">//用map保存下来，以后如果遇到之后就不用再加入到数组中去</span></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; x &gt;&gt; y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span> &amp;&amp; y == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; p<span class="number">1.</span><span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="type">int</span> t1 = mp[p1[i]];</span><br><span class="line">                <span class="comment">//cout &lt;&lt; p1[i].first&lt;&lt; &quot; &quot; &lt;&lt; p1[i].second &lt;&lt; &quot; &quot; &lt;&lt; t1 &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; p<span class="number">1.</span><span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                    <span class="type">int</span> t2 = mp[p1[j]];</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; t2 &lt;&lt; endl;</span></span><br><span class="line">                    <span class="type">int</span> t3 = mp[p1[j - <span class="number">1</span>]];</span><br><span class="line">                    g[t1][t2] = g[t2][t1] = g[t1][t3] + <span class="built_in">d</span>(p1[j], p1[j - <span class="number">1</span>]) / <span class="number">4</span>;<span class="comment">//由于直接算距离过大，会导致溢出，所以利用前一个站点来计算</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; g[t1][t2] &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p<span class="number">1.</span><span class="built_in">clear</span>();</span><br><span class="line">            <span class="comment">//cout &lt;&lt;endl;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p<span class="number">1.</span><span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">            <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(&#123;x, y&#125;))&#123;<span class="comment">//如果之前的节点没有出现过就直接加入到总数组中去</span></span><br><span class="line">                mp[&#123;x,y&#125;] = k++;</span><br><span class="line">                p.<span class="built_in">push_back</span>(&#123;x, y&#125;);                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = p.<span class="built_in">size</span>();<span class="comment">//总的节点个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为到有些走过去站点可能会更快</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; p[i].first&lt;&lt; &quot; &quot; &lt;&lt; p[i].second &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            g[i][j] = <span class="built_in">min</span>(g[i][j], <span class="built_in">d</span>(p[i], p[j]));  <span class="comment">//行走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span>)(dist[<span class="number">1</span>] + <span class="number">0.5</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-4249-电车"><a href="#AcWing-4249-电车" class="headerlink" title="AcWing 4249. 电车"></a>AcWing 4249. 电车</h1><h2 id="题目链接-11"><a href="#题目链接-11" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/description/4252/">4249. 电车 - AcWing题库</a></p><h2 id="题解思路-11"><a href="#题解思路-11" class="headerlink" title="题解思路"></a>题解思路</h2><p>Floyd算法（可求任何两个节点间的最短距离、基于动态规划）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> d[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, a, b;</span><br><span class="line">    cin  &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        cin  &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            cin  &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)d[i][x] = <span class="number">0</span>;      <span class="comment">//第一个点需要的步数为0</span></span><br><span class="line">            <span class="keyword">else</span> d[i][x] = <span class="number">1</span>;           <span class="comment">//其他点需要的步数为1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//floyd</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d[a][b] == <span class="number">0x3f3f3f3f</span>)cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; d[a][b] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-4251-Nya图最短路"><a href="#AcWing-4251-Nya图最短路" class="headerlink" title="AcWing 4251. Nya图最短路"></a>AcWing 4251. Nya图最短路</h1><h2 id="题目链接-12"><a href="#题目链接-12" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.acwing.com/problem/content/description/4254/">4251. Nya图最短路 - AcWing题库</a></p><h2 id="题解思路-12"><a href="#题解思路-12" class="headerlink" title="题解思路"></a>题解思路</h2><p>普通建图的话，如果只有两层数据拉拉满，建图直接爆</p><p>在每一层建立虚拟节点,这个点到其他层源点都是0,这个点到本层源点都是c,相当于这个相邻其他层到本层就是c</p><p>然后dj，或者spfa都可以过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="type">const</span>  <span class="type">int</span> N = <span class="number">200010</span>, M = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, c;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], d[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = z, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(pq.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = pq.<span class="built_in">top</span>().second;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[x] == <span class="literal">true</span>)<span class="keyword">continue</span>;</span><br><span class="line">        st[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] &gt; d[x] + w[i])&#123;</span><br><span class="line">                d[j] = d[x] + w[i];</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;d[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; t++)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line">        <span class="type">int</span> cur = n + <span class="number">10</span>; idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        <span class="comment">//在每一层建立虚拟节点,这个点到其他层源点都是0,这个点到本层源点都是c,相当于这个相邻其他层到本层就是c</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> lev;</span><br><span class="line">            cin &gt;&gt; lev;</span><br><span class="line">            <span class="built_in">add</span>(i, cur + lev - <span class="number">1</span>, <span class="number">0</span>); <span class="comment">//这个点到其他层源点都是0</span></span><br><span class="line">            <span class="built_in">add</span>(i, cur + lev + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(cur + lev, i, c);       <span class="comment">//这个点到本层源点都是c，相当于这个相邻其他层到本层就是c</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x, y, z;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">add</span>(x, y, z);</span><br><span class="line">            <span class="built_in">add</span>(y, x, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">dijkstra</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, t);</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">0x3f3f3f3f</span>)cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客创建笔记</title>
      <link href="/archives/6e27d22d.html"/>
      <url>/archives/6e27d22d.html</url>
      
        <content type="html"><![CDATA[<h2 id="需要有git-node-hexo-npm"><a href="#需要有git-node-hexo-npm" class="headerlink" title="需要有git node hexo npm"></a>需要有git node hexo npm</h2><p>全局安装cnpm</p><blockquote><p>npm install -g cnpm —registry=<a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></p></blockquote><p>cnpm 全局安装hexo 博客框架</p><blockquote><p>cnpm install -g hexo-cli</p></blockquote><p>创建blog</p><blockquote><p>mkdir blog</p></blockquote><p>进入blog初始化一个hexo blog</p><blockquote><p>hexo init</p></blockquote><p>创建文章</p><blockquote><p>hexo n “我的笔记”</p></blockquote><h2 id="安装一个插件建立hexo仓库"><a href="#安装一个插件建立hexo仓库" class="headerlink" title="安装一个插件建立hexo仓库"></a>安装一个插件建立hexo仓库</h2><blockquote><p>cnpm install —save hexo-deployer-git</p></blockquote><p>设置配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/jpc901/jpc901.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h2><p>github上搜butterfly主题<br>直接安装</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/archives/4a17b156.html"/>
      <url>/archives/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
