<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>高级数据结构 | 贾小白博客</title><meta name="author" content="jpc901"><meta name="copyright" content="jpc901"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="并查集总概 合并两个集合 查询某个节点的祖宗的节点 记录每个集合的大小：（绑定到根节点） 每个节点到根节点的距离：（绑定到每个节点上）    1250. 格子游戏题目链接：1250. 格子游戏 题解思路：根据题目，将各个元素映射到一维数组中，连接起来，检查连接的过程中是否出现环（若出现环状-》出现连"><link rel="shortcut icon" href="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/031-perseus.png"><link rel="canonical" href="https://jpcly.cn/archives/41da5bdd.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="code-jjsoouLcGZ"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高级数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-23 23:02:53'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220119090729.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/s4..jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="贾小白博客"><span class="site-name">贾小白博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">高级数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-07T03:52:39.000Z" title="发表于 2022-03-07 11:52:39">2022-03-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-23T15:02:53.634Z" title="更新于 2024-08-23 23:02:53">2024-08-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/">算法题解</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="高级数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="总概"><a href="#总概" class="headerlink" title="总概"></a>总概</h2><ol>
<li>合并两个集合</li>
<li>查询某个节点的祖宗的节点<ul>
<li>记录每个集合的大小：（绑定到根节点）</li>
<li>每个节点到根节点的距离：（绑定到每个节点上）</li>
</ul>
</li>
</ol>
<h2 id="1250-格子游戏"><a href="#1250-格子游戏" class="headerlink" title="1250. 格子游戏"></a>1250. 格子游戏</h2><h3 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/description/1252/">1250. 格子游戏</a></p>
<h3 id="题解思路："><a href="#题解思路：" class="headerlink" title="题解思路："></a>题解思路：</h3><p>根据题目，将各个元素映射到一维数组中，连接起来，检查连接的过程中是否出现环（若出现环状-》出现连接的时候两个节点在同一个连通块中）就说明有圈了</p>
<h3 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">41000</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * n + y;</span><br><span class="line">    <span class="comment">//如果是第二种初始化的话可以按照数据来乘倍率</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    return x * 200 + y;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">//只有根节点的p[x] == x，所以继续找</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * n; i++) p[i] = i; <span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从头初始化到结尾,第二种初始化</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt; N; i++)p[i] = i;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="type">char</span> d;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; d;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="comment">//因为输入原因(初始化原因)以及get函数x,y需要从0开始，如果按第二种初始化就不用，也可以不用从0开始</span></span><br><span class="line">        x--, y--;   </span><br><span class="line">        a = <span class="built_in">get</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span>(d == <span class="string">&#x27;D&#x27;</span>) b = <span class="built_in">get</span>(x + <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">else</span> b = <span class="built_in">get</span>(x, y + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b); </span><br><span class="line">        <span class="keyword">if</span>(pa == pb)&#123;       <span class="comment">//父亲节点相等就说明在同一个连通块中，连线必定有环</span></span><br><span class="line">            res = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p[pa] = pb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!res)cout &lt;&lt; <span class="string">&quot;draw&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1252-搭配购买"><a href="#1252-搭配购买" class="headerlink" title="1252. 搭配购买"></a>1252. 搭配购买</h2><h3 id="题目链接：-1"><a href="#题目链接：-1" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/1254/">1252. 搭配购买 - AcWing题库</a></p>
<h3 id="题解思路：-1"><a href="#题解思路：-1" class="headerlink" title="题解思路："></a>题解思路：</h3><p>思路：根据题目，将各个搭配连接起来，就相当于各个连通块选择，使得总价为vol，价值最大的01背包问题</p>
<h3 id="题目代码：-1"><a href="#题目代码：-1" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：根据题目，将各个搭配连接起来，就相当于各个连通块选择，使得总价为vol，价值最大的01背包问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> v[N], w[N], p[N], f[N];         <span class="comment">// v[N] —— 价格、w[N] —— 价值、f[N] —— dp</span></span><br><span class="line"><span class="type">int</span> n, m, vol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]); <span class="comment">// 祖宗节点的p[x] == x,持续向上查找到祖宗节点</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; vol;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)&#123;</span><br><span class="line">            v[pb] += v[pa]; <span class="comment">//总价格全部绑定到祖宗节点上去</span></span><br><span class="line">            w[pb] += w[pa]; <span class="comment">//总价值全部绑定到祖宗节点上去</span></span><br><span class="line">            p[pa] = p[pb];  <span class="comment">//pa的祖宗是pb</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 01背包问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] == i) <span class="comment">//如果是祖宗节点，才进行状态转移（只有祖宗节点是这个连通块的总量）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = vol; j &gt;= v[i]; j--)&#123;</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);  <span class="comment">//状态转移</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[vol] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="237-程序自动分析"><a href="#237-程序自动分析" class="headerlink" title="237. 程序自动分析"></a>237. 程序自动分析</h2><h3 id="题目链接：-2"><a href="#题目链接：-2" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/239/">237. 程序自动分析</a></p>
<h3 id="题解思路：-2"><a href="#题解思路：-2" class="headerlink" title="题解思路："></a>题解思路：</h3><p>离散化+并查集</p>
<p>因为i,j的范围是1~1e9,所以需要离散化，然后就是基本的，相等的点连接到一个连通图里面，不相等的点进行判断。</p>
<p>离散化：</p>
<ol>
<li>保序：排序+判重+二分</li>
<li>不保序： map、hash表</li>
</ol>
<p>此题不保序</p>
<h3 id="题目代码：-2"><a href="#题目代码：-2" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为i,j的范围是1~1e9,所以需要离散化，然后就是基本的，相等的点连接到一个连通图里面，不相等的点进行判断。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n, m, p[N];</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp; <span class="comment">//散列表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Q</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, e;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x) == <span class="number">0</span>) mp[x] = ++n; </span><br><span class="line">    <span class="keyword">return</span> mp[x]; <span class="comment">//返回离散化后对应的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        mp.<span class="built_in">clear</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//离散化各个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++ )&#123;</span><br><span class="line">            <span class="type">int</span> x, y, e;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; e;</span><br><span class="line">            q[i] = &#123;<span class="built_in">get</span>(x), <span class="built_in">get</span>(y), e&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理相等的值，将相等的值连接到一个连通块</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].e == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; q[i].x &lt;&lt; &quot; &quot; &lt;&lt; q[i].y &lt;&lt; endl;</span></span><br><span class="line">                <span class="type">int</span> pa = <span class="built_in">find</span>(q[i].x), pb = <span class="built_in">find</span>(q[i].y);</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//非相等的值判断是否在同一个连通块中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].e == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> pa = <span class="built_in">find</span>(q[i].x), pb = <span class="built_in">find</span>(q[i].y);</span><br><span class="line">                <span class="keyword">if</span>(pa == pb) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="238-银河英雄传说"><a href="#238-银河英雄传说" class="headerlink" title="238. 银河英雄传说"></a>238. 银河英雄传说</h2><h3 id="题目链接：-3"><a href="#题目链接：-3" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/240/">238. 银河英雄传说</a></p>
<h3 id="题解思路：-3"><a href="#题解思路：-3" class="headerlink" title="题解思路："></a>题解思路：</h3><p>并查集：统一维护每个战舰到排头战舰的距离</p>
<p>当我们询问两个战舰间隔的时候是，|dx - dy| - 1 or 0(特判)</p>
<ol>
<li>让排头当根节点-&gt;同时维护一个size表示当前队列的长度</li>
<li>假设有一个初始的队列a,新加一个队列b，就把队列b的排头d[b]+size[a]，并且在find函数里面刷新后面所有d[x];</li>
<li>d[x]表示的是x到p[x]的距离，这样就可以很方便的算出每个节点到最排头的距离</li>
</ol>
<h3 id="题目代码：-3"><a href="#题目代码：-3" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="type">int</span> p[N], d[N], Size[N], T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)&#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);  <span class="comment">//持续向上找到根节点</span></span><br><span class="line">        d[x] += d[p[x]];        <span class="comment">//会更新当前节点到根节点的距离</span></span><br><span class="line">        p[x] = root;            <span class="comment">//向上找到根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) p[i] = i, Size[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            d[pa] = Size[pb];       <span class="comment">//距离pb的距离</span></span><br><span class="line">            Size[pb] += Size[pa];   <span class="comment">//将a这一列的大小加到b这一列</span></span><br><span class="line">            p[pa] = pb;             <span class="comment">//pa的父节点是pb</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa != pb)&#123;           <span class="comment">//不在同一列</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                  <span class="comment">//在同一列</span></span><br><span class="line">                <span class="keyword">if</span>(a != b)          <span class="comment">//不是同一个节点</span></span><br><span class="line">                    cout &lt;&lt; <span class="built_in">abs</span>(d[a] - d[b]) - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="239-奇偶游戏"><a href="#239-奇偶游戏" class="headerlink" title="239. 奇偶游戏"></a>239. 奇偶游戏</h2><h3 id="题目链接：-4"><a href="#题目链接：-4" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/241/">239. 奇偶游戏</a></p>
<h3 id="题解思路：-4"><a href="#题解思路：-4" class="headerlink" title="题解思路："></a>题解思路：</h3><p>总思想：前缀和</p>
<p>前缀和思想，如果是<code>[l, r]</code>内有奇数个1的话那么必有S[r] - S[l-1]为奇数，也即是<code>S[r]、S[l - 1]</code>奇偶性不同</p>
<p>同理如果是<code>[l, r]</code>内有偶数个1的话那么必有S[r] - S[l-1]为偶数，也即是<code>S[r]、S[l - 1]</code>奇偶性相同</p>
<h4 id="方法一（扩展域）"><a href="#方法一（扩展域）" class="headerlink" title="方法一（扩展域）"></a>方法一（扩展域）</h4><p>枚举思想：</p>
<ol>
<li>假设这个节点a是偶，并添加一个节点是a+M是奇</li>
<li>奇偶性相同的放在同一个集合中去</li>
<li>如果一组数据中，类型是偶数，就判断 a与b+M在不在同一个集合中<ul>
<li>在同一个集合中说明矛盾</li>
<li>不在同一个集合中说明不矛盾</li>
</ul>
</li>
<li>如果一组数据中，类型是奇数，就判断a与b是否在同一个集合中<ul>
<li>在同一个集合中说明，矛盾</li>
<li>不在同一个集合中说明不矛盾</li>
</ul>
</li>
</ol>
<h4 id="方法二（带边权）"><a href="#方法二（带边权）" class="headerlink" title="方法二（带边权）"></a>方法二（带边权）</h4><p>维护一个带边权的并查集</p>
<ol>
<li>d[x]表示x与p[x]的关系<ul>
<li>0表示同类</li>
<li>1表示不同类</li>
</ul>
</li>
<li>x与y是同类<ul>
<li>p[x] = p[y]<ul>
<li>d[x] ^ d[y]是0无矛盾，d[x]^d[y]是1有矛盾</li>
</ul>
</li>
<li>p[x] != p[y]<ul>
<li>d[p[x]] = d[x] ^ d[y]</li>
</ul>
</li>
</ul>
</li>
<li>xy异类<ul>
<li>p[x] = p[y]<ul>
<li>d[x] ^ d[y]是0有矛盾，d[x]^d[y]是1无矛盾</li>
</ul>
</li>
<li>p[x] != p[y]<ul>
<li>d[p[x]] = d[x] ^ d[y] ^ 1</li>
</ul>
</li>
</ul>
</li>
<li>综上所述，就相当于代边权一个路径d表示x与根节点的关系，在find函数中需要对d进行更新类似于238题</li>
</ol>
<h3 id="题目代码：-4"><a href="#题目代码：-4" class="headerlink" title="题目代码："></a>题目代码：</h3><h4 id="方法一-（扩展域）"><a href="#方法一-（扩展域）" class="headerlink" title="方法一 （扩展域）"></a>方法一 （扩展域）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">41000</span>, M = N / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> p[N], n, m;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x) == <span class="number">0</span>) mp[x] = ++n;</span><br><span class="line">    <span class="keyword">return</span> mp[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        string t;   <span class="comment">//类型（奇偶）</span></span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; t; </span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b);     <span class="comment">//相当于奇偶性~（Sl-1, Sr）</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">&quot;even&quot;</span>)&#123;                <span class="comment">//奇偶性相同</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b + M))&#123; <span class="comment">//必然b+M与a的奇偶性就不能相同</span></span><br><span class="line">                res = i - <span class="number">1</span>;            </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            p[<span class="built_in">find</span>(a + M)] = <span class="built_in">find</span>(b + M);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                          <span class="comment">//奇偶性不同</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))&#123;     <span class="comment">//那么奇偶性必然不能相同</span></span><br><span class="line">                res = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b + M);   <span class="comment">//奇偶性相同的点加入到同一个集合中</span></span><br><span class="line">            p[<span class="built_in">find</span>(a + M)] = <span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二（带边权）-1"><a href="#方法二（带边权）-1" class="headerlink" title="方法二（带边权）"></a>方法二（带边权）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">41000</span>, M = N / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> p[N], d[N], n, m;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)&#123;</span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]] % <span class="number">2</span>; <span class="comment">//奇偶性原因，不影像最后结果，同时也防止爆int</span></span><br><span class="line">        p[x] = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//离散化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x) == <span class="number">0</span>) mp[x] = ++n;</span><br><span class="line">    <span class="keyword">return</span> mp[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        string t;   <span class="comment">//类型（奇偶）</span></span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; t; </span><br><span class="line">        a = <span class="built_in">get</span>(a - <span class="number">1</span>), b = <span class="built_in">get</span>(b);     <span class="comment">//相当于奇偶性~（Sl-1, Sr）</span></span><br><span class="line">        <span class="keyword">if</span>(t == <span class="string">&quot;even&quot;</span>)&#123;                <span class="comment">//奇偶性相同</span></span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa == pb)&#123;               <span class="comment">//在同一集合中</span></span><br><span class="line">                <span class="keyword">if</span>((d[a] ^ d[b]) % <span class="number">2</span>)&#123;  <span class="comment">//防止爆int</span></span><br><span class="line">                    res = i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">                d[pa] = d[a] ^ d[b];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                              <span class="comment">//奇偶性不同</span></span><br><span class="line">            <span class="type">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa == pb)&#123;                   <span class="comment">//在同一集合中</span></span><br><span class="line">                <span class="keyword">if</span>((d[a] ^ d[b]) % <span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">//防止爆int</span></span><br><span class="line">                    res = i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">                d[pa] = d[a] ^ d[b] ^ <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>引入问题<br>给出一个长度为n的数组，完成以下两种操作：</p>
<ol>
<li>将第i个数加上k</li>
<li>输出区间<code>[i,j]</code>内每个数的和</li>
</ol>
<h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>单点修改：O(1)<br>区间查询：O(n)</p>
<h3 id="树状数组-1"><a href="#树状数组-1" class="headerlink" title="树状数组"></a>树状数组</h3><p>快速求前缀和</p>
<p>单点修改：O(logn)<br>区间查询：O(logn)</p>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit()"></a>lowbit()</h3><p>lowbit()运算：x &amp; (-x) 的用途一般是用来获取某个二进制数的 LowBit ，在树状数组中会用到<br>lowbit(x)是x的二进制表达式中最低位的1所对应的值.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组思想"><a href="#树状数组思想" class="headerlink" title="树状数组思想"></a>树状数组思想</h3><p>树状数组的本质思想是使用树结构维护”前缀和”，从而把时间复杂度降为O(logn)。</p>
<p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220308170615088.png" alt=""></p>
<p>对于一个序列，对其建立如下树形结构：</p>
<ul>
<li>每个结点t[x]保存以x为根的子树中叶结点值的和</li>
<li>每个结点覆盖的长度为lowbit(x)</li>
<li>t[x]结点的父结点为t[x + lowbit(x)]</li>
<li>树的深度为log2n+1log2n+1</li>
</ul>
<h3 id="树状数组操作"><a href="#树状数组操作" class="headerlink" title="树状数组操作"></a>树状数组操作</h3><h4 id="add-x-k-表示将序列中第x个数加上k。"><a href="#add-x-k-表示将序列中第x个数加上k。" class="headerlink" title="add(x, k)表示将序列中第x个数加上k。"></a>add(x, k)表示将序列中第x个数加上k。</h4><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220308170815852.png" alt=""></p>
<p>以add(3, 5)为例：<br>在整棵树上维护这个值，需要一层一层向上找到父结点，并将这些结点上的t[x]值都加上k，这样保证计算区间和时的结果正确。时间复杂度为O(logn)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        t[i] += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ask-x-表示将查询序列前x个数的和"><a href="#ask-x-表示将查询序列前x个数的和" class="headerlink" title="ask(x)表示将查询序列前x个数的和"></a>ask(x)表示将查询序列前x个数的和</h4><p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220308170841138.png" alt=""></p>
<p>以ask(7)为例：<br>查询这个点的前缀和，需要从这个点向左上找到上一个结点，将加上其结点的值。向左上找到上一个结点，只需要将下标 x -= lowbit(x)，</p>
<p>例如 7 - lowbit(7) = 6。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        sum += t[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组初始化"><a href="#树状数组初始化" class="headerlink" title="树状数组初始化"></a>树状数组初始化</h3><p>若给你一个数组，时间卡的特别紧的话，需要O(n)的时间复杂度去初始化树状数组，那么可以On求出前缀和数组S</p>
<p>tr[x] = S[x] - S[x - lowbit(x)]</p>
<p>上述介绍引用：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/solution/content/13818/">qiaoxinwei</a></p>
<h2 id="241-楼兰图腾"><a href="#241-楼兰图腾" class="headerlink" title="241. 楼兰图腾"></a>241. 楼兰图腾</h2><h3 id="题目链接：-5"><a href="#题目链接：-5" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/243/">241. 楼兰图腾</a></p>
<h3 id="题解思路：-5"><a href="#题解思路：-5" class="headerlink" title="题解思路："></a>题解思路：</h3><p>树状数组</p>
<ol>
<li>tr[x]保存数据在[1, x]的个数，<code>t[r] - t[l-1]</code>代表在<code>[l, r]</code>之间数据的个数</li>
<li>Greater[i]表示前i个数里面有多少个比a[i]大的数、Lower[i]表示前i个数里面有多少个比a[i]小的数</li>
<li>以i为中心，左边大于i的*右边大于i的就是以当前i为中心的所有V个数</li>
</ol>
<h3 id="题目代码：-5"><a href="#题目代码：-5" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210000</span>;</span><br><span class="line"><span class="type">int</span> a[N], tr[N], Greater[N], Lower[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;  <span class="comment">//从前往后遍历更新将会影响到后面所有的tr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i]; <span class="comment">//从后往前遍历减去末位1所对应的值</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        Greater[i] = <span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y);   <span class="comment">//前i个元素中，在[y + 1, n]范围的个数</span></span><br><span class="line">        Lower[i] = <span class="built_in">sum</span>(y - <span class="number">1</span>);          <span class="comment">//前i个元素中， 在[1, y - 1]范围的个数</span></span><br><span class="line">        <span class="built_in">add</span>(y, <span class="number">1</span>);      <span class="comment">//添加y,个数为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);       <span class="comment">//初始化一下变成0,因为后续操作需要从右边往左遍历</span></span><br><span class="line">    ll res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        res1 += Greater[i] * (ll)(<span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y)); <span class="comment">//[i + 1, n]元素中，在[y + 1, n]范围的个数</span></span><br><span class="line">        res2 += Lower[i] * (ll)(<span class="built_in">sum</span>(y - <span class="number">1</span>));        <span class="comment">//[i + 1, n]元素中， 在[1, y - 1]范围的个数</span></span><br><span class="line">        <span class="built_in">add</span>(y, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, res1, res2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="242-一个简单的整数问题"><a href="#242-一个简单的整数问题" class="headerlink" title="242. 一个简单的整数问题"></a>242. 一个简单的整数问题</h2><h3 id="题目链接：-6"><a href="#题目链接：-6" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/description/248/">242. 一个简单的整数问题</a></p>
<h3 id="题解思路：-6"><a href="#题解思路：-6" class="headerlink" title="题解思路："></a>题解思路：</h3><p>树状数组+差分</p>
<ol>
<li>根据题目意思在a数组的<code>[l, r]</code>区间每个元素加d，可以求a数组的差分，然后对a数组的差分来求树状数组</li>
<li>可以根据a数组的差分来求的树状数组，来还原a数组</li>
</ol>
<h3 id="题目代码：-6"><a href="#题目代码：-6" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N], n, m;</span><br><span class="line">ll  tr[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) s += tr[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">add</span>(i, a[i] - a[i - <span class="number">1</span>]);    <span class="comment">//求a数组差分的树状数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> l, r, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;l);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">sum</span>(l));   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;d);</span><br><span class="line">            <span class="built_in">add</span>(l, d), <span class="built_in">add</span>(r + <span class="number">1</span>, -d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="243-一个简单的整数问题2"><a href="#243-一个简单的整数问题2" class="headerlink" title="243. 一个简单的整数问题2"></a>243. 一个简单的整数问题2</h2><h3 id="题目链接：-7"><a href="#题目链接：-7" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/description/244/">243. 一个简单的整数问题2</a></p>
<h3 id="题解思路：-7"><a href="#题解思路：-7" class="headerlink" title="题解思路："></a>题解思路：</h3><p>树状数组+差分</p>
<ol>
<li><p>根据差分的思想，求出a的差分数组b</p>
</li>
<li><script type="math/tex; mode=display">
a数组前n个之和 --- \sum_{i = 0}^{n}a_i \\
a的差分数组b可以求a_i \\
也等于 \sum_{i = 0}^{n}\sum_{j = 0}^{i}b_j\\
a前n个数的之和 = \sum_{i = 0}^{n}a_i = \sum_{i = 0}^{n}\sum_{j = 0}^{i}b_j</script></li>
</ol>
<h3 id="题目代码：-7"><a href="#题目代码：-7" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line">ll tr1[N], tr2[N];  <span class="comment">// b的前缀和， b * i 的前缀和</span></span><br><span class="line"><span class="type">int</span> n, m, a[N];     <span class="comment">//b是a的差分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll tr[], <span class="type">int</span> x, ll c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll tr[], <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) s += tr[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pre_sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(tr1, x) * (x + <span class="number">1</span>) - <span class="built_in">sum</span>(tr2, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> b = a[i] - a[i - <span class="number">1</span>];    <span class="comment">//a数组的差分</span></span><br><span class="line">        <span class="built_in">add</span>(tr1, i, b);             <span class="comment">//维护差分数组b</span></span><br><span class="line">        <span class="built_in">add</span>(tr2, i, (ll)b * i);     <span class="comment">//维护b * i的树状数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> l, r, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">pre_sum</span>(r) - <span class="built_in">pre_sum</span>(l - <span class="number">1</span>));  <span class="comment">//更具推出来的公式</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">add</span>(tr1, l, d), <span class="built_in">add</span>(tr1, r + <span class="number">1</span>, -d);            </span><br><span class="line">            <span class="built_in">add</span>(tr2, l, d * l), <span class="built_in">add</span>(tr2, r + <span class="number">1</span>, -d * (r + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="244-谜一样的牛"><a href="#244-谜一样的牛" class="headerlink" title="244. 谜一样的牛"></a>244. 谜一样的牛</h2><h3 id="题目链接：-8"><a href="#题目链接：-8" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/245/">244. 谜一样的牛</a></p>
<h3 id="题解思路：-8"><a href="#题解思路：-8" class="headerlink" title="题解思路："></a>题解思路：</h3><p>树状数组+二分查找</p>
<ol>
<li>根据观察发现最后一头牛可以确定：最后一头牛前面有k个比它矮的牛，那么它必定是第k+1矮的牛</li>
<li>所以从后往前遍历，每次确定最后一头牛，他当前高度必定是剩下的牛种第k+1矮的（可以通过二分查找来确定每头牛的高度）</li>
<li>每确定一头牛，就删除这头牛的高度</li>
</ol>
<h3 id="题目代码：-8"><a href="#题目代码：-8" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N], res[N], tr[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) s += tr[i];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) tr[i] = <span class="built_in">lowbit</span>(i);   <span class="comment">//初始化tr，（每种高度的个数都是1）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i; i -- ) &#123; <span class="comment">//从后往前遍历,确定每一头牛的身高</span></span><br><span class="line">        <span class="type">int</span> k = h[i] + <span class="number">1</span>;		<span class="comment">//这头牛的高度必定是剩下牛当中第k+1矮的</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;         <span class="comment">//二分查找剩下的数中第一个等于k的，就是当前牛的高度</span></span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sum</span>(mid) &gt;= k) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = r;             <span class="comment">//当前牛的高度</span></span><br><span class="line">        <span class="built_in">add</span>(r, <span class="number">-1</span>);             <span class="comment">//删除此高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="操作原理"><a href="#操作原理" class="headerlink" title="操作原理"></a>操作原理</h2><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol>
<li><p>pushup(u)：子节点的信息更新父节点的信息。</p>
</li>
<li><p>build()：将一段区间初始化成线段树。</p>
</li>
<li><p>modify()：修改。</p>
<ul>
<li><p>单点：easy。</p>
</li>
<li><p>区间：pushdown（懒标记）hard。</p>
<ul>
<li><p>类似于查询的时候，找到一个完整区间的时候直接标记一下（需要维护一个add）。</p>
</li>
<li><p>维护一个add(懒标记)，以当前节点为根的子树中的每一个节点加上一个add（不包含根节点）。</p>
</li>
<li><p>在pushdown的时候被标记的节点如果继续往下递归的话，就将当前节点的标记取消并且递归到子节点上，这样所有叶子节点的祖宗节点的标记已经取消掉，并且累加到此叶子节点上了。</p>
<p><code>left.add += root.add, left.sum += (left.r - left.l + 1) * root.add</code></p>
<p><code>right.add += root.add, right += (right.r - right.l + 1) * root.add</code></p>
<p><code>root.add = 0</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>query()：查询</p>
<p>查询某一个子区间的时候一定要pushdown一下</p>
</li>
</ol>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>满二叉树</p>
<script type="math/tex; mode=display">
编号是x \begin{cases} 父节点：x/2下取整-->\ x >> 1 \\
左儿子：2x --> \ x << 1 \\
右儿子：2x+1 --> \ x << 1|1\end{cases}</script><p>线段树一般开空间：4n</p>
<h2 id="1-最大数"><a href="#1-最大数" class="headerlink" title="1. 最大数"></a>1. 最大数</h2><h3 id="题目链接：-9"><a href="#题目链接：-9" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/1277/">最大数</a></p>
<h3 id="题解思路：-9"><a href="#题解思路：-9" class="headerlink" title="题解思路："></a>题解思路：</h3><p>线段树</p>
<ol>
<li>用线段树维护区间最大值</li>
<li>查询时<ul>
<li><code>[tr.l , tr.r] 属于 [l, r]</code>直接返回<code>[tr.l, tr.r]</code>区间内维护的最大值即可</li>
<li>l &lt;= mid说明有左边部分，递归往左边查询即可</li>
<li>r&gt;mid说明有右边部分，递归往右边查询即可</li>
</ul>
</li>
<li>修改时<ul>
<li>递归调用，直至叶节点，修改叶节点的值</li>
<li>pushup一下，将子节点的信息更新到父节点上</li>
</ul>
</li>
</ol>
<h3 id="题目代码：-9"><a href="#题目代码：-9" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> m, p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般开的空间大小为4*N</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> v; <span class="comment">//维护区间最大值</span></span><br><span class="line">&#125;tr[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span>  <span class="comment">// 由子节点的信息，来计算父节点的信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].v = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].v, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线段树，u为当前线段树的节点编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>; <span class="comment">//l == r说明是叶子节点直接退出</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询以u为根节点，[l,r]中的最大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//区间[tr[u].l, tr[u].r] 属于区间[l, r],直接返回就得到当前区间最大值</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].v; </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左边</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) v = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l , r); <span class="comment">//往左边查询</span></span><br><span class="line">    <span class="comment">//右边</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) v = <span class="built_in">max</span>(v, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l ,r)); <span class="comment">//取右边与左边的最大值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//u为节点为编号，更新该节点的最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == tr[u].r) tr[u].v = v;  <span class="comment">//叶节点，递归出口</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//分治处理左右子树, 寻找x所在的子树</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="comment">//pushup操作, 子结点的信息更新父节点</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, last = <span class="number">0</span>; <span class="comment">// n表示树中节点个数、last表示上一次操作</span></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, m); <span class="comment">//初始化线段树，节点的区间[1, m]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)&#123;       <span class="comment">//添加结点</span></span><br><span class="line">            <span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, n + <span class="number">1</span>, ((LL)t + last) % p); <span class="comment">//在n + 1处插入   </span></span><br><span class="line">            n++;    <span class="comment">//结点个数+1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;        <span class="comment">//询问</span></span><br><span class="line">            <span class="type">int</span> L; cin &gt;&gt; L;</span><br><span class="line">            last = <span class="built_in">query</span>(<span class="number">1</span>, n - L + <span class="number">1</span>, n); <span class="comment">//查询[n - L + 1, n]内的最大值，u = 1，即从根节点开始查询</span></span><br><span class="line">            cout &lt;&lt; last &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-你能回答这些问题吗"><a href="#2-你能回答这些问题吗" class="headerlink" title="2. 你能回答这些问题吗"></a>2. 你能回答这些问题吗</h2><h3 id="题目链接：-10"><a href="#题目链接：-10" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/246/">你能回答这些问题吗</a></p>
<h3 id="题解思路：-10"><a href="#题解思路：-10" class="headerlink" title="题解思路："></a>题解思路：</h3><p>思路：</p>
<ol>
<li><p>维护四个数值：</p>
<ul>
<li>tmax：最大连续子段和</li>
<li>lmax：最大前缀和</li>
<li>rmax：最大后缀和</li>
<li>sum：区间和</li>
</ul>
</li>
<li><p>确定tmax:</p>
<p>$tmax = max(left-son.tmax, right-son.tmax, left-son.rmax + right-son.lmax)$</p>
</li>
<li><p>确定lmax,rmax:</p>
<p>以维护lmax为例：</p>
<ul>
<li>完全在左区间内：左边的lmax</li>
<li>横跨两个区间：左边的sum+右边的lmax</li>
</ul>
<p>rmax同理</p>
</li>
</ol>
<h3 id="题目代码：-10"><a href="#题目代码：-10" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> w[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> tmax, lmax, rmax, sum;  <span class="comment">//维护最大连续子段和、最大前缀和、最大后缀和、区间和</span></span><br><span class="line">&#125;tr[<span class="number">4</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;                              <span class="comment">//区间和</span></span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);               <span class="comment">//前缀和等于两种请况取最大值（左区间的前缀和，左区间的sum + 右区间的前缀和）</span></span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);               <span class="comment">//后缀和同理</span></span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax, r.tmax), l.rmax + r.lmax); <span class="comment">//最大连续字段和取三种情况的最大和（左区间tmax,右区间tmax,在中间（左区间后缀+右区间前缀和））</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果是叶节点,叶节点直接赋值</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;; </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l , r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r); <span class="comment">//递归建立左右子树</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);  <span class="comment">//子节点去更新父节点的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果到达叶节点</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x) tr[u] = &#123;x, x, v, v, v, v&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid &gt;= x)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);   <span class="comment">//往左边递归</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);      <span class="comment">//往右边递归</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);      <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//查询区间包含当前线段树区间</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid &gt;= r) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);            <span class="comment">//在左</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);    <span class="comment">//在右边</span></span><br><span class="line">        <span class="keyword">else</span>&#123;                                               <span class="comment">//横跨两个区间</span></span><br><span class="line">            Node left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);            </span><br><span class="line">            Node right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">            Node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> k, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, x, y).tmax);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-区间最大公约数"><a href="#3-区间最大公约数" class="headerlink" title="3. 区间最大公约数"></a>3. 区间最大公约数</h2><h3 id="题目链接：-11"><a href="#题目链接：-11" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/247/">区间最大公约数</a></p>
<h3 id="题解思路：-11"><a href="#题解思路：-11" class="headerlink" title="题解思路："></a>题解思路：</h3><p>操作1：区间<code>[l,r]</code>增加一个数</p>
<p>操作2：区间<code>[l,r]</code>最大公约数</p>
<p>思路：</p>
<ol>
<li><p>将区间增加一个数，转换为单点增加一个数，可以推出用差分。</p>
</li>
<li><p>证明差分数组和原数组某个区间内有共同的最大公因数。</p>
<ul>
<li>($a<em>1,a_2,···，a_n$）= （$a_1,a_2-a_1,···，a_n-a</em>{n-1} $）</li>
<li>gcd(a, b) = gcd(a, b - a)</li>
<li>gcd(a, b) = gcd(a, -b)</li>
</ul>
</li>
<li><p>查询某个区间<code>[l, r]</code>的最大公约数</p>
<p>$gcd(a[l], gcd(b[l + 1], b[r]))$</p>
</li>
</ol>
<h3 id="题目代码：-11"><a href="#题目代码：-11" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;        </span><br><span class="line">LL w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL sum, d;</span><br><span class="line">&#125;tr[<span class="number">4</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span>  <span class="comment">//求最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span>  <span class="comment">//由子区间信息更新父区间信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;  <span class="comment">// 区间和</span></span><br><span class="line">    u.d = <span class="built_in">gcd</span>(l.d, r.d);    <span class="comment">//左右区间最大公约数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span>         </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].l = l, tr[u].r = r;</span><br><span class="line">    <span class="keyword">if</span> ( l == r ) </span><br><span class="line">        tr[u].d = w[l] - w[l - <span class="number">1</span>], tr[u].sum = w[l] - w[l - <span class="number">1</span>]; <span class="comment">//将差分数组维护到线段树中去</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);      <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, LL v)</span>         </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//叶节点</span></span><br><span class="line">    <span class="keyword">if</span> ( tr[u]. r == x &amp;&amp; tr[u].l == x ) </span><br><span class="line">        tr[u].d = tr[u].sum + v, tr[u].sum += v;        </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;       </span><br><span class="line">        <span class="keyword">if</span> ( mid &gt;= x ) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);   <span class="comment">//修改左区间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);          <span class="comment">//修改右区间</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查询区间包含当前线段树区间</span></span><br><span class="line">    <span class="keyword">if</span> ( tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r ) <span class="keyword">return</span> tr[u];   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( mid &gt;= r ) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( mid &lt; l ) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);        <span class="comment">//如果当前访问区间的子区间横跨询问区间</span></span><br><span class="line">            Node right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);   <span class="comment">//则递归两个子区间</span></span><br><span class="line">            Node res;                               </span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right);               <span class="comment">//更新，相当于求right和left区间合并后的结果</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin  &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n); <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL d;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, l);     <span class="comment">//求前缀和得到a[l]</span></span><br><span class="line">            <span class="function">Node <span class="title">right</span><span class="params">(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (l + <span class="number">1</span> &lt;= r) right = <span class="built_in">query</span>(<span class="number">1</span>, l + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">abs</span>(<span class="built_in">gcd</span>(left.sum, right.d)));  <span class="comment">//gcd(a[l], gcd(b[l + 1], b[r]))</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, d);</span><br><span class="line">            <span class="keyword">if</span> ( r + <span class="number">1</span> &lt;= n ) <span class="built_in">modify</span>(<span class="number">1</span>, r + <span class="number">1</span>, -d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-一个简单的整数问题2"><a href="#4-一个简单的整数问题2" class="headerlink" title="4. 一个简单的整数问题2"></a>4. 一个简单的整数问题2</h2><h3 id="题目链接：-12"><a href="#题目链接：-12" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/description/244/">一个简单的整数问题2</a></p>
<h3 id="题解思路：-12"><a href="#题解思路：-12" class="headerlink" title="题解思路："></a>题解思路：</h3><p>最基本的线段树做法（添加懒标记）</p>
<ul>
<li><p>类似于查询的时候，找到一个完整区间的时候直接标记一下（需要维护一个add）。</p>
</li>
<li><p>维护一个add(懒标记)，以当前节点为根的子树中的每一个节点加上一个add（不包含根节点）。</p>
</li>
<li><p>在pushdown的时候被标记的节点如果继续往下递归的话，就将当前节点的标记取消并且递归到子节点上，这样所有叶子节点的祖宗节点的标记已经取消掉，并且累加到此叶子节点上了。</p>
<p><code>left.add += root.add, left.sum += (left.r - left.l + 1) * root.add</code></p>
<p><code>right.add += root.add, right += (right.r - right.l + 1) * root.add</code></p>
<p><code>root.add = 0</code></p>
</li>
</ul>
<h3 id="题目代码：-12"><a href="#题目代码：-12" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> w[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum, add;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum; <span class="comment">//左右儿子之和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u); <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add)&#123;</span><br><span class="line">        left.add += root.add, left.sum += (ll)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (ll)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改之前也需要pushdown()一下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)&#123;</span><br><span class="line">        tr[u].sum += (ll)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//分裂的情况</span></span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询之前一定要pushdown()一下</span></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-亚特兰蒂斯"><a href="#5-亚特兰蒂斯" class="headerlink" title="5. 亚特兰蒂斯"></a>5. 亚特兰蒂斯</h2><h3 id="题目链接：-13"><a href="#题目链接：-13" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/249/">亚特兰蒂斯</a></p>
<h3 id="题解思路：-13"><a href="#题解思路：-13" class="headerlink" title="题解思路："></a>题解思路：</h3><p>线段树+扫描线+离散化</p>
<p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220310200933974.png" alt=""></p>
<p>操作一：将某一个区间[l, r] + k</p>
<p>操作二：整个区间中权值大于0的总长是多少</p>
<p>需要用离散化去处理y坐标，但是线段树维护的是y这个区间。</p>
<p>线段树中的节点信息：</p>
<ol>
<li>cnt 当前区间整个被覆盖的次数</li>
<li>len 不考虑祖先节点cnt的前提下cnt&gt;0的区间总长</li>
</ol>
<p>扫描线：</p>
<ol>
<li>永远只考虑根节点的信息（说明在query的时候不需要pushdown）</li>
<li>所有操作都是成对出现，且先加后减</li>
</ol>
<h3 id="题目代码：-13"><a href="#题目代码：-13" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">double</span>&gt;ys;<span class="comment">//用于离散化</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来存线段信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y1, y2;</span><br><span class="line">    <span class="type">int</span> d; <span class="comment">// 区分它是该矩阵前面的线段还是后面的线段</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> segment&amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">     &#125; </span><br><span class="line">&#125;seg[N * <span class="number">2</span>];<span class="comment">//每个矩阵需要存两个线段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树的每个节点 保存的为线段, 0号点为y[0]到y[1]，以此类推</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> cnt;    <span class="comment">// 记录当前区间整个被覆盖的次数</span></span><br><span class="line">    <span class="type">double</span> len; <span class="comment">// 记录这段区间的长度</span></span><br><span class="line">&#125;tr[N * <span class="number">8</span>];     <span class="comment">//由于线段二倍，所以8倍空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回第一个 &gt;= y 的数的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), y) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].cnt)tr[u].len = ys[tr[u].r + <span class="number">1</span>] - ys[tr[u].l];<span class="comment">//表示整个区间都被覆盖，该段长度就为右端点 + 1后在ys中的值 - 左端点在ys中的值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l != tr[u].r)&#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>;<span class="comment">//表示为叶子节点且该线段没被覆盖，为无用线段，长度变为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;</span><br><span class="line">        tr[u].cnt += d;     </span><br><span class="line">        <span class="built_in">pushup</span>(u);          <span class="comment">//更新该节点的len</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].r + tr[u].l &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);      <span class="comment">//左边存在点</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);   <span class="comment">//右边存在点</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);      <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l != r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>,l,mid),<span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,mid + <span class="number">1</span>,r);</span><br><span class="line">        <span class="comment">//后面都为0，不需更新len</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        ys.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;              <span class="comment">//线段个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++) &#123;</span><br><span class="line">            <span class="type">double</span> x1,y1,x2,y2;</span><br><span class="line">            cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">            seg[j ++] = &#123;x1, y1, y2, <span class="number">1</span>&#125;;        <span class="comment">//前面的线段</span></span><br><span class="line">            seg[j ++] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;       <span class="comment">//后面的线段</span></span><br><span class="line">            ys.<span class="built_in">push_back</span>(y1), ys.<span class="built_in">push_back</span>(y2);  <span class="comment">//y轴出现过那些点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(seg,seg + j);          <span class="comment">//线段按x排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//去重</span></span><br><span class="line">        <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());  </span><br><span class="line">        ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());<span class="comment">//离散化去重</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, ys.<span class="built_in">size</span>() - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; j ; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i)res += tr[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x); <span class="comment">//根节点的长度即为此时有效线段长度 ，再 * x轴长度即为面积</span></span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>, T ++ );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Total explored area: %.2lf\n\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="6-维护序列"><a href="#6-维护序列" class="headerlink" title="6. 维护序列"></a>6. 维护序列</h2><h3 id="题目链接：-14"><a href="#题目链接：-14" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/1279/">维护序列</a></p>
<h3 id="题解思路：-14"><a href="#题解思路：-14" class="headerlink" title="题解思路："></a>题解思路：</h3><p>线段树需要维护的信息：</p>
<p>sum、add、mul 需要有两个懒标记，先乘再加，方便更新mul和add</p>
<p>只是基础线段树的一个拓展</p>
<h3 id="题目代码：-14"><a href="#题目代码：-14" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, p, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, add, mul;  <span class="comment">//维护一个乘一个加,先乘后加使得便于维护</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    tr[u].sum = (tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % p; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(Node &amp;t, <span class="type">int</span> add, <span class="type">int</span> mul)</span> </span>&#123;</span><br><span class="line">    t.sum = ((LL)t.sum * mul + (LL)(t.r - t.l + <span class="number">1</span>) * add) % p; <span class="comment">//计算总和</span></span><br><span class="line">    t.mul = (LL)t.mul * mul % p;            <span class="comment">//先乘后加使得便于维护</span></span><br><span class="line">    t.add = ((LL)t.add * mul + add) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消除祖宗节点的标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span>], tr[u].add, tr[u].mul); </span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);  <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> add, <span class="type">int</span> mul)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="built_in">eval</span>(tr[u], add, mul);    <span class="comment">//计算一下当前节点的值</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, add, mul);   <span class="comment">//修改左右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum = (sum + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r)) % p;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m --) &#123;</span><br><span class="line">        <span class="type">int</span> t, l, r, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, <span class="number">0</span>, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="可持久化数据结构"><a href="#可持久化数据结构" class="headerlink" title="可持久化数据结构"></a>可持久化数据结构</h1><ol>
<li>trie的可持久化</li>
<li>线段树的可持久化——主席树</li>
</ol>
<p>可持久化的前提：本身拓扑结构、不变</p>
<p>解决的问题：将所有数据结构的历史版本都保存下来（有点像git）</p>
<p>核心思想：只记录每一个版本与前一个版本不同的节点</p>
<p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220311172906244.png" alt=""></p>
<h2 id="1-最大异或和"><a href="#1-最大异或和" class="headerlink" title="1. 最大异或和"></a>1. 最大异或和</h2><h3 id="题目链接：-15"><a href="#题目链接：-15" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/description/258/">最大异或和</a></p>
<h3 id="题解思路：-15"><a href="#题解思路：-15" class="headerlink" title="题解思路："></a>题解思路：</h3><ol>
<li>求出前缀异或和，每次所求就是：$S<em>{p-1}\ xor\ S</em>{N}\ xor \ x = c$使得在l,r内c最大。</li>
<li>但是会有A操作在数组尾添加元素，这样就会影响到查询的结果，所有用可持久化维护各个版本，求[1, R]可用root[R]以及上述公式来求最大c。</li>
<li>但是同时又得求[L ,R]之内得最大c,所有需要trie维护一个信息，max-id（当前子树下标的最大值），只要当前子树下标最大值符合[L , R]就可以继续往当前子树查询。</li>
</ol>
<h3 id="题目代码：-15"><a href="#题目代码：-15" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 30w初始数据和30w新增,  而10的7次方小于2的24次方, 再加上根节点, 就是说每个数最多需要25位;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">600010</span>, M = N * <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 前缀和序列</span></span><br><span class="line"><span class="type">int</span> tr[M][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> max_id[M];  <span class="comment">// 用于记录当前根节点版本的最大id范围</span></span><br><span class="line"><span class="type">int</span> root[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i是第i个插入的数的i, p是上一个插入的数的节点号, q是当前节点号, k是现在取到第k位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> k, <span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果记录结束了</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max_id[q] = i;  <span class="comment">// 记录当前节点(可能会被后面公用)所能到达的最大范围i</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出前缀和的二进制表示从右往左数第k位v</span></span><br><span class="line">    <span class="comment">// 需要注意的是, 这个s[i]就是我们要存的东西!!!!!</span></span><br><span class="line">    <span class="type">int</span> v = s[i] &gt;&gt; k &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前一个节点存在当前节点没有的分支, 那就把当前节点的这个空的路径指过去, 这就相当于复制!</span></span><br><span class="line">    <span class="keyword">if</span> (p) tr[q][v ^ <span class="number">1</span>] = tr[p][v ^ <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    tr[q][v] = ++idx; <span class="comment">// 现在才是正常trie树插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归插入下一位二进制, tr[q][v]就是我们本轮插入的新节点</span></span><br><span class="line">    <span class="comment">// 而前面我们只复制了前一轮的不同v方向的路径, v方向的还没动过, 于是放到p里面等下一轮</span></span><br><span class="line">    <span class="comment">// 至于为什么可以放到下一轮, 因为当前q新插入的数字(二进制当前位)是v, 而p的这条路径也是v</span></span><br><span class="line">    <span class="comment">// 所以暂时不需要复制</span></span><br><span class="line">    <span class="built_in">insert</span>(i, k - <span class="number">1</span>, tr[p][v], tr[q][v]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是递归到所有点都插入完成才开始进行的, 所以能把最大max_id递归传递回去</span></span><br><span class="line">    <span class="comment">// 每个点的最大范围用子节点最大的值, 然后还能递归传递回去, 因为当前递归层</span></span><br><span class="line">    <span class="comment">// 的q, 就是上一层的tr[q][v], 观察易知每个节点都会有对应max_id</span></span><br><span class="line">    max_id[q] = <span class="built_in">max</span>(max_id[tr[q][<span class="number">0</span>]], max_id[tr[q][<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> C, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 选用合适的root, 就是第r-1个节点作为root(-1已在传参前完成)</span></span><br><span class="line">    <span class="comment">// 然后根据异或的前缀和性质才能保证在r左边</span></span><br><span class="line">    <span class="type">int</span> p = root[r];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">23</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// C是s[n] ^ x, 从高位到低位逐位检索二进制每一位上能跟C异或结果最大的数</span></span><br><span class="line">        <span class="type">int</span> v = C &gt;&gt; i &amp; <span class="number">1</span>; </span><br><span class="line">        <span class="comment">// 自带判空功能如果没有点, max_id会为0, 那就肯定不能满足&gt;=l</span></span><br><span class="line">        <span class="comment">// 而max_id又同时可以限制当前的点是在l r区间内</span></span><br><span class="line">        <span class="comment">// 另外, 如果tr[p][v^1]为空, 那么tr[p][v]就肯定不为空,并在l r区间, 因为根据</span></span><br><span class="line">        <span class="comment">// 插入的代码, 每个节点至少有一条当前s[i]的完整路径</span></span><br><span class="line">        <span class="comment">// 而如果tr[p][v^1]不为空但maxid小于l, 同理也能选取到tr[p][v]</span></span><br><span class="line">        <span class="keyword">if</span> (max_id[tr[p][v ^ <span class="number">1</span>]] &gt;= l) p = tr[p][v ^ <span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">else</span> p = tr[p][v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C ^ s[max_id[p]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// 前缀和, 初始化root[0]</span></span><br><span class="line">    max_id[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    root[<span class="number">0</span>] = ++idx;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">23</span>, <span class="number">0</span>, root[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] ^ x; <span class="comment">// 前缀和序列</span></span><br><span class="line">        root[i] = ++idx;</span><br><span class="line">        <span class="built_in">insert</span>(i, <span class="number">23</span>, root[i - <span class="number">1</span>], root[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r, x;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            n++;</span><br><span class="line">            s[n] = s[n - <span class="number">1</span>] ^ x;</span><br><span class="line">            root[n] = ++idx;</span><br><span class="line">            <span class="built_in">insert</span>(n, <span class="number">23</span>, root[n - <span class="number">1</span>], root[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">            <span class="comment">// 至少要包住第r个点, 所以用r-1, 否则会因为异或把root[r]抵消掉</span></span><br><span class="line">            <span class="comment">// l也同理</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(r - <span class="number">1</span>, s[n] ^ x, l - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-可持久化线段树（主席树）"><a href="#2-可持久化线段树（主席树）" class="headerlink" title="2. 可持久化线段树（主席树）"></a>2. 可持久化线段树（主席树）</h2><h3 id="题目链接：-16"><a href="#题目链接：-16" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/description/258/">最大异或和</a></p>
<h3 id="题解思路：-16"><a href="#题解思路：-16" class="headerlink" title="题解思路："></a>题解思路：</h3><p>此题可用方法：</p>
<ol>
<li>树套树：（$O(mlog^2n)$）支持修改</li>
<li>划分树：（$O(nlogn)$）不支持修改</li>
<li>主席树：（$O(nlogn)$）</li>
</ol>
<p>采用主席树：</p>
<p>核心：把新得点替换掉原来的点,结构一样，信息不一样</p>
<ol>
<li>离散化</li>
<li>在数值上建立线段树，维护每个数值区间个数，求整体第k小的数。</li>
</ol>
<p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220314091721203.png" alt=""></p>
<p>缺点：难以进行区间修改操作</p>
<p>0————-mid————-n-1     mid的左边的个数cnt如果大于k说明第k个数在左边，cnt &lt;= k 说明在右边</p>
<p>此题可以维护每个版本的各个数值区间的个数，因为每个版本结构都是一样的，但是只是信息不同，所以只要用第R个版本减去L-1个版本就可以得到[L， R]这一段这个区间里面0————-mid————-n-1有多少个数。 </p>
<h3 id="题目代码：-16"><a href="#题目代码：-16" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], root[N], idx;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;   <span class="comment">//左右孩子，不是区间</span></span><br><span class="line">    <span class="type">int</span> cnt; <span class="comment">//维护数值区间的个数</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span> + N * <span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), x) - nums.<span class="built_in">begin</span>(); <span class="comment">//返回第一个大于等于x的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = ++idx; <span class="comment">//一个新得节点</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> p; <span class="comment">//叶节点</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[p].l = <span class="built_in">build</span>(l, mid), tr[p].r = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> p;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = ++idx; <span class="comment">//一个新得节点</span></span><br><span class="line">    tr[q] = tr[p]; <span class="comment">//新节点指向旧节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;     <span class="comment">//叶节点</span></span><br><span class="line">        tr[q].cnt++;    <span class="comment">//当前这个值的元素个数+1</span></span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) tr[q].l = <span class="built_in">insert</span>(tr[p].l, l, mid, x);  <span class="comment">//元素比中间值小，往左边插入</span></span><br><span class="line">    <span class="keyword">else</span> tr[q].r = <span class="built_in">insert</span>(tr[p].r, mid + <span class="number">1</span>, r, x);      <span class="comment">//元素比中间值大，往右边插入</span></span><br><span class="line">    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;      <span class="comment">//父节点的总个数等于左右儿子节点的总个数</span></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此题可以维护每个版本的各个数值区间的个数</span></span><br><span class="line"><span class="comment">//因为每个版本结构都是一样的，但是只是信息不同</span></span><br><span class="line"><span class="comment">//所以只要用第R个版本减去L-1个版本就可以得到[L， R]这一段这个区间里面0---------mid---------n-1有多少个数。 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> q, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)<span class="keyword">return</span> r; <span class="comment">//找到</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// R版本减去 L-1版本就是【L, R】这个区间中添加的各个数</span></span><br><span class="line">    <span class="type">int</span> cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;  </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// k &lt;= cnt说明要找的元素在q的左子树里面</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt;= cnt) <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].l, tr[p].l, l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].r, tr[p].r, mid<span class="number">+1</span>, r, k - cnt);     <span class="comment">//减去左半部分总数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        nums.<span class="built_in">push_back</span>(a[i]); <span class="comment">//离散化数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//去重</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">//初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//相当于n次操作维护各个版本</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">//根据前一个版本创建一个新得节点指向前一个版本各个修改的信息</span></span><br><span class="line">        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>], <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="built_in">find</span>(a[i])); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m -- )&#123;</span><br><span class="line">        <span class="type">int</span> l, r, k;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nums[<span class="built_in">query</span>(root[r], root[l - <span class="number">1</span>], <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, k)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="平衡树——Treap"><a href="#平衡树——Treap" class="headerlink" title="平衡树——Treap"></a>平衡树——Treap</h1><p>treap、红黑树、splay、sbt、AVL</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>对于一棵树，我们可以做一些特殊的操作，来让它变换树的形态结构，但是最后的答案却是正确的。平衡树的精髓就是这个，就是改变树的形态结构，但是不改变最后的中序遍历,也就是答案数组。</p>
<ol>
<li><p>首先需要维护一个BST(二叉搜索树)，一个根节点p，左儿子一定小于他，右儿子大于它。</p>
</li>
<li><p>为了维护这个BST我们需要一个<strong>左旋zag和右旋zig</strong>，分别表示将根节点和左右儿子交换位置，使交换后还<strong>满足BST的性质</strong>。</p>
<p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220315114510822.png" alt=""></p>
</li>
<li><p>为了使得这个BST是一个尽可能随机的（添加随机数val<strong>维护这个堆</strong>）使得这个BST的期望更加好一些（防止出现一条链的情况使得BST的时间复杂度达到O(n)）</p>
</li>
</ol>
<p>操作：</p>
<ol>
<li>插入数值 xx。</li>
<li>删除数值 xx(若有多个相同的数，应只删除一个)。</li>
<li>查询数值 xx 的排名(若有多个相同的数，应输出最小的排名)。</li>
<li>查询排名为 xx 的数值。</li>
<li>求数值 xx 的前驱(前驱定义为小于 xx 的最大的数)。</li>
<li>求数值 xx 的后继(后继定义为大于 xx 的最小的数)。</li>
</ol>
<h2 id="1-普通平衡树"><a href="#1-普通平衡树" class="headerlink" title="1. 普通平衡树"></a>1. 普通平衡树</h2><h3 id="题目链接：-17"><a href="#题目链接：-17" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/description/258/">普通平衡树</a></p>
<h3 id="题解思路：-17"><a href="#题解思路：-17" class="headerlink" title="题解思路："></a>题解思路：</h3><p>Treap</p>
<ol>
<li>维护键值key——BST，同时维护随机值val——堆</li>
<li>这样使得这颗树时间复杂度更加趋近于（logn）,防止出现一条链</li>
</ol>
<h3 id="题目代码：-17"><a href="#题目代码：-17" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, root, idx;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> key, val;   <span class="comment">//key当前键值，val随机值，使得这个treap更加随机</span></span><br><span class="line">    <span class="type">int</span> cnt, size;  <span class="comment">//cnt当前节点的个数</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    tr[u].size = tr[tr[u].l].size + tr[tr[u].r].size + tr[u].cnt;<span class="comment">//字节点更新父节点信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新得节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123; </span><br><span class="line">    tr[ ++ idx].key = key;  <span class="comment">//新得节点的键值</span></span><br><span class="line">    tr[idx].val = <span class="built_in">rand</span>();   <span class="comment">//随机值，根据这个维护一个堆</span></span><br><span class="line">    tr[idx].cnt = tr[idx].size = <span class="number">1</span>; <span class="comment">//初始节点的个数等于1，以及当前子树的大小也是1</span></span><br><span class="line">    <span class="keyword">return</span> idx;             <span class="comment">//返回这个节点所对应的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zig</span><span class="params">(<span class="type">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].l;</span><br><span class="line">    tr[p].l = tr[q].r, tr[q].r = p, p = q; </span><br><span class="line">    <span class="built_in">pushup</span>(tr[p].r), <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zag</span><span class="params">(<span class="type">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].r;</span><br><span class="line">    tr[p].r = tr[q].l, tr[q].l = p, p = q;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[p].l), <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">get_node</span>(-INF), <span class="built_in">get_node</span>(INF);  <span class="comment">//创建两个哨兵</span></span><br><span class="line">    root = <span class="number">1</span>, tr[<span class="number">1</span>].r = <span class="number">2</span>;          </span><br><span class="line">    <span class="built_in">pushup</span>(root);                   <span class="comment">//更新</span></span><br><span class="line">    <span class="keyword">if</span> (tr[<span class="number">1</span>].val &lt; tr[<span class="number">2</span>].val) <span class="built_in">zag</span>(root);   <span class="comment">//父节点的val &lt; 右子节点的val左旋</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) p = <span class="built_in">get_node</span>(key);                      <span class="comment">//如果之前没有的话就创建一个新得节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key == key) tr[p].cnt ++ ;       <span class="comment">//如果之前存在就直接再cnt++</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key &gt; key)                       <span class="comment">//key小于当前节点的值往左边递归插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].l, key);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[p].l].val &gt; tr[p].val) <span class="built_in">zig</span>(p);    <span class="comment">//需要维护val    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                        <span class="comment">//key大于当前节点的值往右边递归插入</span></span><br><span class="line">        <span class="built_in">insert</span>(tr[p].r, key);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[p].r].val &gt; tr[p].val) <span class="built_in">zag</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushup</span>(p);  <span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;         <span class="comment">//不存在这个点，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tr[p].key == key) &#123;     </span><br><span class="line">        <span class="keyword">if</span> (tr[p].cnt &gt; <span class="number">1</span>) tr[p].cnt -- ;   <span class="comment">//这个点的数量大于1，数量--</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].l || tr[p].r) &#123;      <span class="comment">//这个点左右子树都不空</span></span><br><span class="line">            <span class="keyword">if</span> (!tr[p].r || tr[tr[p].l].val &gt; tr[tr[p].r].val) &#123;    <span class="comment">//右旋</span></span><br><span class="line">                <span class="built_in">zig</span>(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;                          <span class="comment">//左旋</span></span><br><span class="line">                <span class="built_in">zag</span>(p);</span><br><span class="line">                <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = <span class="number">0</span>; <span class="comment">//叶子节点，左右子树都空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[p].key &gt; key) <span class="built_in">remove</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">remove</span>(tr[p].r, key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushup</span>(p);  <span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过数值找排名</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_rank_by_key</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">if</span> (tr[p].key == key) <span class="keyword">return</span> tr[tr[p].l].size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &gt; key) <span class="keyword">return</span> <span class="built_in">get_rank_by_key</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> tr[tr[p].l].size + tr[p].cnt + <span class="built_in">get_rank_by_key</span>(tr[p].r, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过排名找数值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_key_by_rank</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;     </span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].size &gt;= rank) <span class="keyword">return</span> <span class="built_in">get_key_by_rank</span>(tr[p].l, rank);    </span><br><span class="line">    <span class="keyword">if</span> (tr[tr[p].l].size + tr[p].cnt &gt;= rank) <span class="keyword">return</span> tr[p].key;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_key_by_rank</span>(tr[p].r, rank - tr[tr[p].l].size - tr[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到严格小于key的最大数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prev</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &gt;= key) <span class="keyword">return</span> <span class="built_in">get_prev</span>(tr[p].l, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key, <span class="built_in">get_prev</span>(tr[p].r, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到严格大于key的最小数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &lt;= key) <span class="keyword">return</span> <span class="built_in">get_next</span>(tr[p].r, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key, <span class="built_in">get_next</span>(tr[p].l, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- ) &#123;</span><br><span class="line">        <span class="type">int</span> op, x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">insert</span>(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) <span class="built_in">remove</span>(root, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) cout &lt;&lt; <span class="built_in">get_rank_by_key</span>(root, x) - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) cout &lt;&lt; <span class="built_in">get_key_by_rank</span>(root, x + <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) cout &lt;&lt; <span class="built_in">get_prev</span>(root, x) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">get_next</span>(root, x) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-营业额统计"><a href="#2-营业额统计" class="headerlink" title="2. 营业额统计"></a>2. 营业额统计</h2><h3 id="题目链接：-18"><a href="#题目链接：-18" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/267/">营业额统计</a></p>
<h3 id="题解思路：-18"><a href="#题解思路：-18" class="headerlink" title="题解思路："></a>题解思路：</h3><p>可以用set的lower_bound(), upper_bound()</p>
<p>也可用平衡树</p>
<h3 id="题目代码：-18"><a href="#题目代码：-18" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">33000</span>, INF = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> key, val;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root, idx, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建新得节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_node</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    tr[++idx].key = key;</span><br><span class="line">    tr[idx].val = <span class="built_in">rand</span>(); <span class="comment">//使得平衡树更加随机，期望更高</span></span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_node</span>(-INF), <span class="built_in">get_node</span>(INF);</span><br><span class="line">    root = <span class="number">1</span>, tr[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zig</span><span class="params">(<span class="type">int</span> &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].l;</span><br><span class="line">    tr[p].l = tr[q].r, tr[q].r = p, p = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zag</span><span class="params">(<span class="type">int</span> &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = tr[p].r;</span><br><span class="line">    tr[p].r = tr[q].l, tr[q].l = p, p = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p = <span class="built_in">get_node</span>(key); <span class="comment">//没有这个节点就直接创建这个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key == key) <span class="keyword">return</span>;   <span class="comment">//之前有这个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[p].key &gt; key)&#123;           <span class="comment">//插入到当前节点左边</span></span><br><span class="line">        <span class="built_in">insert</span>(tr[p].l, key); </span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].l].val &gt; tr[p].val) <span class="comment">//检查子节点的val是否大于父节点</span></span><br><span class="line">            <span class="built_in">zig</span>(p);                     <span class="comment">//右旋</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(tr[p].r, key);</span><br><span class="line">        <span class="keyword">if</span>(tr[tr[p].r].val &gt; tr[p].val) <span class="comment">//检查子节点的val是否大于父节点</span></span><br><span class="line">            <span class="built_in">zag</span>(p);                     <span class="comment">//左旋</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到小于等于key的最大数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_prev</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> -INF;</span><br><span class="line">    <span class="keyword">if</span>(tr[p].key &gt; key) <span class="keyword">return</span> <span class="built_in">get_prev</span>(tr[p].l, key); <span class="comment">//往左边查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(tr[p].key, <span class="built_in">get_prev</span>(tr[p].r, key)); <span class="comment">//右边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到大于等于key的最小的数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[p].key &lt; key) <span class="keyword">return</span> <span class="built_in">get_next</span>(tr[p].r, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(tr[p].key, <span class="built_in">get_next</span>(tr[p].l, key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)res += x;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res += <span class="built_in">min</span>(x - <span class="built_in">get_prev</span>(root, x), <span class="built_in">get_next</span>(root, x) - x); <span class="comment">//x与x的前一个值的差值，x与后一个值的差值</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">insert</span>(root, x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><p>ac自动机 = trie + kmp</p>
<p>next[i]: 在p中以p[i]结尾的后缀，能够匹配从1开始的（非平凡）前缀的最大长度</p>
<p>ac自动机就是对trie求next</p>
<p><img src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/image-20220315144630861.png" alt=""></p>
<p>用BFS的思想，一层一层遍历，对应于一维求next数组</p>
<h2 id="1-搜索关键词"><a href="#1-搜索关键词" class="headerlink" title="1. 搜索关键词"></a>1. 搜索关键词</h2><h3 id="题目链接：-19"><a href="#题目链接：-19" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/description/1284/">搜索关键词</a></p>
<h3 id="题解思路：-19"><a href="#题解思路：-19" class="headerlink" title="题解思路："></a>题解思路：</h3><p>用BFS的思想，一层一层遍历，对应于一维求next数组</p>
<h3 id="题目代码：-19"><a href="#题目代码：-19" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, S = <span class="number">55</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tr[N * S][<span class="number">26</span>], cnt[N * S], idx;</span><br><span class="line"><span class="type">char</span> str[M];</span><br><span class="line"><span class="type">int</span> q[N * S], ne[N * S], tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trie树插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!tr[p][t]) tr[p][t] = ++ idx; <span class="comment">//创建一个节点</span></span><br><span class="line">        p = tr[p][t];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ; <span class="comment">//此节点个数++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于处理next数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (tr[<span class="number">0</span>][i])   <span class="comment">//如果第一个字母没有就不用入队</span></span><br><span class="line">            q[ ++ tt] = tr[<span class="number">0</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ ) &#123;    <span class="comment">//遍历当前节点的所有子节点</span></span><br><span class="line">            <span class="type">int</span> c = tr[t][i];   <span class="comment">//对应当前节点</span></span><br><span class="line">            <span class="keyword">if</span>(!c)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> j = ne[t];      <span class="comment">//对应前面的状态，也就是前面的层</span></span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; !tr[j][i]) j =  ne[j];   <span class="comment">//如果这个节点是空的话就查找ne数组</span></span><br><span class="line">            <span class="keyword">if</span>(tr[j][i]) j = tr[j][i];</span><br><span class="line">            ne[c] = j;</span><br><span class="line">            q[++tt] = c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="built_in">memset</span>(ne, <span class="number">0</span>, <span class="keyword">sizeof</span> ne);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="built_in">insert</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &amp;&amp; !tr[j][t]) j = ne[j];    </span><br><span class="line">            <span class="keyword">if</span>(tr[j][t]) j = tr[j][t];</span><br><span class="line">            <span class="type">int</span> p = j;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;</span><br><span class="line">                res += cnt[p];</span><br><span class="line">                cnt[p] = <span class="number">0</span>;</span><br><span class="line">                p = ne[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以优化成一个trie图</p>
<p>将空节点的指针指向它父节点的next指向的位置，这样就相当于每个空姐点都会直接指向它对应得next节点上去</p>
<p>有点路径压缩的感觉</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, S = <span class="number">55</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tr[N * S][<span class="number">26</span>], cnt[N * S], idx;</span><br><span class="line"><span class="type">char</span> str[M];</span><br><span class="line"><span class="type">int</span> q[N * S], ne[N * S], tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trie树插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!tr[p][t]) tr[p][t] = ++ idx; <span class="comment">//创建一个节点</span></span><br><span class="line">        p = tr[p][t];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ; <span class="comment">//此节点个数++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于处理next数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (tr[<span class="number">0</span>][i])   <span class="comment">//如果第一个字母没有就不用入队</span></span><br><span class="line">            q[ ++ tt] = tr[<span class="number">0</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ ) &#123;    <span class="comment">//遍历当前节点的所有子节点</span></span><br><span class="line">            <span class="type">int</span> p = tr[t][i];               <span class="comment">//对应当前节点</span></span><br><span class="line">            <span class="keyword">if</span>(!p) tr[t][i] = tr[ne[t]][i]; <span class="comment">//直接跳到对应得位置，有点路径压缩的感觉</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ne[p] = tr[ne[t]][i];       </span><br><span class="line">                q[++ tt] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="built_in">memset</span>(ne, <span class="number">0</span>, <span class="keyword">sizeof</span> ne);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="built_in">insert</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">            <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            j = tr[j][t]; <span class="comment">//下一个节点</span></span><br><span class="line">            <span class="type">int</span> p = j;</span><br><span class="line">            <span class="keyword">while</span>(p)&#123;       <span class="comment">//下一个节点，不为空</span></span><br><span class="line">                res += cnt[p];</span><br><span class="line">                cnt[p] = <span class="number">0</span>;</span><br><span class="line">                p = ne[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-单词"><a href="#2-单词" class="headerlink" title="2. 单词"></a>2. 单词</h2><h3 id="题目链接：-20"><a href="#题目链接：-20" class="headerlink" title="题目链接："></a>题目链接：</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.acwing.com/problem/content/description/1287/">单词</a></p>
<h3 id="题解思路：-20"><a href="#题解思路：-20" class="headerlink" title="题解思路："></a>题解思路：</h3><p>去求所有满足要求的前缀个数：</p>
<p>所有满足要求的前缀其后缀一定等于原串单词。</p>
<p>需要反向来求：</p>
<p>trie是通过next指针，根据地推的思想一直往前推，next可以求出前一个满足要求的前缀（可以和后缀匹配），可以一直跟着next指针一直往前走。</p>
<p>对于i来说可以用next指针将f[i] 累加到f[next[i]]上去，f的累加相当于是有向无环图，所有的和都会累加到终止节点上去，可以用拓扑排序的方法来求最终节点。</p>
<h3 id="题目代码：-20"><a href="#题目代码：-20" class="headerlink" title="题目代码："></a>题目代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">26</span>], f[N], q[N], ne[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> id[<span class="number">210</span>];   <span class="comment">//单词编号 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p][t]) tr[p][t] = ++idx;    <span class="comment">//创建新的节点</span></span><br><span class="line">        p = tr[p][t];</span><br><span class="line">        f[p] ++;    <span class="comment">//每一个结束位置都代表一个字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">    id[x] = p;  <span class="comment">//记录每个单词结尾所在地方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])q[++tt] = tr[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>;i ++)&#123;</span><br><span class="line">            <span class="type">int</span> &amp;p = tr[t][i];</span><br><span class="line">            <span class="keyword">if</span>(!p) p = tr[ne[t]][i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ne[p] = tr[ne[t]][i];</span><br><span class="line">                q[++tt] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面是从根节点一层一层求得，所以拓扑排序是倒序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idx - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) f[ne[q[i]]] += f[q[i]];    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[id[i]]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://jpcly.cn">jpc901</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://jpcly.cn/archives/41da5bdd.html">https://jpcly.cn/archives/41da5bdd.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jpcly.cn" target="_blank">贾小白博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/s4..jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222215434.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222215434.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222215417.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/QQ图片20220222215417.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/archives/4c2eef42.html" title="并查集-高级数据结构"><img class="cover" src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/s2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">并查集-高级数据结构</div></div></a></div><div class="next-post pull-right"><a href="/archives/10f14ed7.html" title="图论"><img class="cover" src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/1103346.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/archives/4c2eef42.html" title="并查集-高级数据结构"><img class="cover" src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/s2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-07</div><div class="title">并查集-高级数据结构</div></div></a></div><div><a href="/archives/47530237.html" title="146-LRU 缓存（力扣题解）"><img class="cover" src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/s2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-03</div><div class="title">146-LRU 缓存（力扣题解）</div></div></a></div><div><a href="/archives/1d059c01.html" title="力扣336场周赛（力扣题解）"><img class="cover" src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/s4..jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-12</div><div class="title">力扣336场周赛（力扣题解）</div></div></a></div><div><a href="/archives/14a387ba.html" title="力扣339场周赛（力扣题解）"><img class="cover" src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/s4..jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-02</div><div class="title">力扣339场周赛（力扣题解）</div></div></a></div><div><a href="/archives/e8bdeba4.html" title="力扣-系列算法题"><img class="cover" src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/s2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-28</div><div class="title">力扣-系列算法题</div></div></a></div><div><a href="/archives/18d07328.html" title="牛客寒假集训4J题（分解质因数+埃氏筛）"><img class="cover" src="https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/s2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-22</div><div class="title">牛客寒假集训4J题（分解质因数+埃氏筛）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E6%A6%82"><span class="toc-number">1.1.</span> <span class="toc-text">总概</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1250-%E6%A0%BC%E5%AD%90%E6%B8%B8%E6%88%8F"><span class="toc-number">1.2.</span> <span class="toc-text">1250. 格子游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1252-%E6%90%AD%E9%85%8D%E8%B4%AD%E4%B9%B0"><span class="toc-number">1.3.</span> <span class="toc-text">1252. 搭配购买</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#237-%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">237. 程序自动分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-2"><span class="toc-number">1.4.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238-%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4"><span class="toc-number">1.5.</span> <span class="toc-text">238. 银河英雄传说</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-3"><span class="toc-number">1.5.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-3"><span class="toc-number">1.5.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-3"><span class="toc-number">1.5.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E5%A5%87%E5%81%B6%E6%B8%B8%E6%88%8F"><span class="toc-number">1.6.</span> <span class="toc-text">239. 奇偶游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-4"><span class="toc-number">1.6.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-4"><span class="toc-number">1.6.2.</span> <span class="toc-text">题解思路：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%88%E6%89%A9%E5%B1%95%E5%9F%9F%EF%BC%89"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">方法一（扩展域）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%88%E5%B8%A6%E8%BE%B9%E6%9D%83%EF%BC%89"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">方法二（带边权）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-4"><span class="toc-number">1.6.3.</span> <span class="toc-text">题目代码：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%EF%BC%88%E6%89%A9%E5%B1%95%E5%9F%9F%EF%BC%89"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">方法一 （扩展域）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%88%E5%B8%A6%E8%BE%B9%E6%9D%83%EF%BC%89-1"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">方法二（带边权）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">朴素算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-1"><span class="toc-number">2.1.2.</span> <span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lowbit"><span class="toc-number">2.1.3.</span> <span class="toc-text">lowbit()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%80%9D%E6%83%B3"><span class="toc-number">2.1.4.</span> <span class="toc-text">树状数组思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.5.</span> <span class="toc-text">树状数组操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#add-x-k-%E8%A1%A8%E7%A4%BA%E5%B0%86%E5%BA%8F%E5%88%97%E4%B8%AD%E7%AC%ACx%E4%B8%AA%E6%95%B0%E5%8A%A0%E4%B8%8Ak%E3%80%82"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">add(x, k)表示将序列中第x个数加上k。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ask-x-%E8%A1%A8%E7%A4%BA%E5%B0%86%E6%9F%A5%E8%AF%A2%E5%BA%8F%E5%88%97%E5%89%8Dx%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">ask(x)表示将查询序列前x个数的和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.6.</span> <span class="toc-text">树状数组初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#241-%E6%A5%BC%E5%85%B0%E5%9B%BE%E8%85%BE"><span class="toc-number">2.2.</span> <span class="toc-text">241. 楼兰图腾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-5"><span class="toc-number">2.2.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-5"><span class="toc-number">2.2.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-5"><span class="toc-number">2.2.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#242-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.</span> <span class="toc-text">242. 一个简单的整数问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-6"><span class="toc-number">2.3.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-6"><span class="toc-number">2.3.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-6"><span class="toc-number">2.3.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#243-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%982"><span class="toc-number">2.4.</span> <span class="toc-text">243. 一个简单的整数问题2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-7"><span class="toc-number">2.4.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-7"><span class="toc-number">2.4.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-7"><span class="toc-number">2.4.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#244-%E8%B0%9C%E4%B8%80%E6%A0%B7%E7%9A%84%E7%89%9B"><span class="toc-number">2.5.</span> <span class="toc-text">244. 谜一样的牛</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-8"><span class="toc-number">2.5.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-8"><span class="toc-number">2.5.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-8"><span class="toc-number">2.5.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">操作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.1.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">基本知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">1. 最大数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-9"><span class="toc-number">3.2.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-9"><span class="toc-number">3.2.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-9"><span class="toc-number">3.2.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%A0%E8%83%BD%E5%9B%9E%E7%AD%94%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E5%90%97"><span class="toc-number">3.3.</span> <span class="toc-text">2. 你能回答这些问题吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-10"><span class="toc-number">3.3.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-10"><span class="toc-number">3.3.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-10"><span class="toc-number">3.3.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">3. 区间最大公约数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-11"><span class="toc-number">3.4.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-11"><span class="toc-number">3.4.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-11"><span class="toc-number">3.4.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%982"><span class="toc-number">3.5.</span> <span class="toc-text">4. 一个简单的整数问题2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-12"><span class="toc-number">3.5.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-12"><span class="toc-number">3.5.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-12"><span class="toc-number">3.5.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BA%9A%E7%89%B9%E5%85%B0%E8%92%82%E6%96%AF"><span class="toc-number">3.6.</span> <span class="toc-text">5. 亚特兰蒂斯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-13"><span class="toc-number">3.6.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-13"><span class="toc-number">3.6.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-13"><span class="toc-number">3.6.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BB%B4%E6%8A%A4%E5%BA%8F%E5%88%97"><span class="toc-number">3.7.</span> <span class="toc-text">6. 维护序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-14"><span class="toc-number">3.7.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-14"><span class="toc-number">3.7.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-14"><span class="toc-number">3.7.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">可持久化数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C"><span class="toc-number">4.1.</span> <span class="toc-text">1. 最大异或和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-15"><span class="toc-number">4.1.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-15"><span class="toc-number">4.1.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-15"><span class="toc-number">4.1.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">2. 可持久化线段树（主席树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-16"><span class="toc-number">4.2.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-16"><span class="toc-number">4.2.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-16"><span class="toc-number">4.2.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%A0%91%E2%80%94%E2%80%94Treap"><span class="toc-number">5.</span> <span class="toc-text">平衡树——Treap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text">1. 普通平衡树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-17"><span class="toc-number">5.2.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-17"><span class="toc-number">5.2.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-17"><span class="toc-number">5.2.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%90%A5%E4%B8%9A%E9%A2%9D%E7%BB%9F%E8%AE%A1"><span class="toc-number">5.3.</span> <span class="toc-text">2. 营业额统计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-18"><span class="toc-number">5.3.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-18"><span class="toc-number">5.3.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-18"><span class="toc-number">5.3.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AC%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">6.</span> <span class="toc-text">AC自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">6.1.</span> <span class="toc-text">1. 搜索关键词</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-19"><span class="toc-number">6.1.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-19"><span class="toc-number">6.1.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-19"><span class="toc-number">6.1.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8D%95%E8%AF%8D"><span class="toc-number">6.2.</span> <span class="toc-text">2. 单词</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5%EF%BC%9A-20"><span class="toc-number">6.2.1.</span> <span class="toc-text">题目链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF%EF%BC%9A-20"><span class="toc-number">6.2.2.</span> <span class="toc-text">题解思路：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BB%A3%E7%A0%81%EF%BC%9A-20"><span class="toc-number">6.2.3.</span> <span class="toc-text">题目代码：</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://jiapengcheng.obs.cn-north-4.myhuaweicloud.com/img/s4..jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By jpc901</div><div class="footer_custom_text"><div><a target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn/">鄂ICP备2022006987号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>